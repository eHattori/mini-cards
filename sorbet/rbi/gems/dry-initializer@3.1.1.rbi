# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-initializer` gem.
# Please instead update this file by running `bin/tapioca gem dry-initializer`.

# The nested structure that takes nested hashes with indifferent access
module Dry; end

# DSL for declaring params and options of class initializers
module Dry::Initializer
  extend ::Dry::Initializer::DSL

  # Gem-related configuration
  #
  # @return [Dry::Initializer::Config]
  def dry_initializer; end

  # Adds or redefines an option of [#dry_initializer]
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol]
  # @param type [#call, nil] (nil)
  # @param opts [Hash] a customizable set of options
  # @return [self] itself
  # @yield block with nested definition
  def option(name, type = T.unsafe(nil), **opts, &block); end

  # Adds or redefines a parameter of [#dry_initializer]
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol]
  # @param type [#call, nil] (nil)
  # @param opts [Hash] a customizable set of options
  # @return [self] itself
  # @yield block with nested definition
  def param(name, type = T.unsafe(nil), **opts, &block); end

  private

  def inherited(klass); end
end

# @private
module Dry::Initializer::Builders; end

# @private
class Dry::Initializer::Builders::Attribute
  # @return [Attribute] a new instance of Attribute
  def initialize(definition); end

  def call; end

  private

  def assignment_line; end
  def coercion_line; end
  def default_line; end
  def definition_line; end
  def lines; end
  def optional_reader; end
  def reader_line; end
  def required_reader; end

  class << self
    def [](definition); end
  end
end

# @private
class Dry::Initializer::Builders::Initializer
  # @return [Initializer] a new instance of Initializer
  def initialize(config); end

  def call; end

  private

  def define_line; end
  def end_line; end
  def lines; end
  def options_lines; end
  def params_lines; end
  def undef_line; end

  class << self
    def [](config); end
  end
end

# @private
class Dry::Initializer::Builders::Reader
  # @return [Reader] a new instance of Reader
  def initialize(definition); end

  def call; end

  private

  def attribute_line; end
  def lines; end
  def method_lines; end
  def type_line; end
  def undef_line; end

  class << self
    def [](definition); end
  end
end

# @private
class Dry::Initializer::Builders::Signature
  # @return [Signature] a new instance of Signature
  def initialize(config); end

  def call; end

  private

  def optional_params; end
  def options; end
  def required_params; end

  class << self
    def [](config); end
  end
end

# Gem-related configuration of some class
class Dry::Initializer::Config
  # @return [Config] a new instance of Config
  def initialize(extended_class = T.unsafe(nil), null: T.unsafe(nil)); end

  # The hash of assigned attributes for an instance of the [#extended_class]
  #
  # @param instance [Dry::Initializer::Instance]
  # @return [Hash<Symbol, Object>]
  def attributes(instance); end

  # List of configs of all subclasses of the [#extended_class]
  #
  # @return [Array<Dry::Initializer::Config>]
  def children; end

  # Code of the `#__initialize__` method
  #
  # @return [String]
  def code; end

  # @return [Hash<Symbol, Dry::Initializer::Definition>] hash of attribute definitions with their source names
  def definitions; end

  # @return [Hash<Symbol, Dry::Initializer::Definition>] hash of attribute definitions with their source names
  def extended_class; end

  # Finalizes config
  #
  # @return [self]
  def finalize; end

  # Human-readable representation of configured params and options
  #
  # @return [String]
  def inch; end

  # @return [Module] reference to the module to be included into class
  def mixin; end

  # @return [Hash<Symbol, Dry::Initializer::Definition>] hash of attribute definitions with their source names
  def null; end

  # Adds or redefines an option of [#dry_initializer]
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol]
  # @param type [#call, nil] (nil)
  # @param opts [Hash] a customizable set of options
  # @return [self] itself
  def option(name, type = T.unsafe(nil), **opts, &block); end

  # List of definitions for initializer options
  #
  # @return [Array<Dry::Initializer::Definition>]
  def options; end

  # Adds or redefines a parameter
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param name [Symbol]
  # @param type [#call, nil] (nil)
  # @param opts [Hash] a customizable set of options
  # @return [self] itself
  def param(name, type = T.unsafe(nil), **opts, &block); end

  # List of definitions for initializer params
  #
  # @return [Array<Dry::Initializer::Definition>]
  def params; end

  # @return [Hash<Symbol, Dry::Initializer::Definition>] hash of attribute definitions with their source names
  def parent; end

  # The hash of public attributes for an instance of the [#extended_class]
  #
  # @param instance [Dry::Initializer::Instance]
  # @return [Hash<Symbol, Object>]
  def public_attributes(instance); end

  private

  def add_definition(option, name, type, block, **opts); end
  def check_order_of_params; end

  # @raise [SyntaxError]
  def check_type(previous, current); end

  def final_definitions; end
end

# Module-level DSL
module Dry::Initializer::DSL
  # Returns a version of the module with custom settings
  #
  # @option settings
  # @param settings [Hash] a customizable set of options
  # @return [Dry::Initializer]
  def [](undefined: T.unsafe(nil), **_arg1); end

  # Returns mixin module to be included to target class by hand
  #
  # @return [Module]
  # @yield proc defining params and options
  def define(procedure = T.unsafe(nil), &block); end

  # Setting for null (undefined value)
  #
  # @return [nil, Dry::Initializer::UNDEFINED]
  def null; end

  private

  def extended(klass); end

  class << self
    private

    # @private
    def extended(mod); end
  end
end

# Base class for parameter or option definitions
# Defines methods to add corresponding reader to the class,
# and build value of instance attribute.
#
# @abstract
# @private
class Dry::Initializer::Definition
  # @return [Definition] a new instance of Definition
  def initialize(**options); end

  def ==(other); end
  def code; end

  # Returns the value of attribute default.
  def default; end

  # Returns the value of attribute desc.
  def desc; end

  def inch; end
  def inspect; end

  # Returns the value of attribute ivar.
  def ivar; end

  def name; end

  # Returns the value of attribute null.
  def null; end

  # Returns the value of attribute option.
  def option; end

  # Returns the value of attribute optional.
  def optional; end

  def options; end

  # Returns the value of attribute reader.
  def reader; end

  # Returns the value of attribute source.
  def source; end

  # Returns the value of attribute target.
  def target; end

  def to_s; end
  def to_str; end

  # Returns the value of attribute type.
  def type; end
end

module Dry::Initializer::Dispatchers
  extend ::Dry::Initializer::Dispatchers

  # Registers a new dispatcher
  #
  # @param dispatcher [#call]
  # @return [self] itself
  def <<(dispatcher); end

  # Normalizes the source set of options
  #
  # @param options [Hash<Symbol, Object>]
  # @return [Hash<Symbol, Objct>] normalized set of options
  def call(**options); end

  # @return [Object]
  def null; end

  # @return [Object]
  def null=(_arg0); end

  private

  def pipeline; end
end

module Dry::Initializer::Dispatchers::BuildNestedType
  extend ::Dry::Initializer::Dispatchers::BuildNestedType

  def call(parent:, source:, target:, type: T.unsafe(nil), block: T.unsafe(nil), **options); end

  private

  def build_nested_type(parent, name, block); end
  def build_struct(klass_name, block); end

  # @raise [ArgumentError]
  def check_certainty!(source, type, block); end

  # @raise [ArgumentError]
  def check_name!(name, block); end

  def full_name(parent, name); end
end

module Dry::Initializer::Dispatchers::CheckType
  extend ::Dry::Initializer::Dispatchers::CheckType

  def call(source:, type: T.unsafe(nil), wrap: T.unsafe(nil), **options); end

  private

  # @raise [ArgumentError]
  def check_arity!(_source, type, wrap); end

  # @raise [ArgumentError]
  def check_if_callable!(source, type); end
end

module Dry::Initializer::Dispatchers::PrepareDefault
  extend ::Dry::Initializer::Dispatchers::PrepareDefault

  def call(default: T.unsafe(nil), optional: T.unsafe(nil), **options); end

  private

  def callable!(default); end
  def check_arity!(default); end

  # @raise [TypeError]
  def invalid!(default); end
end

module Dry::Initializer::Dispatchers::PrepareIvar
  private

  def call(target:, **options); end

  class << self
    def call(target:, **options); end
  end
end

module Dry::Initializer::Dispatchers::PrepareOptional
  private

  def call(optional: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), **options); end

  class << self
    def call(optional: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), **options); end
  end
end

module Dry::Initializer::Dispatchers::PrepareReader
  extend ::Dry::Initializer::Dispatchers::PrepareReader

  def call(target: T.unsafe(nil), reader: T.unsafe(nil), **options); end

  private

  # @raise [ArgumentError]
  def invalid_reader!(target, _reader); end
end

module Dry::Initializer::Dispatchers::PrepareSource
  private

  def call(source:, **options); end

  class << self
    def call(source:, **options); end
  end
end

module Dry::Initializer::Dispatchers::PrepareTarget
  extend ::Dry::Initializer::Dispatchers::PrepareTarget

  def call(source:, target: T.unsafe(nil), as: T.unsafe(nil), **options); end

  private

  # @raise [ArgumentError]
  def check_reserved_names!(target); end

  # @raise [ArgumentError]
  def check_ruby_name!(target); end
end

# List of variable names reserved by the gem
Dry::Initializer::Dispatchers::PrepareTarget::RESERVED = T.let(T.unsafe(nil), Array)

module Dry::Initializer::Dispatchers::UnwrapType
  extend ::Dry::Initializer::Dispatchers::UnwrapType

  def call(type: T.unsafe(nil), wrap: T.unsafe(nil), **options); end

  private

  def unwrap(type, count); end
end

module Dry::Initializer::Dispatchers::WrapType
  extend ::Dry::Initializer::Dispatchers::WrapType

  def call(type: T.unsafe(nil), wrap: T.unsafe(nil), **options); end

  private

  def wrap_value(value, count, type); end
  def wrapped_type(type, count); end
end

# @private
module Dry::Initializer::Mixin
  include ::Dry::Initializer
  extend ::Dry::Initializer::DSL

  class << self
    # @deprecated
    def extended(klass); end
  end
end

# @private
module Dry::Initializer::Mixin::Local
  def inspect; end

  # Returns the value of attribute klass.
  def klass; end

  def to_s; end
  def to_str; end

  private

  def included(klass); end
end

# @private
module Dry::Initializer::Mixin::Root
  def initialize(*_arg0, &_arg1); end
end

class Dry::Initializer::Struct
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # Represents event data as a nested hash with deeply stringified keys
  #
  # @return [Hash<String, ...>]
  def to_h; end

  private

  def __hashify(value); end

  class << self
    def call(options); end
    def new(options); end
  end
end

module Dry::Initializer::UNDEFINED; end
