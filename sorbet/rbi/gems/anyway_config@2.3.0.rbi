# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `anyway_config` gem.
# Please instead update this file by running `bin/tapioca gem anyway_config`.

module Anyway
  class << self
    def env; end
    def loaders; end
  end
end

module Anyway::AutoCast
  class << self
    def call(val); end
    def cast_hash(obj); end
    def coerce(_key, val); end
  end
end

Anyway::AutoCast::ARRAY_RXP = T.let(T.unsafe(nil), Regexp)

class Anyway::Config
  include ::Anyway::Rails::Config
  include ::Anyway::OptparseConfig
  include ::Anyway::DynamicConfig
  extend ::Anyway::OptparseConfig::ClassMethods
  extend ::Anyway::DynamicConfig::ClassMethods
  extend ::Anyway::RBSGenerator
  extend ::Anyway::Rails::Config::ClassMethods

  def initialize(overrides = T.unsafe(nil)); end

  def clear; end
  def config_name; end
  def deconstruct_keys(keys); end
  def dig(*keys); end
  def dup; end
  def env_prefix; end
  def inspect; end
  def load(overrides = T.unsafe(nil)); end
  def load_from_sources(base_config, **options); end
  def pretty_print(q); end
  def reload(overrides = T.unsafe(nil)); end
  def resolve_config_path(name, env_prefix); end
  def to_h; end
  def to_source_trace; end

  private

  def __trace__; end
  def __type_caster__; end
  def raise_validation_error(msg); end
  def validate_required_attributes!; end
  def values; end
  def write_config_attr(key, val); end

  class << self
    def attr_config(*args, **hargs); end
    def coerce_types(mapping); end
    def coercion_mapping; end
    def config_attributes; end
    def config_name(val = T.unsafe(nil)); end
    def current_env; end
    def defaults; end
    def disable_auto_cast!; end
    def env_prefix(val = T.unsafe(nil)); end
    def explicit_config_name; end
    def explicit_config_name?; end
    def fallback_type_caster(val = T.unsafe(nil)); end
    def filter_by_env(names, env); end
    def load_callbacks; end
    def names_with_exclude_env_option(names, env); end
    def new_empty_config; end
    def on_load(*names, &block); end
    def required(*names, env: T.unsafe(nil)); end
    def required_attributes; end
    def type_caster(val = T.unsafe(nil)); end

    private

    def accessors_module; end
    def build_config_name; end
    def define_config_accessor(*names); end
    def validate_param_names!(names); end
  end
end

class Anyway::Config::BlockCallback
  def initialize(block); end

  def apply_to(config); end
  def block; end
end

Anyway::Config::ENV_OPTION_EXCLUDE_KEY = T.let(T.unsafe(nil), Symbol)
class Anyway::Config::Error < ::StandardError; end

class Anyway::Config::NamedCallback
  def initialize(name); end

  def apply_to(config); end
  def name; end
end

Anyway::Config::PARAM_NAME = T.let(T.unsafe(nil), Regexp)
Anyway::Config::RESERVED_NAMES = T.let(T.unsafe(nil), Array)
class Anyway::Config::ValidationError < ::Anyway::Config::Error; end
Anyway::DEFAULT_CONFIGS_PATH = T.let(T.unsafe(nil), String)

module Anyway::DynamicConfig
  mixes_in_class_methods ::Anyway::DynamicConfig::ClassMethods

  class << self
    def included(base); end
  end
end

module Anyway::DynamicConfig::ClassMethods
  def for(name, auto_cast: T.unsafe(nil), **options); end
end

class Anyway::Env
  include ::Anyway::Tracing

  def initialize(type_cast: T.unsafe(nil)); end

  def clear; end
  def data; end
  def fetch(prefix); end
  def fetch_with_trace(prefix); end
  def traces; end
  def type_cast; end

  private

  def parse_env(prefix); end
end

module Anyway::Ext; end

# Extend Object through refinements
module Anyway::Ext::DeepDup; end

# Add #deep_freeze to hashes and arrays
module Anyway::Ext::DeepFreeze; end

# Extend Hash through refinements
module Anyway::Ext::Hash; end

module Anyway::Loaders; end

class Anyway::Loaders::Base
  include ::Anyway::Tracing

  def initialize(local:); end

  def use_local?; end

  class << self
    def call(local: T.unsafe(nil), **opts); end
  end
end

class Anyway::Loaders::Env < ::Anyway::Loaders::Base
  def call(env_prefix:, **_options); end
end

class Anyway::Loaders::Registry
  def initialize; end

  def append(id, handler = T.unsafe(nil), &block); end
  def delete(id); end
  def each(&block); end
  def freeze; end
  def insert_after(another_id, id, handler = T.unsafe(nil), &block); end
  def insert_before(another_id, id, handler = T.unsafe(nil), &block); end
  def override(id, handler); end
  def prepend(id, handler = T.unsafe(nil), &block); end
  def registry; end

  private

  def find(id); end
  def insert_at(index, id, handler); end
end

class Anyway::Loaders::YAML < ::Anyway::Loaders::Base
  def call(config_path:, **_options); end

  private

  def config_with_env(config); end

  # @return [Boolean]
  def environmental?(parsed_yml); end

  def load_base_yml(path); end
  def load_local_yml(path); end
  def local_config_path(path); end
  def parse_yml(path); end
  def relative_config_path(path); end
end

module Anyway::NoCast
  class << self
    def call(val); end
    def coerce(_key, val); end
  end
end

# Initializes the OptionParser instance using the given configuration
class Anyway::OptionParserBuilder
  class << self
    def call(options); end

    private

    def option_parser_on_args(key, flag: T.unsafe(nil), desc: T.unsafe(nil), type: T.unsafe(nil)); end
  end
end

# Adds ability to use script options as the source
# of configuration (via optparse)
module Anyway::OptparseConfig
  mixes_in_class_methods ::Anyway::OptparseConfig::ClassMethods

  def option_parser; end
  def parse_options!(options); end

  class << self
    # @private
    def included(base); end
  end
end

module Anyway::OptparseConfig::ClassMethods
  def describe_options(**hargs); end
  def extend_options(&block); end
  def flag_options(*args); end
  def ignore_options(*args); end
  def option_parser_descriptors; end
  def option_parser_extensions; end
  def option_parser_options; end
end

module Anyway::RBSGenerator
  # Generate RBS signature from a config class
  def to_rbs; end
end

Anyway::RBSGenerator::TYPE_TO_CLASS = T.let(T.unsafe(nil), Hash)
module Anyway::Rails; end

# Enhance config to be more Railsy-like:
# â€“ accept hashes with indeferent access
# - load data from secrets
# - recognize Rails env when loading from YML
module Anyway::Rails::Config; end

module Anyway::Rails::Config::ClassMethods
  # Make defaults to be a Hash with indifferent access
  def new_empty_config; end
end

module Anyway::Rails::Loaders; end

class Anyway::Rails::Loaders::Credentials < ::Anyway::Loaders::Base
  def call(name:, **_options); end

  private

  def credentials_path; end
  def local_credentials(name); end
end

Anyway::Rails::Loaders::Credentials::LOCAL_CONTENT_PATH = T.let(T.unsafe(nil), String)

class Anyway::Rails::Loaders::Secrets < ::Anyway::Loaders::Base
  def call(name:, **_options); end

  private

  def secrets; end
end

class Anyway::Rails::Loaders::YAML < ::Anyway::Loaders::YAML; end
class Anyway::Railtie < ::Rails::Railtie; end

# Use Settings name to not confuse with Config.
#
# Settings contain the library-wide configuration.
class Anyway::Settings
  class << self
    def app_root; end

    # Returns the value of attribute autoload_static_config_path.
    def autoload_static_config_path; end

    def autoload_static_config_path=(val); end

    # Returns the value of attribute autoloader.
    def autoloader; end

    def cleanup_autoload_paths; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def current_environment; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def current_environment=(_arg0); end

    # A proc returning a path to YML config file given the config name
    def default_config_path; end

    def default_config_path=(val); end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def default_environmental_key; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def default_environmental_key=(_arg0); end

    # @return [Boolean]
    def default_environmental_key?; end

    def future; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def known_environments; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def known_environments=(_arg0); end

    # Enable source tracing
    def tracing_enabled; end

    # Enable source tracing
    def tracing_enabled=(_arg0); end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def use_local_files; end

    # Define whether to load data from
    # *.yml.local (or credentials/local.yml.enc)
    def use_local_files=(_arg0); end
  end
end

# Future encapsulates settings that will be introduced in the upcoming version
# with the default values, which could break compatibility
class Anyway::Settings::Future
  # @return [Future] a new instance of Future
  def initialize; end

  def unwrap_known_environments; end
  def unwrap_known_environments=(val); end
  def use(*names); end

  private

  # Returns the value of attribute store.
  def store; end

  class << self
    def setting(name, default_value); end
    def settings; end
  end
end

module Anyway::Tracing
  private

  def trace!(type, *path, **opts); end

  class << self
    def capture; end
    def current_trace; end
    def current_trace_source; end
    def source_stack; end
    def trace!(type, *path, **opts); end
    def trace_stack; end
    def tracing?; end
    def with_trace_source(src); end

    private

    def accessor_source(location); end
  end
end

class Anyway::Tracing::Trace
  def initialize(type = T.unsafe(nil), value = T.unsafe(nil), **source); end

  def clear; end
  def dig(*_arg0, &_arg1); end
  def dup; end
  def keep_if(*_arg0, &_arg1); end
  def merge!(another_trace); end
  def merge_values(hash, **opts); end
  def pretty_print(q); end
  def record_value(val, *path, **opts); end
  def source; end
  def to_h; end
  def trace?; end
  def type; end
  def value; end
end

Anyway::Tracing::Trace::UNDEF = T.let(T.unsafe(nil), Object)

# TypeCaster is an object responsible for type-casting.
# It uses a provided types registry and mapping, and also
# accepts a fallback typecaster.
class Anyway::TypeCaster
  # @return [TypeCaster] a new instance of TypeCaster
  def initialize(mapping, registry: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def coerce(key, val, config: T.unsafe(nil)); end

  private

  # Returns the value of attribute fallback.
  def fallback; end

  # Returns the value of attribute mapping.
  def mapping; end

  # Returns the value of attribute registry.
  def registry; end
end

# Contains a mapping between type IDs/names and deserializers
class Anyway::TypeRegistry
  # @return [TypeRegistry] a new instance of TypeRegistry
  def initialize; end

  def accept(name_or_object, &block); end
  def deserialize(raw, type_id, array: T.unsafe(nil)); end
  def dup; end

  private

  # Returns the value of attribute registry.
  def registry; end

  class << self
    def default; end
  end
end

module Anyway::Utils
  class << self
    def deep_merge!(source, other); end
  end
end

Anyway::VERSION = T.let(T.unsafe(nil), String)
