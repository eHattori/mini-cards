# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord` gem.
# Please instead update this file by running `bin/tapioca gem activerecord`.

module ActiveRecord
  extend ::ActiveSupport::Autoload

  class << self
    def eager_load!; end

    # Returns the version of the currently loaded Active Record as a <tt>Gem::Version</tt>
    def gem_version; end

    # Returns the version of the currently loaded ActiveRecord as a <tt>Gem::Version</tt>
    def version; end
  end
end

# = Active Record Errors
#
# Generic Active Record exception class.
class ActiveRecord::ActiveRecordError < ::StandardError; end

# Raised when Active Record cannot find database adapter specified in
# +config/database.yml+ or programmatically.
class ActiveRecord::AdapterNotFound < ::ActiveRecord::ActiveRecordError; end

# Raised when adapter not specified on connection (or configuration file
# +config/database.yml+ misses adapter field).
class ActiveRecord::AdapterNotSpecified < ::ActiveRecord::ActiveRecordError; end

# See ActiveRecord::Aggregations::ClassMethods for documentation
module ActiveRecord::Aggregations
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Aggregations::ClassMethods

  def reload(*_arg0); end

  private

  def clear_aggregation_cache; end
  def init_internals; end
  def initialize_dup(*_arg0); end
end

# Active Record implements aggregation through a macro-like class method called #composed_of
# for representing attributes as value objects. It expresses relationships like "Account [is]
# composed of Money [among other things]" or "Person [is] composed of [an] address". Each call
# to the macro adds a description of how the value objects are created from the attributes of
# the entity object (when the entity is initialized either as a new object or from finding an
# existing object) and how it can be turned back into attributes (when the entity is saved to
# the database).
#
#   class Customer < ActiveRecord::Base
#     composed_of :balance, class_name: "Money", mapping: %w(amount currency)
#     composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
#   end
#
# The customer class now has the following methods to manipulate the value objects:
# * <tt>Customer#balance, Customer#balance=(money)</tt>
# * <tt>Customer#address, Customer#address=(address)</tt>
#
# These methods will operate with value objects like the ones described below:
#
#  class Money
#    include Comparable
#    attr_reader :amount, :currency
#    EXCHANGE_RATES = { "USD_TO_DKK" => 6 }
#
#    def initialize(amount, currency = "USD")
#      @amount, @currency = amount, currency
#    end
#
#    def exchange_to(other_currency)
#      exchanged_amount = (amount * EXCHANGE_RATES["#{currency}_TO_#{other_currency}"]).floor
#      Money.new(exchanged_amount, other_currency)
#    end
#
#    def ==(other_money)
#      amount == other_money.amount && currency == other_money.currency
#    end
#
#    def <=>(other_money)
#      if currency == other_money.currency
#        amount <=> other_money.amount
#      else
#        amount <=> other_money.exchange_to(currency).amount
#      end
#    end
#  end
#
#  class Address
#    attr_reader :street, :city
#    def initialize(street, city)
#      @street, @city = street, city
#    end
#
#    def close_to?(other_address)
#      city == other_address.city
#    end
#
#    def ==(other_address)
#      city == other_address.city && street == other_address.street
#    end
#  end
#
# Now it's possible to access attributes from the database through the value objects instead. If
# you choose to name the composition the same as the attribute's name, it will be the only way to
# access that attribute. That's the case with our +balance+ attribute. You interact with the value
# objects just like you would with any other attribute:
#
#   customer.balance = Money.new(20)     # sets the Money value object and the attribute
#   customer.balance                     # => Money value object
#   customer.balance.exchange_to("DKK")  # => Money.new(120, "DKK")
#   customer.balance > Money.new(10)     # => true
#   customer.balance == Money.new(20)    # => true
#   customer.balance < Money.new(5)      # => false
#
# Value objects can also be composed of multiple attributes, such as the case of Address. The order
# of the mappings will determine the order of the parameters.
#
#   customer.address_street = "Hyancintvej"
#   customer.address_city   = "Copenhagen"
#   customer.address        # => Address.new("Hyancintvej", "Copenhagen")
#
#   customer.address = Address.new("May Street", "Chicago")
#   customer.address_street # => "May Street"
#   customer.address_city   # => "Chicago"
#
# == Writing value objects
#
# Value objects are immutable and interchangeable objects that represent a given value, such as
# a Money object representing $5. Two Money objects both representing $5 should be equal (through
# methods such as <tt>==</tt> and <tt><=></tt> from Comparable if ranking makes sense). This is
# unlike entity objects where equality is determined by identity. An entity class such as Customer can
# easily have two different objects that both have an address on Hyancintvej. Entity identity is
# determined by object or relational unique identifiers (such as primary keys). Normal
# ActiveRecord::Base classes are entity objects.
#
# It's also important to treat the value objects as immutable. Don't allow the Money object to have
# its amount changed after creation. Create a new Money object with the new value instead. The
# <tt>Money#exchange_to</tt> method is an example of this. It returns a new value object instead of changing
# its own values. Active Record won't persist value objects that have been changed through means
# other than the writer method.
#
# The immutable requirement is enforced by Active Record by freezing any object assigned as a value
# object. Attempting to change it afterwards will result in a +RuntimeError+.
#
# Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not
# keeping value objects immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable
#
# == Custom constructors and converters
#
# By default value objects are initialized by calling the <tt>new</tt> constructor of the value
# class passing each of the mapped attributes, in the order specified by the <tt>:mapping</tt>
# option, as arguments. If the value class doesn't support this convention then #composed_of allows
# a custom constructor to be specified.
#
# When a new value is assigned to the value object, the default assumption is that the new value
# is an instance of the value class. Specifying a custom converter allows the new value to be automatically
# converted to an instance of value class if necessary.
#
# For example, the +NetworkResource+ model has +network_address+ and +cidr_range+ attributes that should be
# aggregated using the +NetAddr::CIDR+ value class (http://www.rubydoc.info/gems/netaddr/1.5.0/NetAddr/CIDR).
# The constructor for the value class is called +create+ and it expects a CIDR address string as a parameter.
# New values can be assigned to the value object using either another +NetAddr::CIDR+ object, a string
# or an array. The <tt>:constructor</tt> and <tt>:converter</tt> options can be used to meet
# these requirements:
#
#   class NetworkResource < ActiveRecord::Base
#     composed_of :cidr,
#                 class_name: 'NetAddr::CIDR',
#                 mapping: [ %w(network_address network), %w(cidr_range bits) ],
#                 allow_nil: true,
#                 constructor: Proc.new { |network_address, cidr_range| NetAddr::CIDR.create("#{network_address}/#{cidr_range}") },
#                 converter: Proc.new { |value| NetAddr::CIDR.create(value.is_a?(Array) ? value.join('/') : value) }
#   end
#
#   # This calls the :constructor
#   network_resource = NetworkResource.new(network_address: '192.168.0.1', cidr_range: 24)
#
#   # These assignments will both use the :converter
#   network_resource.cidr = [ '192.168.2.1', 8 ]
#   network_resource.cidr = '192.168.0.1/24'
#
#   # This assignment won't use the :converter as the value is already an instance of the value class
#   network_resource.cidr = NetAddr::CIDR.create('192.168.2.1/8')
#
#   # Saving and then reloading will use the :constructor on reload
#   network_resource.save
#   network_resource.reload
#
# == Finding records by a value object
#
# Once a #composed_of relationship is specified for a model, records can be loaded from the database
# by specifying an instance of the value object in the conditions hash. The following example
# finds all customers with +balance_amount+ equal to 20 and +balance_currency+ equal to "USD":
#
#   Customer.where(balance: Money.new(20, "USD"))
module ActiveRecord::Aggregations::ClassMethods
  # Adds reader and writer methods for manipulating a value object:
  # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.
  #
  # Options are:
  # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name
  #   can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked
  #   to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it
  #   with this option.
  # * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value
  #   object. Each mapping is represented as an array where the first item is the name of the
  #   entity attribute and the second item is the name of the attribute in the value object. The
  #   order in which mappings are defined determines the order in which attributes are sent to the
  #   value class constructor.
  # * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped
  #   attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all
  #   mapped attributes.
  #   This defaults to +false+.
  # * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that
  #   is called to initialize the value object. The constructor is passed all of the mapped attributes,
  #   in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them
  #   to instantiate a <tt>:class_name</tt> object.
  #   The default is <tt>:new</tt>.
  # * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt>
  #   or a Proc that is called when a new value is assigned to the value object. The converter is
  #   passed the single value that is used in the assignment and is only called if the new value is
  #   not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter
  #   can return nil to skip the assignment.
  #
  # Option examples:
  #   composed_of :temperature, mapping: %w(reading celsius)
  #   composed_of :balance, class_name: "Money", mapping: %w(balance amount),
  #                         converter: Proc.new { |balance| balance.to_money }
  #   composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
  #   composed_of :gps_location
  #   composed_of :gps_location, allow_nil: true
  #   composed_of :ip_address,
  #               class_name: 'IPAddr',
  #               mapping: %w(ip to_i),
  #               constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },
  #               converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }
  def composed_of(part_id, options = T.unsafe(nil)); end

  private

  def reader_method(name, class_name, mapping, allow_nil, constructor); end
  def writer_method(name, class_name, mapping, allow_nil, converter); end
end

class ActiveRecord::AssociationNotFoundError < ::ActiveRecord::ConfigurationError
  # @return [AssociationNotFoundError] a new instance of AssociationNotFoundError
  def initialize(record = T.unsafe(nil), association_name = T.unsafe(nil)); end
end

class ActiveRecord::AssociationRelation < ::ActiveRecord::Relation
  # @return [AssociationRelation] a new instance of AssociationRelation
  def initialize(klass, table, predicate_builder, association); end

  def ==(other); end
  def build(*args, &block); end
  def create(*args, &block); end
  def create!(*args, &block); end
  def new(*args, &block); end
  def proxy_association; end

  private

  def exec_queries; end
end

# Raised when an object assigned to an association has an incorrect type.
#
#   class Ticket < ActiveRecord::Base
#     has_many :patches
#   end
#
#   class Patch < ActiveRecord::Base
#     belongs_to :ticket
#   end
#
#   # Comments are not patches, this assignment raises AssociationTypeMismatch.
#   @ticket.patches << Comment.new(content: "Please attach tests to your patch.")
class ActiveRecord::AssociationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

# = Active Record Belongs To Association
module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Associations::ClassMethods

  # Returns the association instance for the given name, instantiating it if it doesn't already exist
  def association(name); end

  # :nodoc
  #
  # @return [Boolean]
  def association_cached?(name); end

  def reload(*_arg0); end

  private

  # Returns the specified association instance if it exists, nil otherwise.
  def association_instance_get(name); end

  # Set the specified association instance.
  def association_instance_set(name, association); end

  # Clears out the association cache.
  def clear_association_cache; end

  def init_internals; end
  def initialize_dup(*_arg0); end

  class << self
    def eager_load!; end
  end
end

# Keeps track of table aliases for ActiveRecord::Associations::JoinDependency
class ActiveRecord::Associations::AliasTracker
  # table_joins is an array of arel joins which might conflict with the aliases we assign here
  #
  # @return [AliasTracker] a new instance of AliasTracker
  def initialize(connection, aliases, type_caster); end

  def aliased_table_for(table_name, aliased_name); end
  def aliases; end

  private

  def truncate(name); end

  class << self
    def create(connection, initial_table, type_caster); end
    def create_with_joins(connection, initial_table, joins, type_caster); end
    def initial_count_for(connection, name, table_joins); end
  end
end

# = Active Record Associations
#
# This is the root class of all associations ('+ Foo' signifies an included module Foo):
#
#   Association
#     SingularAssociation
#       HasOneAssociation + ForeignAssociation
#         HasOneThroughAssociation + ThroughAssociation
#       BelongsToAssociation
#         BelongsToPolymorphicAssociation
#     CollectionAssociation
#       HasManyAssociation + ForeignAssociation
#         HasManyThroughAssociation + ThroughAssociation
class ActiveRecord::Associations::Association
  # @return [Association] a new instance of Association
  def initialize(owner, reflection); end

  # Returns the name of the table of the associated class:
  #
  #   post.comments.aliased_table_name # => "comments"
  def aliased_table_name; end

  # The scope for this association.
  #
  # Note that the association_scope is merged into the target_scope only when the
  # scope method is called. This is because at that point the call may be surrounded
  # by scope.scoping { ... } or with_scope { ... } etc, which affects the scope which
  # actually gets built.
  def association_scope; end

  def extensions; end
  def initialize_attributes(record, except_from_scope_attributes = T.unsafe(nil)); end
  def interpolate(sql, record = T.unsafe(nil)); end

  # Returns the value of attribute inversed.
  def inversed; end

  # Sets the attribute inversed
  #
  # @param value the value to set the attribute inversed to.
  def inversed=(_arg0); end

  # Returns the class of the target. belongs_to polymorphic overrides this to look at the
  # polymorphic_type field on the owner.
  def klass; end

  # Loads the \target if needed and returns it.
  #
  # This method is abstract in the sense that it relies on +find_target+,
  # which is expected to be provided by descendants.
  #
  # If the \target is already \loaded it is just returned. Thus, you can call
  # +load_target+ unconditionally to get the \target.
  #
  # ActiveRecord::RecordNotFound is rescued within the method, and it is
  # not reraised. The proxy is \reset and +nil+ is the return value.
  def load_target; end

  # Asserts the \target has been loaded setting the \loaded flag to +true+.
  def loaded!; end

  # Has the \target been already \loaded?
  #
  # @return [Boolean]
  def loaded?; end

  # We can't dump @reflection since it contains the scope proc
  def marshal_dump; end

  def marshal_load(data); end
  def options(*args, &block); end
  def owner; end
  def reflection; end

  # Reloads the \target and returns +self+ on success.
  def reload; end

  # Resets the \loaded flag to +false+ and sets the \target to +nil+.
  def reset; end

  def reset_scope; end
  def scope; end

  # Set the inverse association, if possible
  def set_inverse_instance(record); end

  # The target is stale if the target no longer points to the record(s) that the
  # relevant foreign_key(s) refers to. If stale, the association accessor method
  # on the owner will reload the target. It's up to subclasses to implement the
  # stale_state method if relevant.
  #
  # Note that if the target has not been loaded, it is not considered stale.
  #
  # @return [Boolean]
  def stale_target?; end

  def target; end

  # Sets the target of this association to <tt>\target</tt>, and the \loaded flag to +true+.
  def target=(target); end

  # Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the
  # through association's scope)
  def target_scope; end

  private

  def build_record(attributes); end
  def creation_attributes; end

  # @return [Boolean]
  def find_target?; end

  # Returns true if record contains the foreign_key
  #
  # @return [Boolean]
  def foreign_key_for?(record); end

  # Returns true if there is a foreign key present on the owner which
  # references the target. This is used to determine whether we can load
  # the target if the owner is currently a new record (and therefore
  # without a key). If the owner is a new record then foreign_key must
  # be present in order to load target.
  #
  # Currently implemented by belongs_to (vanilla and polymorphic) and
  # has_one/has_many :through associations which go through a belongs_to.
  #
  # @return [Boolean]
  def foreign_key_present?; end

  # Can be redefined by subclasses, notably polymorphic belongs_to
  # The record parameter is necessary to support polymorphic inverses as we must check for
  # the association in the specific class of the record.
  def inverse_reflection_for(record); end

  # Returns true if inverse association on the given record needs to be set.
  # This method is redefined by subclasses.
  #
  # @return [Boolean]
  def invertible_for?(record); end

  # Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of
  # the kind of the class of the associated objects. Meant to be used as
  # a sanity check when you are about to assign an associated record.
  def raise_on_type_mismatch!(record); end

  # Sets the owner attributes on the given record
  def set_owner_attributes(record); end

  # Returns true if statement cache should be skipped on the association reader.
  #
  # @return [Boolean]
  def skip_statement_cache?; end

  # This should be implemented to return the values of the relevant key(s) on the owner,
  # so that when stale_state is different from the value stored on the last find_target,
  # the target is stale.
  #
  # This is only relevant to certain associations, which is why it returns nil by default.
  def stale_state; end
end

class ActiveRecord::Associations::AssociationScope
  # @return [AssociationScope] a new instance of AssociationScope
  def initialize(value_transformation); end

  def join_type; end
  def scope(association, connection); end

  protected

  # Returns the value of attribute value_transformation.
  def value_transformation; end

  private

  def add_constraints(scope, owner, association_klass, refl, chain_head, chain_tail); end
  def eval_scope(klass, scope, owner); end
  def get_chain(reflection, association, tracker); end
  def join(table, constraint); end
  def last_chain_scope(scope, table, reflection, owner, association_klass); end
  def next_chain_scope(scope, table, reflection, association_klass, foreign_table, next_reflection); end
  def transform_value(value); end

  class << self
    def create(&block); end
    def get_bind_values(owner, chain); end
    def scope(association, connection); end
  end
end

ActiveRecord::Associations::AssociationScope::INSTANCE = T.let(T.unsafe(nil), ActiveRecord::Associations::AssociationScope)

class ActiveRecord::Associations::AssociationScope::ReflectionProxy < ::SimpleDelegator
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  def initialize(reflection, alias_name); end

  # Returns the value of attribute alias_name.
  def alias_name; end

  def all_includes; end

  # Returns the value of attribute next.
  def next; end

  # Sets the attribute next
  #
  # @param value the value to set the attribute next to.
  def next=(_arg0); end
end

class ActiveRecord::Associations::BelongsToAssociation < ::ActiveRecord::Associations::SingularAssociation
  def decrement_counters; end
  def handle_dependency; end
  def increment_counters; end
  def replace(record); end
  def reset; end

  # @return [Boolean]
  def updated?; end

  private

  # Checks whether record is different to the current target, without loading it
  #
  # @return [Boolean]
  def different_target?(record); end

  # @return [Boolean]
  def find_target?; end

  # @return [Boolean]
  def foreign_key_present?; end

  # NOTE - for now, we're only supporting inverse setting from belongs_to back onto
  # has_one associations.
  #
  # @return [Boolean]
  def invertible_for?(record); end

  def remove_keys; end
  def replace_keys(record); end

  # @return [Boolean]
  def require_counter_update?; end

  def stale_state; end
  def target_id; end
  def update_counters(by); end
  def update_counters_on_replace(record); end
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation < ::ActiveRecord::Associations::BelongsToAssociation
  def klass; end

  private

  # @return [Boolean]
  def different_target?(record); end

  def inverse_reflection_for(record); end
  def raise_on_type_mismatch!(record); end
  def remove_keys; end
  def replace_keys(record); end
  def stale_state; end
end

module ActiveRecord::Associations::Builder; end

class ActiveRecord::Associations::Builder::Association
  class << self
    def add_destroy_callbacks(model, reflection); end
    def build(model, name, scope, options, &block); end
    def build_scope(scope, extension); end
    def check_dependent_options(dependent); end

    # @raise [ArgumentError]
    def create_reflection(model, name, scope, options, extension = T.unsafe(nil)); end

    # Defines the setter and getter methods for the association
    # class Post < ActiveRecord::Base
    #   has_many :comments
    # end
    #
    # Post.first.comments and Post.first.comments= methods are defined by this method...
    def define_accessors(model, reflection); end

    def define_callbacks(model, reflection); end
    def define_extensions(model, name); end
    def define_readers(mixin, name); end
    def define_validations(model, reflection); end
    def define_writers(mixin, name); end

    # Returns the value of attribute extensions.
    def extensions; end

    # Sets the attribute extensions
    #
    # @param value the value to set the attribute extensions to.
    def extensions=(_arg0); end

    # @raise [NotImplementedError]
    def macro; end

    # @raise [NotImplementedError]
    def valid_dependent_options; end

    def valid_options(options); end
    def validate_options(options); end
    def wrap_scope(scope, extension); end
  end
end

ActiveRecord::Associations::Builder::Association::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Associations::Builder::BelongsTo < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    def add_counter_cache_callbacks(model, reflection); end
    def add_counter_cache_methods(mixin); end
    def add_destroy_callbacks(model, reflection); end
    def add_touch_callbacks(model, reflection); end
    def define_accessors(mixin, reflection); end
    def define_callbacks(model, reflection); end
    def define_validations(model, reflection); end
    def macro; end
    def touch_record(o, foreign_key, name, touch, touch_method); end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::CollectionAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    def define_callback(model, callback_name, name, options); end
    def define_callbacks(model, reflection); end
    def define_extensions(model, name); end

    # Defines the setter and getter methods for the collection_singular_ids.
    def define_readers(mixin, name); end

    def define_writers(mixin, name); end
    def valid_options(options); end
    def wrap_scope(scope, mod); end
  end
end

ActiveRecord::Associations::Builder::CollectionAssociation::CALLBACKS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  # @return [HasAndBelongsToMany] a new instance of HasAndBelongsToMany
  def initialize(association_name, lhs_model, options); end

  # Returns the value of attribute association_name.
  def association_name; end

  # Returns the value of attribute lhs_model.
  def lhs_model; end

  def middle_reflection(join_model); end

  # Returns the value of attribute options.
  def options; end

  def through_model; end

  private

  def belongs_to_options(options); end
  def middle_options(join_model); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver
  class << self
    def build(lhs_class, name, options); end
  end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownClass
  # @return [KnownClass] a new instance of KnownClass
  def initialize(lhs_class, rhs_class_name); end

  def join_table; end

  private

  def klass; end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany::JoinTableResolver::KnownTable < ::Struct
  # Returns the value of attribute join_table
  #
  # @return [Object] the current value of join_table
  def join_table; end

  # Sets the attribute join_table
  #
  # @param value [Object] the value to set the attribute join_table to.
  # @return [Object] the newly set value
  def join_table=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Associations::Builder::HasMany < ::ActiveRecord::Associations::Builder::CollectionAssociation
  class << self
    def macro; end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::HasOne < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    def add_destroy_callbacks(model, reflection); end
    def define_validations(model, reflection); end
    def macro; end
    def valid_dependent_options; end
    def valid_options(options); end
  end
end

class ActiveRecord::Associations::Builder::SingularAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    def define_accessors(model, reflection); end

    # Defines the (build|create)_association methods for belongs_to or has_one association
    def define_constructors(mixin, name); end

    def valid_options(options); end
  end
end

# \Associations are a set of macro-like class methods for tying objects together through
# foreign keys. They express relationships like "Project has one Project Manager"
# or "Project belongs to a Portfolio". Each macro adds a number of methods to the
# class which are specialized according to the collection or association symbol and the
# options hash. It works much the same way as Ruby's own <tt>attr*</tt>
# methods.
#
#   class Project < ActiveRecord::Base
#     belongs_to              :portfolio
#     has_one                 :project_manager
#     has_many                :milestones
#     has_and_belongs_to_many :categories
#   end
#
# The project class now has the following methods (and more) to ease the traversal and
# manipulation of its relationships:
# * <tt>Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?</tt>
# * <tt>Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,</tt>
# * <tt>Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones<<(milestone),</tt>
#   <tt>Project#milestones.delete(milestone), Project#milestones.destroy(milestone), Project#milestones.find(milestone_id),</tt>
#   <tt>Project#milestones.build, Project#milestones.create</tt>
# * <tt>Project#categories.empty?, Project#categories.size, Project#categories, Project#categories<<(category1),</tt>
#   <tt>Project#categories.delete(category1), Project#categories.destroy(category1)</tt>
#
# === A word of warning
#
# Don't create associations that have the same name as instance methods of
# ActiveRecord::Base. Since the association adds a method with that name to
# its model, it will override the inherited method and break things.
# For instance, +attributes+ and +connection+ would be bad choices for association names.
#
# == Auto-generated methods
# See also Instance Public methods below for more details.
#
# === Singular associations (one-to-one)
#                                     |            |  belongs_to  |
#   generated methods                 | belongs_to | :polymorphic | has_one
#   ----------------------------------+------------+--------------+---------
#   other                             |     X      |      X       |    X
#   other=(other)                     |     X      |      X       |    X
#   build_other(attributes={})        |     X      |              |    X
#   create_other(attributes={})       |     X      |              |    X
#   create_other!(attributes={})      |     X      |              |    X
#   reload_other                      |     X      |      X       |    X
#
# === Collection associations (one-to-many / many-to-many)
#                                     |       |          | has_many
#   generated methods                 | habtm | has_many | :through
#   ----------------------------------+-------+----------+----------
#   others                            |   X   |    X     |    X
#   others=(other,other,...)          |   X   |    X     |    X
#   other_ids                         |   X   |    X     |    X
#   other_ids=(id,id,...)             |   X   |    X     |    X
#   others<<                          |   X   |    X     |    X
#   others.push                       |   X   |    X     |    X
#   others.concat                     |   X   |    X     |    X
#   others.build(attributes={})       |   X   |    X     |    X
#   others.create(attributes={})      |   X   |    X     |    X
#   others.create!(attributes={})     |   X   |    X     |    X
#   others.size                       |   X   |    X     |    X
#   others.length                     |   X   |    X     |    X
#   others.count                      |   X   |    X     |    X
#   others.sum(*args)                 |   X   |    X     |    X
#   others.empty?                     |   X   |    X     |    X
#   others.clear                      |   X   |    X     |    X
#   others.delete(other,other,...)    |   X   |    X     |    X
#   others.delete_all                 |   X   |    X     |    X
#   others.destroy(other,other,...)   |   X   |    X     |    X
#   others.destroy_all                |   X   |    X     |    X
#   others.find(*args)                |   X   |    X     |    X
#   others.exists?                    |   X   |    X     |    X
#   others.distinct                   |   X   |    X     |    X
#   others.reset                      |   X   |    X     |    X
#   others.reload                     |   X   |    X     |    X
#
# === Overriding generated methods
#
# Association methods are generated in a module that is included into the model class,
# which allows you to easily override with your own methods and call the original
# generated method with +super+. For example:
#
#   class Car < ActiveRecord::Base
#     belongs_to :owner
#     belongs_to :old_owner
#     def owner=(new_owner)
#       self.old_owner = self.owner
#       super
#     end
#   end
#
# If your model class is <tt>Project</tt>, the module is
# named <tt>Project::GeneratedAssociationMethods</tt>. The +GeneratedAssociationMethods+ module is
# included in the model class immediately after the (anonymous) generated attributes methods
# module, meaning an association will override the methods for an attribute with the same name.
#
# == Cardinality and associations
#
# Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
# relationships between models. Each model uses an association to describe its role in
# the relation. The #belongs_to association is always used in the model that has
# the foreign key.
#
# === One-to-one
#
# Use #has_one in the base, and #belongs_to in the associated model.
#
#   class Employee < ActiveRecord::Base
#     has_one :office
#   end
#   class Office < ActiveRecord::Base
#     belongs_to :employee    # foreign key - employee_id
#   end
#
# === One-to-many
#
# Use #has_many in the base, and #belongs_to in the associated model.
#
#   class Manager < ActiveRecord::Base
#     has_many :employees
#   end
#   class Employee < ActiveRecord::Base
#     belongs_to :manager     # foreign key - manager_id
#   end
#
# === Many-to-many
#
# There are two ways to build a many-to-many relationship.
#
# The first way uses a #has_many association with the <tt>:through</tt> option and a join model, so
# there are two stages of associations.
#
#   class Assignment < ActiveRecord::Base
#     belongs_to :programmer  # foreign key - programmer_id
#     belongs_to :project     # foreign key - project_id
#   end
#   class Programmer < ActiveRecord::Base
#     has_many :assignments
#     has_many :projects, through: :assignments
#   end
#   class Project < ActiveRecord::Base
#     has_many :assignments
#     has_many :programmers, through: :assignments
#   end
#
# For the second way, use #has_and_belongs_to_many in both models. This requires a join table
# that has no corresponding model or primary key.
#
#   class Programmer < ActiveRecord::Base
#     has_and_belongs_to_many :projects       # foreign keys in the join table
#   end
#   class Project < ActiveRecord::Base
#     has_and_belongs_to_many :programmers    # foreign keys in the join table
#   end
#
# Choosing which way to build a many-to-many relationship is not always simple.
# If you need to work with the relationship model as its own entity,
# use #has_many <tt>:through</tt>. Use #has_and_belongs_to_many when working with legacy schemas or when
# you never work directly with the relationship itself.
#
# == Is it a #belongs_to or #has_one association?
#
# Both express a 1-1 relationship. The difference is mostly where to place the foreign
# key, which goes on the table for the class declaring the #belongs_to relationship.
#
#   class User < ActiveRecord::Base
#     # I reference an account.
#     belongs_to :account
#   end
#
#   class Account < ActiveRecord::Base
#     # One user references me.
#     has_one :user
#   end
#
# The tables for these classes could look something like:
#
#   CREATE TABLE users (
#     id int NOT NULL auto_increment,
#     account_id int default NULL,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
#   CREATE TABLE accounts (
#     id int NOT NULL auto_increment,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
# == Unsaved objects and associations
#
# You can manipulate objects and associations before they are saved to the database, but
# there is some special behavior you should be aware of, mostly involving the saving of
# associated objects.
#
# You can set the <tt>:autosave</tt> option on a #has_one, #belongs_to,
# #has_many, or #has_and_belongs_to_many association. Setting it
# to +true+ will _always_ save the members, whereas setting it to +false+ will
# _never_ save the members. More details about <tt>:autosave</tt> option is available at
# AutosaveAssociation.
#
# === One-to-one associations
#
# * Assigning an object to a #has_one association automatically saves that object and
#   the object being replaced (if there is one), in order to update their foreign
#   keys - except if the parent object is unsaved (<tt>new_record? == true</tt>).
# * If either of these saves fail (due to one of the objects being invalid), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * If you wish to assign an object to a #has_one association without saving it,
#   use the <tt>#build_association</tt> method (documented below). The object being
#   replaced will still be saved to update its foreign key.
# * Assigning an object to a #belongs_to association does not save the object, since
#   the foreign key field belongs on the parent. It does not save the parent either.
#
# === Collections
#
# * Adding an object to a collection (#has_many or #has_and_belongs_to_many) automatically
#   saves that object, except if the parent object (the owner of the collection) is not yet
#   stored in the database.
# * If saving any of the objects being added to a collection (via <tt>push</tt> or similar)
#   fails, then <tt>push</tt> returns +false+.
# * If saving fails while replacing the collection (via <tt>association=</tt>), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * You can add an object to a collection without automatically saving it by using the
#   <tt>collection.build</tt> method (documented below).
# * All unsaved (<tt>new_record? == true</tt>) members of the collection are automatically
#   saved when the parent is saved.
#
# == Customizing the query
#
# \Associations are built from <tt>Relation</tt> objects, and you can use the Relation syntax
# to customize them. For example, to add a condition:
#
#   class Blog < ActiveRecord::Base
#     has_many :published_posts, -> { where(published: true) }, class_name: 'Post'
#   end
#
# Inside the <tt>-> { ... }</tt> block you can use all of the usual Relation methods.
#
# === Accessing the owner object
#
# Sometimes it is useful to have access to the owner object when building the query. The owner
# is passed as a parameter to the block. For example, the following association would find all
# events that occur on the user's birthday:
#
#   class User < ActiveRecord::Base
#     has_many :birthday_events, ->(user) { where(starts_on: user.birthday) }, class_name: 'Event'
#   end
#
# Note: Joining, eager loading and preloading of these associations is not fully possible.
# These operations happen before instance creation and the scope will be called with a +nil+ argument.
# This can lead to unexpected behavior and is deprecated.
#
# == Association callbacks
#
# Similar to the normal callbacks that hook into the life cycle of an Active Record object,
# you can also define callbacks that get triggered when you add an object to or remove an
# object from an association collection.
#
#   class Project
#     has_and_belongs_to_many :developers, after_add: :evaluate_velocity
#
#     def evaluate_velocity(developer)
#       ...
#     end
#   end
#
# It's possible to stack callbacks by passing them as an array. Example:
#
#   class Project
#     has_and_belongs_to_many :developers,
#                             after_add: [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
#   end
#
# Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
#
# If any of the +before_add+ callbacks throw an exception, the object will not be
# added to the collection.
#
# Similarly, if any of the +before_remove+ callbacks throw an exception, the object
# will not be removed from the collection.
#
# == Association extensions
#
# The proxy objects that control the access to associations can be extended through anonymous
# modules. This is especially beneficial for adding new finders, creators, and other
# factory-type methods that are only used as part of this association.
#
#   class Account < ActiveRecord::Base
#     has_many :people do
#       def find_or_create_by_name(name)
#         first_name, last_name = name.split(" ", 2)
#         find_or_create_by(first_name: first_name, last_name: last_name)
#       end
#     end
#   end
#
#   person = Account.first.people.find_or_create_by_name("David Heinemeier Hansson")
#   person.first_name # => "David"
#   person.last_name  # => "Heinemeier Hansson"
#
# If you need to share the same extensions between many associations, you can use a named
# extension module.
#
#   module FindOrCreateByNameExtension
#     def find_or_create_by_name(name)
#       first_name, last_name = name.split(" ", 2)
#       find_or_create_by(first_name: first_name, last_name: last_name)
#     end
#   end
#
#   class Account < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
#   class Company < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
# Some extensions can only be made to work with knowledge of the association's internals.
# Extensions can access relevant state using the following methods (where +items+ is the
# name of the association):
#
# * <tt>record.association(:items).owner</tt> - Returns the object the association is part of.
# * <tt>record.association(:items).reflection</tt> - Returns the reflection object that describes the association.
# * <tt>record.association(:items).target</tt> - Returns the associated object for #belongs_to and #has_one, or
#   the collection of associated objects for #has_many and #has_and_belongs_to_many.
#
# However, inside the actual extension code, you will not have access to the <tt>record</tt> as
# above. In this case, you can access <tt>proxy_association</tt>. For example,
# <tt>record.association(:items)</tt> and <tt>record.items.proxy_association</tt> will return
# the same object, allowing you to make calls like <tt>proxy_association.owner</tt> inside
# association extensions.
#
# == Association Join Models
#
# Has Many associations can be configured with the <tt>:through</tt> option to use an
# explicit join model to retrieve the data. This operates similarly to a
# #has_and_belongs_to_many association. The advantage is that you're able to add validations,
# callbacks, and extra attributes on the join model. Consider the following schema:
#
#   class Author < ActiveRecord::Base
#     has_many :authorships
#     has_many :books, through: :authorships
#   end
#
#   class Authorship < ActiveRecord::Base
#     belongs_to :author
#     belongs_to :book
#   end
#
#   @author = Author.first
#   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to
#   @author.books                              # selects all books by using the Authorship join model
#
# You can also go through a #has_many association on the join model:
#
#   class Firm < ActiveRecord::Base
#     has_many   :clients
#     has_many   :invoices, through: :clients
#   end
#
#   class Client < ActiveRecord::Base
#     belongs_to :firm
#     has_many   :invoices
#   end
#
#   class Invoice < ActiveRecord::Base
#     belongs_to :client
#   end
#
#   @firm = Firm.first
#   @firm.clients.flat_map { |c| c.invoices } # select all invoices for all clients of the firm
#   @firm.invoices                            # selects all invoices by going through the Client join model
#
# Similarly you can go through a #has_one association on the join model:
#
#   class Group < ActiveRecord::Base
#     has_many   :users
#     has_many   :avatars, through: :users
#   end
#
#   class User < ActiveRecord::Base
#     belongs_to :group
#     has_one    :avatar
#   end
#
#   class Avatar < ActiveRecord::Base
#     belongs_to :user
#   end
#
#   @group = Group.first
#   @group.users.collect { |u| u.avatar }.compact # select all avatars for all users in the group
#   @group.avatars                                # selects all avatars by going through the User join model.
#
# An important caveat with going through #has_one or #has_many associations on the
# join model is that these associations are *read-only*. For example, the following
# would not work following the previous example:
#
#   @group.avatars << Avatar.new   # this would work if User belonged_to Avatar rather than the other way around
#   @group.avatars.delete(@group.avatars.last)  # so would this
#
# == Setting Inverses
#
# If you are using a #belongs_to on the join model, it is a good idea to set the
# <tt>:inverse_of</tt> option on the #belongs_to, which will mean that the following example
# works correctly (where <tt>tags</tt> is a #has_many <tt>:through</tt> association):
#
#   @post = Post.first
#   @tag = @post.tags.build name: "ruby"
#   @tag.save
#
# The last line ought to save the through record (a <tt>Tagging</tt>). This will only work if the
# <tt>:inverse_of</tt> is set:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :post
#     belongs_to :tag, inverse_of: :taggings
#   end
#
# If you do not set the <tt>:inverse_of</tt> record, the association will
# do its best to match itself up with the correct inverse. Automatic
# inverse detection only works on #has_many, #has_one, and
# #belongs_to associations.
#
# Extra options on the associations, as defined in the
# <tt>AssociationReflection::INVALID_AUTOMATIC_INVERSE_OPTIONS</tt> constant, will
# also prevent the association's inverse from being found automatically.
#
# The automatic guessing of the inverse association uses a heuristic based
# on the name of the class, so it may not work for all associations,
# especially the ones with non-standard names.
#
# You can turn off the automatic detection of inverse associations by setting
# the <tt>:inverse_of</tt> option to <tt>false</tt> like so:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :tag, inverse_of: false
#   end
#
# == Nested \Associations
#
# You can actually specify *any* association with the <tt>:through</tt> option, including an
# association which has a <tt>:through</tt> option itself. For example:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :comments, through: :posts
#     has_many :commenters, through: :comments
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
#   @author = Author.first
#   @author.commenters # => People who commented on posts written by the author
#
# An equivalent way of setting up this association this would be:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :commenters, through: :posts
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#     has_many :commenters, through: :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
# When using a nested association, you will not be able to modify the association because there
# is not enough information to know what modification to make. For example, if you tried to
# add a <tt>Commenter</tt> in the example above, there would be no way to tell how to set up the
# intermediate <tt>Post</tt> and <tt>Comment</tt> objects.
#
# == Polymorphic \Associations
#
# Polymorphic associations on models are not restricted on what types of models they
# can be associated with. Rather, they specify an interface that a #has_many association
# must adhere to.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :assets, as: :attachable         # The :as option specifies the polymorphic interface to use.
#   end
#
#   @asset.attachable = @post
#
# This works by using a type column in addition to a foreign key to specify the associated
# record. In the Asset example, you'd need an +attachable_id+ integer column and an
# +attachable_type+ string column.
#
# Using polymorphic associations in combination with single table inheritance (STI) is
# a little tricky. In order for the associations to work as expected, ensure that you
# store the base model for the STI models in the type column of the polymorphic
# association. To continue with the asset example above, suppose there are guest posts
# and member posts that use the posts table for STI. In this case, there must be a +type+
# column in the posts table.
#
# Note: The <tt>attachable_type=</tt> method is being called when assigning an +attachable+.
# The +class_name+ of the +attachable+ is passed as a String.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#
#     def attachable_type=(class_name)
#        super(class_name.constantize.base_class.to_s)
#     end
#   end
#
#   class Post < ActiveRecord::Base
#     # because we store "Post" in attachable_type now dependent: :destroy will work
#     has_many :assets, as: :attachable, dependent: :destroy
#   end
#
#   class GuestPost < Post
#   end
#
#   class MemberPost < Post
#   end
#
# == Caching
#
# All of the methods are built on a simple caching principle that will keep the result
# of the last query around unless specifically instructed not to. The cache is even
# shared across methods to make it even cheaper to use the macro-added methods without
# worrying too much about performance at the first go.
#
#   project.milestones             # fetches milestones from the database
#   project.milestones.size        # uses the milestone cache
#   project.milestones.empty?      # uses the milestone cache
#   project.milestones(true).size  # fetches milestones from the database
#   project.milestones             # uses the milestone cache
#
# == Eager loading of associations
#
# Eager loading is a way to find objects of a certain class and a number of named associations.
# It is one of the easiest ways to prevent the dreaded N+1 problem in which fetching 100
# posts that each need to display their author triggers 101 database queries. Through the
# use of eager loading, the number of queries will be reduced from 101 to 2.
#
#   class Post < ActiveRecord::Base
#     belongs_to :author
#     has_many   :comments
#   end
#
# Consider the following loop using the class above:
#
#   Post.all.each do |post|
#     puts "Post:            " + post.title
#     puts "Written by:      " + post.author.name
#     puts "Last comment on: " + post.comments.first.created_on
#   end
#
# To iterate over these one hundred posts, we'll generate 201 database queries. Let's
# first just optimize it for retrieving the author:
#
#   Post.includes(:author).each do |post|
#
# This references the name of the #belongs_to association that also used the <tt>:author</tt>
# symbol. After loading the posts, find will collect the +author_id+ from each one and load
# all the referenced authors with one query. Doing so will cut down the number of queries
# from 201 to 102.
#
# We can improve upon the situation further by referencing both associations in the finder with:
#
#   Post.includes(:author, :comments).each do |post|
#
# This will load all comments with a single query. This reduces the total number of queries
# to 3. In general, the number of queries will be 1 plus the number of associations
# named (except if some of the associations are polymorphic #belongs_to - see below).
#
# To include a deep hierarchy of associations, use a hash:
#
#   Post.includes(:author, { comments: { author: :gravatar } }).each do |post|
#
# The above code will load all the comments and all of their associated
# authors and gravatars. You can mix and match any combination of symbols,
# arrays, and hashes to retrieve the associations you want to load.
#
# All of this power shouldn't fool you into thinking that you can pull out huge amounts
# of data with no performance penalty just because you've reduced the number of queries.
# The database still needs to send all the data to Active Record and it still needs to
# be processed. So it's no catch-all for performance problems, but it's a great way to
# cut down on the number of queries in a situation as the one described above.
#
# Since only one table is loaded at a time, conditions or orders cannot reference tables
# other than the main one. If this is the case, Active Record falls back to the previously
# used LEFT OUTER JOIN based strategy. For example:
#
#   Post.includes([:author, :comments]).where(['comments.approved = ?', true])
#
# This will result in a single SQL query with joins along the lines of:
# <tt>LEFT OUTER JOIN comments ON comments.post_id = posts.id</tt> and
# <tt>LEFT OUTER JOIN authors ON authors.id = posts.author_id</tt>. Note that using conditions
# like this can have unintended consequences.
# In the above example posts with no approved comments are not returned at all, because
# the conditions apply to the SQL statement as a whole and not just to the association.
#
# You must disambiguate column references for this fallback to happen, for example
# <tt>order: "author.name DESC"</tt> will work but <tt>order: "name DESC"</tt> will not.
#
# If you want to load all posts (including posts with no approved comments) then write
# your own LEFT OUTER JOIN query using ON
#
#   Post.joins("LEFT OUTER JOIN comments ON comments.post_id = posts.id AND comments.approved = '1'")
#
# In this case it is usually more natural to include an association which has conditions defined on it:
#
#   class Post < ActiveRecord::Base
#     has_many :approved_comments, -> { where(approved: true) }, class_name: 'Comment'
#   end
#
#   Post.includes(:approved_comments)
#
# This will load posts and eager load the +approved_comments+ association, which contains
# only those comments that have been approved.
#
# If you eager load an association with a specified <tt>:limit</tt> option, it will be ignored,
# returning all the associated objects:
#
#   class Picture < ActiveRecord::Base
#     has_many :most_recent_comments, -> { order('id DESC').limit(10) }, class_name: 'Comment'
#   end
#
#   Picture.includes(:most_recent_comments).first.most_recent_comments # => returns all associated comments.
#
# Eager loading is supported with polymorphic associations.
#
#   class Address < ActiveRecord::Base
#     belongs_to :addressable, polymorphic: true
#   end
#
# A call that tries to eager load the addressable model
#
#   Address.includes(:addressable)
#
# This will execute one query to load the addresses and load the addressables with one
# query per addressable type.
# For example if all the addressables are either of class Person or Company then a total
# of 3 queries will be executed. The list of addressable types to load is determined on
# the back of the addresses loaded. This is not supported if Active Record has to fallback
# to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError.
# The reason is that the parent model's type is a column value so its corresponding table
# name cannot be put in the +FROM+/+JOIN+ clauses of that query.
#
# == Table Aliasing
#
# Active Record uses table aliasing in the case that a table is referenced multiple times
# in a join. If a table is referenced only once, the standard table name is used. The
# second time, the table is aliased as <tt>#{reflection_name}_#{parent_table_name}</tt>.
# Indexes are appended for any more successive uses of the table name.
#
#   Post.joins(:comments)
#   # => SELECT ... FROM posts INNER JOIN comments ON ...
#   Post.joins(:special_comments) # STI
#   # => SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
#   Post.joins(:comments, :special_comments) # special_comments is the reflection name, posts is the parent table name
#   # => SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
#
# Acts as tree example:
#
#   TreeMixin.joins(:children)
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#   TreeMixin.joins(children: :parent)
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#                               INNER JOIN parents_mixins ...
#   TreeMixin.joins(children: {parent: :children})
#   # => SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#                               INNER JOIN parents_mixins ...
#                               INNER JOIN mixins childrens_mixins_2
#
# Has and Belongs to Many join tables use the same idea, but add a <tt>_join</tt> suffix:
#
#   Post.joins(:categories)
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#   Post.joins(categories: :posts)
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#   Post.joins(categories: {posts: :categories})
#   # => SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
#
# If you wish to specify your own custom joins using ActiveRecord::QueryMethods#joins method, those table
# names will take precedence over the eager associations:
#
#   Post.joins(:comments).joins("inner join comments ...")
#   # => SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
#   Post.joins(:comments, :special_comments).joins("inner join comments ...")
#   # => SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
#                              INNER JOIN comments special_comments_posts ...
#                              INNER JOIN comments ...
#
# Table aliases are automatically truncated according to the maximum length of table identifiers
# according to the specific database.
#
# == Modules
#
# By default, associations will look for objects within the current module scope. Consider:
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base
#         has_many :clients
#       end
#
#       class Client < ActiveRecord::Base; end
#     end
#   end
#
# When <tt>Firm#clients</tt> is called, it will in turn call
# <tt>MyApplication::Business::Client.find_all_by_firm_id(firm.id)</tt>.
# If you want to associate with a class in another module scope, this can be done by
# specifying the complete class name.
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base; end
#     end
#
#     module Billing
#       class Account < ActiveRecord::Base
#         belongs_to :firm, class_name: "MyApplication::Business::Firm"
#       end
#     end
#   end
#
# == Bi-directional associations
#
# When you specify an association there is usually an association on the associated model
# that specifies the same relationship in reverse. For example, with the following models:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps
#      has_one :evil_wizard
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
# The +traps+ association on +Dungeon+ and the +dungeon+ association on +Trap+ are
# the inverse of each other and the inverse of the +dungeon+ association on +EvilWizard+
# is the +evil_wizard+ association on +Dungeon+ (and vice-versa). By default,
# Active Record can guess the inverse of the association based on the name
# of the class. The result is the following:
#
#    d = Dungeon.first
#    t = d.traps.first
#    d.object_id == t.dungeon.object_id # => true
#
# The +Dungeon+ instances +d+ and <tt>t.dungeon</tt> in the above example refer to
# the same in-memory instance since the association matches the name of the class.
# The result would be the same if we added +:inverse_of+ to our model definitions:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps, inverse_of: :dungeon
#      has_one :evil_wizard, inverse_of: :dungeon
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :traps
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :evil_wizard
#    end
#
# There are limitations to <tt>:inverse_of</tt> support:
#
# * does not work with <tt>:through</tt> associations.
# * does not work with <tt>:polymorphic</tt> associations.
# * for #belongs_to associations #has_many inverse associations are ignored.
#
# For more information, see the documentation for the +:inverse_of+ option.
#
# == Deleting from associations
#
# === Dependent associations
#
# #has_many, #has_one and #belongs_to associations support the <tt>:dependent</tt> option.
# This allows you to specify that associated records should be deleted when the owner is
# deleted.
#
# For example:
#
#     class Author
#       has_many :posts, dependent: :destroy
#     end
#     Author.find(1).destroy # => Will destroy all of the author's posts, too
#
# The <tt>:dependent</tt> option can have different values which specify how the deletion
# is done. For more information, see the documentation for this option on the different
# specific association types. When no option is given, the behavior is to do nothing
# with the associated records when destroying a record.
#
# Note that <tt>:dependent</tt> is implemented using Rails' callback
# system, which works by processing callbacks in order. Therefore, other
# callbacks declared either before or after the <tt>:dependent</tt> option
# can affect what it does.
#
# Note that <tt>:dependent</tt> option is ignored for #has_one <tt>:through</tt> associations.
#
# === Delete or destroy?
#
# #has_many and #has_and_belongs_to_many associations have the methods <tt>destroy</tt>,
# <tt>delete</tt>, <tt>destroy_all</tt> and <tt>delete_all</tt>.
#
# For #has_and_belongs_to_many, <tt>delete</tt> and <tt>destroy</tt> are the same: they
# cause the records in the join table to be removed.
#
# For #has_many, <tt>destroy</tt> and <tt>destroy_all</tt> will always call the <tt>destroy</tt> method of the
# record(s) being removed so that callbacks are run. However <tt>delete</tt> and <tt>delete_all</tt> will either
# do the deletion according to the strategy specified by the <tt>:dependent</tt> option, or
# if no <tt>:dependent</tt> option is given, then it will follow the default strategy.
# The default strategy is to do nothing (leave the foreign keys with the parent ids set), except for
# #has_many <tt>:through</tt>, where the default strategy is <tt>delete_all</tt> (delete
# the join records, without running their callbacks).
#
# There is also a <tt>clear</tt> method which is the same as <tt>delete_all</tt>, except that
# it returns the association rather than the records which have been deleted.
#
# === What gets deleted?
#
# There is a potential pitfall here: #has_and_belongs_to_many and #has_many <tt>:through</tt>
# associations have records in join tables, as well as the associated records. So when we
# call one of these deletion methods, what exactly should be deleted?
#
# The answer is that it is assumed that deletion on an association is about removing the
# <i>link</i> between the owner and the associated object(s), rather than necessarily the
# associated objects themselves. So with #has_and_belongs_to_many and #has_many
# <tt>:through</tt>, the join records will be deleted, but the associated records won't.
#
# This makes sense if you think about it: if you were to call <tt>post.tags.delete(Tag.find_by(name: 'food'))</tt>
# you would want the 'food' tag to be unlinked from the post, rather than for the tag itself
# to be removed from the database.
#
# However, there are examples where this strategy doesn't make sense. For example, suppose
# a person has many projects, and each project has many tasks. If we deleted one of a person's
# tasks, we would probably not want the project to be deleted. In this scenario, the delete method
# won't actually work: it can only be used if the association on the join model is a
# #belongs_to. In other situations you are expected to perform operations directly on
# either the associated records or the <tt>:through</tt> association.
#
# With a regular #has_many there is no distinction between the "associated records"
# and the "link", so there is only one choice for what gets deleted.
#
# With #has_and_belongs_to_many and #has_many <tt>:through</tt>, if you want to delete the
# associated records themselves, you can always do something along the lines of
# <tt>person.tasks.each(&:destroy)</tt>.
#
# == Type safety with ActiveRecord::AssociationTypeMismatch
#
# If you attempt to assign an object to an association that doesn't match the inferred
# or specified <tt>:class_name</tt>, you'll get an ActiveRecord::AssociationTypeMismatch.
#
# == Options
#
# All of the association macros can be specialized through options. This makes cases
# more complex than the simple and guessable ones possible.
module ActiveRecord::Associations::ClassMethods
  # Specifies a one-to-one association with another class. This method should only be used
  # if this class contains the foreign key. If the other class contains the foreign key,
  # then you should use #has_one instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # Methods will be added for retrieval and query for a single associated object, for which
  # this object holds an id:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.
  #
  # [association]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [association=(associate)]
  #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
  # [build_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
  # [create_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [create_association!(attributes = {})]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [reload_association]
  #   Returns the associated object, forcing a database read.
  #
  # === Example
  #
  # A Post class declares <tt>belongs_to :author</tt>, which will add:
  # * <tt>Post#author</tt> (similar to <tt>Author.find(author_id)</tt>)
  # * <tt>Post#author=(author)</tt> (similar to <tt>post.author_id = author.id</tt>)
  # * <tt>Post#build_author</tt> (similar to <tt>post.author = Author.new</tt>)
  # * <tt>Post#create_author</tt> (similar to <tt>post.author = Author.new; post.author.save; post.author</tt>)
  # * <tt>Post#create_author!</tt> (similar to <tt>post.author = Author.new; post.author.save!; post.author</tt>)
  # * <tt>Post#reload_author</tt>
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   belongs_to :firm, -> { where(id: 2) }
  #   belongs_to :user, -> { joins(:friends) }
  #   belongs_to :level, ->(level) { where("game_level > ?", level.current) }
  #
  # === Options
  #
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :person</tt>
  #   association will use "person_id" as the default <tt>:foreign_key</tt>. Similarly,
  #   <tt>belongs_to :favorite_person, class_name: "Person"</tt> will use a foreign key
  #   of "favorite_person_id".
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the association with a "_type"
  #   suffix. So a class that defines a <tt>belongs_to :taggable, polymorphic: true</tt>
  #   association will use "taggable_type" as the default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the method that returns the primary key of associated object used for the association.
  #   By default this is id.
  # [:dependent]
  #   If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to
  #   <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method.
  #   This option should not be specified when #belongs_to is used in conjunction with
  #   a #has_many relationship on another class because of the potential to leave
  #   orphaned records behind.
  # [:counter_cache]
  #   Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter
  #   and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this
  #   class is created and decremented when it's destroyed. This requires that a column
  #   named <tt>#{table_name}_count</tt> (such as +comments_count+ for a belonging Comment class)
  #   is used on the associate class (such as a Post class) - that is the migration for
  #   <tt>#{table_name}_count</tt> is created on the associate class (such that <tt>Post.comments_count</tt> will
  #   return the count cached, see note below). You can also specify a custom counter
  #   cache column by providing a column name instead of a +true+/+false+ value to this
  #   option (e.g., <tt>counter_cache: :my_custom_counter</tt>.)
  #   Note: Specifying a counter cache will add it to that model's list of readonly attributes
  #   using +attr_readonly+.
  # [:polymorphic]
  #   Specify this association is a polymorphic association by passing +true+.
  #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
  #   to the +attr_readonly+ list in the associated classes (e.g. <tt>class Post; attr_readonly :comments_count; end</tt>).
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated object or destroy it if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for
  #   sets <tt>:autosave</tt> to <tt>true</tt>.
  # [:touch]
  #   If true, the associated object will be touched (the updated_at/on attributes set to current time)
  #   when this record is either saved or destroyed. If you specify a symbol, that attribute
  #   will be updated with the current time in addition to the updated_at/on attribute.
  #   Please note that with touching no validation is performed and only the +after_touch+,
  #   +after_commit+ and +after_rollback+ callbacks are executed.
  # [:inverse_of]
  #   Specifies the name of the #has_one or #has_many association on the associated
  #   object that is the inverse of this #belongs_to association. Does not work in
  #   combination with the <tt>:polymorphic</tt> options.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:optional]
  #   When set to +true+, the association will not have its presence validated.
  # [:required]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  #   NOTE: <tt>required</tt> is set to <tt>true</tt> by default and is deprecated. If
  #   you don't want to have association presence validated, use <tt>optional: true</tt>.
  #
  # Option examples:
  #   belongs_to :firm, foreign_key: "client_of"
  #   belongs_to :person, primary_key: "name", foreign_key: "person_name"
  #   belongs_to :author, class_name: "Person", foreign_key: "author_id"
  #   belongs_to :valid_coupon, ->(o) { where "discounts > ?", o.payments_count },
  #                             class_name: "Coupon", foreign_key: "coupon_id"
  #   belongs_to :attachable, polymorphic: true
  #   belongs_to :project, -> { readonly }
  #   belongs_to :post, counter_cache: true
  #   belongs_to :comment, touch: true
  #   belongs_to :company, touch: :employees_last_updated_at
  #   belongs_to :user, optional: true
  def belongs_to(name, scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # Specifies a many-to-many relationship with another class. This associates two classes via an
  # intermediate join table. Unless the join table is explicitly specified as an option, it is
  # guessed using the lexical order of the class names. So a join between Developer and Project
  # will give the default join table name of "developers_projects" because "D" precedes "P" alphabetically.
  # Note that this precedence is calculated using the <tt><</tt> operator for String. This
  # means that if the strings are of different lengths, and the strings are equal when compared
  # up to the shortest length, then the longer string is considered of higher
  # lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers"
  # to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes",
  # but it in fact generates a join table name of "paper_boxes_papers". Be aware of this caveat, and use the
  # custom <tt>:join_table</tt> option if you need to.
  # If your tables share a common prefix, it will only appear once at the beginning. For example,
  # the tables "catalog_categories" and "catalog_products" generate a join table name of "catalog_categories_products".
  #
  # The join table should not have a primary key or a model associated with it. You must manually generate the
  # join table with a migration such as this:
  #
  #   class CreateDevelopersProjectsJoinTable < ActiveRecord::Migration[5.0]
  #     def change
  #       create_join_table :developers, :projects
  #     end
  #   end
  #
  # It's also a good idea to add indexes to each of those columns to speed up the joins process.
  # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only
  # uses one index per table during the lookup.
  #
  # Adds the following methods for retrieval and query:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.
  #
  # [collection]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [collection<<(object, ...)]
  #   Adds one or more objects to the collection by creating associations in the join table
  #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  # [collection.delete(object, ...)]
  #   Removes one or more objects from the collection by removing their associations from the join table.
  #   This does not destroy the objects.
  # [collection.destroy(object, ...)]
  #   Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option.
  #   This does not destroy the objects.
  # [collection=objects]
  #   Replaces the collection's content by deleting and adding objects as appropriate.
  # [collection_singular_ids]
  #   Returns an array of the associated objects' ids.
  # [collection_singular_ids=ids]
  #   Replace the collection by the objects identified by the primary keys in +ids+.
  # [collection.clear]
  #   Removes every object from the collection. This does not destroy the objects.
  # [collection.empty?]
  #   Returns +true+ if there are no associated objects.
  # [collection.size]
  #   Returns the number of associated objects.
  # [collection.find(id)]
  #   Finds an associated object responding to the +id+ and that
  #   meets the condition that it has to be associated with this object.
  #   Uses the same rules as ActiveRecord::FinderMethods#find.
  # [collection.exists?(...)]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [collection.build(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
  # [collection.create(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through the join table, and that has already been
  #   saved (if it passed the validation).
  # [collection.reload]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # === Example
  #
  # A Developer class declares <tt>has_and_belongs_to_many :projects</tt>, which will add:
  # * <tt>Developer#projects</tt>
  # * <tt>Developer#projects<<</tt>
  # * <tt>Developer#projects.delete</tt>
  # * <tt>Developer#projects.destroy</tt>
  # * <tt>Developer#projects=</tt>
  # * <tt>Developer#project_ids</tt>
  # * <tt>Developer#project_ids=</tt>
  # * <tt>Developer#projects.clear</tt>
  # * <tt>Developer#projects.empty?</tt>
  # * <tt>Developer#projects.size</tt>
  # * <tt>Developer#projects.find(id)</tt>
  # * <tt>Developer#projects.exists?(...)</tt>
  # * <tt>Developer#projects.build</tt> (similar to <tt>Project.new("developer_id" => id)</tt>)
  # * <tt>Developer#projects.create</tt> (similar to <tt>c = Project.new("developer_id" => id); c.save; c</tt>)
  # * <tt>Developer#projects.reload</tt>
  # The declaration may include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :categories, ->(category) {
  #     where("default_category = ?", category.name)
  #   }
  #
  # === Extensions
  #
  # The +extension+ argument allows you to pass a block into a
  # has_and_belongs_to_many association. This is useful for adding new
  # finders, creators and other factory-type methods to be used as part of
  # the association.
  #
  # Extension examples:
  #   has_and_belongs_to_many :contractors do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # === Options
  #
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the
  #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
  # [:join_table]
  #   Specify the name of the join table if the default based on lexical order isn't what you want.
  #   <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method
  #   MUST be declared underneath any #has_and_belongs_to_many declaration in order to work.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes
  #   a #has_and_belongs_to_many association to Project will use "person_id" as the
  #   default <tt>:foreign_key</tt>.
  # [:association_foreign_key]
  #   Specify the foreign key used for the association on the receiving side of the association.
  #   By default this is guessed to be the name of the associated class in lower-case and "_id" suffixed.
  #   So if a Person class makes a #has_and_belongs_to_many association to Project,
  #   the association will use "project_id" as the default <tt>:association_foreign_key</tt>.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated objects or destroy them if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  #
  # Option examples:
  #   has_and_belongs_to_many :projects
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :nations, class_name: "Country"
  #   has_and_belongs_to_many :categories, join_table: "prods_cats"
  #   has_and_belongs_to_many :categories, -> { readonly }
  def has_and_belongs_to_many(name, scope = T.unsafe(nil), options = T.unsafe(nil), &extension); end

  # Specifies a one-to-many association. The following methods for retrieval and query of
  # collections of associated objects will be added:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.
  #
  # [collection]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [collection<<(object, ...)]
  #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  #   This will also run validations and callbacks of associated object(s).
  # [collection.delete(object, ...)]
  #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
  #   Objects will be in addition destroyed if they're associated with <tt>dependent: :destroy</tt>,
  #   and deleted if they're associated with <tt>dependent: :delete_all</tt>.
  #
  #   If the <tt>:through</tt> option is used, then the join records are deleted (rather than
  #   nullified) by default, but you can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [collection.destroy(object, ...)]
  #   Removes one or more objects from the collection by running <tt>destroy</tt> on
  #   each record, regardless of any dependent option, ensuring callbacks are run.
  #
  #   If the <tt>:through</tt> option is used, then the join records are destroyed
  #   instead, not the objects themselves.
  # [collection=objects]
  #   Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt>
  #   option is true callbacks in the join models are triggered except destroy callbacks, since deletion is
  #   direct by default. You can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [collection_singular_ids]
  #   Returns an array of the associated objects' ids
  # [collection_singular_ids=ids]
  #   Replace the collection with the objects identified by the primary keys in +ids+. This
  #   method loads the models and calls <tt>collection=</tt>. See above.
  # [collection.clear]
  #   Removes every object from the collection. This destroys the associated objects if they
  #   are associated with <tt>dependent: :destroy</tt>, deletes them directly from the
  #   database if <tt>dependent: :delete_all</tt>, otherwise sets their foreign keys to +NULL+.
  #   If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
  #   Join models are directly deleted.
  # [collection.empty?]
  #   Returns +true+ if there are no associated objects.
  # [collection.size]
  #   Returns the number of associated objects.
  # [collection.find(...)]
  #   Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find.
  # [collection.exists?(...)]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [collection.build(attributes = {}, ...)]
  #   Returns one or more new objects of the collection type that have been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but have not yet
  #   been saved.
  # [collection.create(attributes = {})]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that has already
  #   been saved (if it passed the validation). *Note*: This only works if the base model
  #   already exists in the DB, not if it is a new (unsaved) record!
  # [collection.create!(attributes = {})]
  #   Does the same as <tt>collection.create</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [collection.reload]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # === Example
  #
  # A <tt>Firm</tt> class declares <tt>has_many :clients</tt>, which will add:
  # * <tt>Firm#clients</tt> (similar to <tt>Client.where(firm_id: id)</tt>)
  # * <tt>Firm#clients<<</tt>
  # * <tt>Firm#clients.delete</tt>
  # * <tt>Firm#clients.destroy</tt>
  # * <tt>Firm#clients=</tt>
  # * <tt>Firm#client_ids</tt>
  # * <tt>Firm#client_ids=</tt>
  # * <tt>Firm#clients.clear</tt>
  # * <tt>Firm#clients.empty?</tt> (similar to <tt>firm.clients.size == 0</tt>)
  # * <tt>Firm#clients.size</tt> (similar to <tt>Client.count "firm_id = #{id}"</tt>)
  # * <tt>Firm#clients.find</tt> (similar to <tt>Client.where(firm_id: id).find(id)</tt>)
  # * <tt>Firm#clients.exists?(name: 'ACME')</tt> (similar to <tt>Client.exists?(name: 'ACME', firm_id: firm.id)</tt>)
  # * <tt>Firm#clients.build</tt> (similar to <tt>Client.new("firm_id" => id)</tt>)
  # * <tt>Firm#clients.create</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save; c</tt>)
  # * <tt>Firm#clients.create!</tt> (similar to <tt>c = Client.new("firm_id" => id); c.save!</tt>)
  # * <tt>Firm#clients.reload</tt>
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_many :comments, -> { where(author_id: 1) }
  #   has_many :employees, -> { joins(:address) }
  #   has_many :posts, ->(post) { where("max_post_length > ?", post.length) }
  #
  # === Extensions
  #
  # The +extension+ argument allows you to pass a block into a has_many
  # association. This is useful for adding new finders, creators and other
  # factory-type methods to be used as part of the association.
  #
  # Extension examples:
  #   has_many :employees do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # === Options
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_many :products</tt> will by default be linked
  #   to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to
  #   specify it with this option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_many
  #   association will use "person_id" as the default <tt>:foreign_key</tt>.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_many :tags, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the name of the column to use as the primary key for the association. By default this is +id+.
  # [:dependent]
  #   Controls what happens to the associated objects when
  #   their owner is destroyed. Note that these are implemented as
  #   callbacks, and Rails executes callbacks in order. Therefore, other
  #   similar callbacks may affect the <tt>:dependent</tt> behavior, and the
  #   <tt>:dependent</tt> behavior may affect other callbacks.
  #
  #   * <tt>:destroy</tt> causes all the associated objects to also be destroyed.
  #   * <tt>:delete_all</tt> causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).
  #   * <tt>:nullify</tt> causes the foreign keys to be set to +NULL+. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an exception to be raised if there are any associated records.
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there are any associated objects.
  #
  #   If using with the <tt>:through</tt> option, the association on the join model must be
  #   a #belongs_to, and the records which get deleted are the join records, rather than
  #   the associated records.
  # [:counter_cache]
  #   This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option,
  #   when you customized the name of your <tt>:counter_cache</tt> on the #belongs_to association.
  # [:as]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [:through]
  #   Specifies an association through which to perform the query. This can be any other type
  #   of association, including other <tt>:through</tt> associations. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection.
  #
  #   If the association on the join model is a #belongs_to, the collection can be modified
  #   and the records on the <tt>:through</tt> model will be automatically created and removed
  #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the
  #   <tt>:through</tt> association directly.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option on the source association on the
  #   join model. This allows associated records to be built which will automatically create
  #   the appropriate join model records when they are saved. (See the 'Association Join Models'
  #   section above.)
  # [:source]
  #   Specifies the source association name used by #has_many <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_many :subscribers, through: :subscriptions</tt> will look for either <tt>:subscribers</tt> or
  #   <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given.
  # [:source_type]
  #   Specifies type of the source association used by #has_many <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated objects or destroy them if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records. This option is implemented as a
  #   +before_save+ callback. Because callbacks are run in the order they are defined, associated objects
  #   may need to be explicitly saved in any user-defined +before_save+ callbacks.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [:inverse_of]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_many association. Does not work in combination
  #   with <tt>:through</tt> or <tt>:as</tt> options.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:extend]
  #   Specifies a module or array of modules that will be extended into the association object returned.
  #   Useful for defining methods on associations, especially when they should be shared between multiple
  #   association objects.
  #
  # Option examples:
  #   has_many :comments, -> { order("posted_on") }
  #   has_many :comments, -> { includes(:author) }
  #   has_many :people, -> { where(deleted: false).order("name") }, class_name: "Person"
  #   has_many :tracks, -> { order("position") }, dependent: :destroy
  #   has_many :comments, dependent: :nullify
  #   has_many :tags, as: :taggable
  #   has_many :reports, -> { readonly }
  #   has_many :subscribers, through: :subscriptions, source: :user
  def has_many(name, scope = T.unsafe(nil), options = T.unsafe(nil), &extension); end

  # Specifies a one-to-one association with another class. This method should only be used
  # if the other class contains the foreign key. If the current class contains the foreign key,
  # then you should use #belongs_to instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # The following methods for retrieval and query of a single associated object will be added:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.
  #
  # [association]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [association=(associate)]
  #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
  #   and saves the associate object. To avoid database inconsistencies, permanently deletes an existing
  #   associated object when assigning a new one, even if the new one isn't saved to database.
  # [build_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not
  #   yet been saved.
  # [create_association(attributes = {})]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [create_association!(attributes = {})]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [reload_association]
  #   Returns the associated object, forcing a database read.
  #
  # === Example
  #
  # An Account class declares <tt>has_one :beneficiary</tt>, which will add:
  # * <tt>Account#beneficiary</tt> (similar to <tt>Beneficiary.where(account_id: id).first</tt>)
  # * <tt>Account#beneficiary=(beneficiary)</tt> (similar to <tt>beneficiary.account_id = account.id; beneficiary.save</tt>)
  # * <tt>Account#build_beneficiary</tt> (similar to <tt>Beneficiary.new("account_id" => id)</tt>)
  # * <tt>Account#create_beneficiary</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save; b</tt>)
  # * <tt>Account#create_beneficiary!</tt> (similar to <tt>b = Beneficiary.new("account_id" => id); b.save!; b</tt>)
  # * <tt>Account#reload_beneficiary</tt>
  #
  # === Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   has_one :author, -> { where(comment_id: 1) }
  #   has_one :employer, -> { joins(:company) }
  #   has_one :dob, ->(dob) { where("Date.new(2000, 01, 01) > ?", dob) }
  #
  # === Options
  #
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # Options are:
  # [:class_name]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [:dependent]
  #   Controls what happens to the associated object when
  #   its owner is destroyed:
  #
  #   * <tt>:destroy</tt> causes the associated object to also be destroyed
  #   * <tt>:delete</tt> causes the associated object to be deleted directly from the database (so callbacks will not execute)
  #   * <tt>:nullify</tt> causes the foreign key to be set to +NULL+. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an exception to be raised if there is an associated record
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object
  #
  #   Note that <tt>:dependent</tt> option is ignored when using <tt>:through</tt> option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_one association
  #   will use "person_id" as the default <tt>:foreign_key</tt>.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_one :tag, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the method that returns the primary key used for the association. By default this is +id+.
  # [:as]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [:through]
  #   Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection. You can only use a <tt>:through</tt> query through a #has_one
  #   or #belongs_to association on the join model.
  # [:source]
  #   Specifies the source association name used by #has_one <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_one :favorite, through: :favorites</tt> will look for a
  #   <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given.
  # [:source_type]
  #   Specifies type of the source association used by #has_one <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [:validate]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [:autosave]
  #   If true, always save the associated object or destroy it if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [:inverse_of]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_one association. Does not work in combination
  #   with <tt>:through</tt> or <tt>:as</tt> options.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [:required]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  #
  # Option examples:
  #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card
  #   has_one :credit_card, dependent: :nullify  # updates the associated records foreign
  #                                                 # key value to NULL rather than destroying it
  #   has_one :last_comment, -> { order('posted_on') }, class_name: "Comment"
  #   has_one :project_manager, -> { where(role: 'project_manager') }, class_name: "Person"
  #   has_one :attachment, as: :attachable
  #   has_one :boss, -> { readonly }
  #   has_one :club, through: :membership
  #   has_one :primary_address, -> { where(primary: true) }, through: :addressables, source: :addressable
  #   has_one :credit_card, required: true
  def has_one(name, scope = T.unsafe(nil), options = T.unsafe(nil)); end
end

# = Active Record Association Collection
#
# CollectionAssociation is an abstract class that provides common stuff to
# ease the implementation of association proxies that represent
# collections. See the class hierarchy in Association.
#
#   CollectionAssociation:
#     HasManyAssociation => has_many
#       HasManyThroughAssociation + ThroughAssociation => has_many :through
#
# CollectionAssociation class provides common methods to the collections
# defined by +has_and_belongs_to_many+, +has_many+ or +has_many+ with
# +:through association+ option.
#
# You need to be careful with assumptions regarding the target: The proxy
# does not fetch records from the database until it needs them, but new
# ones created with +build+ are added to the target. So, the target may be
# non-empty and still lack children waiting to be read from the database.
# If you look directly to the database you cannot assume that's the entire
# collection because new records may have been added to the target, etc.
#
# If you need to work on all current children, new and existing records,
# +load_target+ and the +loaded+ flag are your friends.
class ActiveRecord::Associations::CollectionAssociation < ::ActiveRecord::Associations::Association
  def add_to_target(record, skip_callbacks = T.unsafe(nil), &block); end

  # Returns true if the collections is not empty.
  # If block given, loads all records and checks for one or more matches.
  # Otherwise, equivalent to +!collection.empty?+.
  #
  # @return [Boolean]
  def any?; end

  def build(attributes = T.unsafe(nil), &block); end

  # Add +records+ to this association. Returns +self+ so method calls may
  # be chained. Since << flattens its argument list and inserts each record,
  # +push+ and +concat+ behave identically.
  def concat(*records); end

  # Count all records using SQL.  Construct options and pass them with
  # scope to the target class's +count+.
  def count(column_name = T.unsafe(nil)); end

  def create(attributes = T.unsafe(nil), &block); end
  def create!(attributes = T.unsafe(nil), &block); end

  # Removes +records+ from this association calling +before_remove+ and
  # +after_remove+ callbacks.
  #
  # This method is abstract in the sense that +delete_records+ has to be
  # provided by descendants. Note this method does not imply the records
  # are actually removed from the database, that depends precisely on
  # +delete_records+. They are in any case removed from the collection.
  def delete(*records); end

  # Removes all records from the association without calling callbacks
  # on the associated records. It honors the +:dependent+ option. However
  # if the +:dependent+ value is +:destroy+ then in that case the +:delete_all+
  # deletion strategy for the association is applied.
  #
  # You can force a particular deletion strategy by passing a parameter.
  #
  # Example:
  #
  # @author.books.delete_all(:nullify)
  # @author.books.delete_all(:delete_all)
  #
  # See delete for more info.
  def delete_all(dependent = T.unsafe(nil)); end

  # Deletes the +records+ and removes them from this association calling
  # +before_remove+ , +after_remove+ , +before_destroy+ and +after_destroy+ callbacks.
  #
  # Note that this method removes records from the database ignoring the
  # +:dependent+ option.
  def destroy(*records); end

  # Destroy all the records from this association.
  #
  # See destroy for more info.
  def destroy_all; end

  def distinct; end

  # Returns true if the collection is empty.
  #
  # If the collection has been loaded
  # it is equivalent to <tt>collection.size.zero?</tt>. If the
  # collection has not been loaded, it is equivalent to
  # <tt>collection.exists?</tt>. If the collection has not already been
  # loaded and you are going to fetch the records anyway it is better to
  # check <tt>collection.length.zero?</tt>.
  #
  # @return [Boolean]
  def empty?; end

  def fifth(*args); end
  def find(*args); end
  def first(*args); end
  def forty_two(*args); end
  def fourth(*args); end

  # Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items
  def ids_reader; end

  # Implements the ids writer method, e.g. foo.item_ids= for Foo.has_many :items
  def ids_writer(ids); end

  # @return [Boolean]
  def include?(record); end

  def last(*args); end

  # Returns the size of the collection calling +size+ on the target.
  #
  # If the collection has been already loaded +length+ and +size+ are
  # equivalent. If not and you are going to need the records anyway this
  # method will take one less query. Otherwise +size+ is more efficient.
  def length; end

  def load_target; end

  # Returns true if the collection has more than 1 record.
  # If block given, loads all records and checks for two or more matches.
  # Otherwise, equivalent to +collection.size > 1+.
  #
  # @return [Boolean]
  def many?; end

  # @return [Boolean]
  def null_scope?; end

  # Implements the reader method, e.g. foo.items for Foo.has_many :items
  def reader(force_reload = T.unsafe(nil)); end

  # Replace this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  def replace(other_array); end

  def reset; end
  def scope; end
  def second(*args); end
  def second_to_last(*args); end
  def select(*fields); end

  # Returns the size of the collection by executing a SELECT COUNT(*)
  # query if the collection hasn't been loaded, and calling
  # <tt>collection.size</tt> if it has.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  # This method is abstract in the sense that it relies on
  # +count_records+, which is a method descendants have to provide.
  def size; end

  def take(n = T.unsafe(nil)); end
  def third(*args); end
  def third_to_last(*args); end

  # Starts a transaction in the association class's database connection.
  #
  #   class Author < ActiveRecord::Base
  #     has_many :books
  #   end
  #
  #   Author.first.books.transaction do
  #     # same effect as calling Book.transaction
  #   end
  def transaction(*args); end

  def uniq; end

  # Implements the writer method, e.g. foo.items= for Foo.has_many :items
  def writer(records); end

  private

  def _create_record(attributes, raise = T.unsafe(nil), &block); end
  def callback(method, record); end
  def callbacks_for(callback_name); end
  def concat_records(records, raise = T.unsafe(nil)); end
  def create_scope; end
  def delete_or_destroy(records, method); end

  # Delete the given records from the association, using one of the methods :destroy,
  # :delete_all or :nullify (or nil, in which case a default is used).
  #
  # @raise [NotImplementedError]
  def delete_records(records, method); end

  # Should we deal with assoc.first or assoc.last by issuing an independent query to
  # the database, or by getting the target, and then taking the first/last item from that?
  #
  # If the args is just a non-empty options hash, go to the database.
  #
  # Otherwise, go to the database only if none of the following are true:
  #   * target already loaded
  #   * owner is new record
  #   * target contains new or changed record(s)
  #
  # @return [Boolean]
  def fetch_first_nth_or_last_using_find?(args); end

  # If the :inverse_of option has been
  # specified, then #find scans the entire collection.
  def find_by_scan(*args); end

  def find_target; end

  # Fetches the first/last using SQL if possible, otherwise from the target array.
  def first_nth_or_last(type, *args); end

  def get_records(&block); end

  # @return [Boolean]
  def include_in_memory?(record); end

  # Do the relevant stuff to insert the given record into the association collection.
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil), &block); end

  # We have some records loaded from the database (persisted) and some that are
  # in-memory (memory). The same record may be represented in the persisted array
  # and in the memory array.
  #
  # So the task of this method is to merge them according to the following rules:
  #
  #   * The final array must not have duplicates
  #   * The order of the persisted array is to be preserved
  #   * Any changes made to attributes on objects in the memory array are to be preserved
  #   * Otherwise, attributes should have the value found in the database
  def merge_target_lists(persisted, memory); end

  def remove_records(existing_records, records, method); end
  def replace_common_records_in_memory(new_target, original_target); end
  def replace_on_target(record, index, skip_callbacks); end
  def replace_records(new_target, original_target); end
end

# Association proxies in Active Record are middlemen between the object that
# holds the association, known as the <tt>@owner</tt>, and the actual associated
# object, known as the <tt>@target</tt>. The kind of association any proxy is
# about is available in <tt>@reflection</tt>. That's an instance of the class
# ActiveRecord::Reflection::AssociationReflection.
#
# For example, given
#
#   class Blog < ActiveRecord::Base
#     has_many :posts
#   end
#
#   blog = Blog.first
#
# the association proxy in <tt>blog.posts</tt> has the object in +blog+ as
# <tt>@owner</tt>, the collection of its posts as <tt>@target</tt>, and
# the <tt>@reflection</tt> object represents a <tt>:has_many</tt> macro.
#
# This class delegates unknown methods to <tt>@target</tt> via
# <tt>method_missing</tt>.
#
# The <tt>@target</tt> object is not \loaded until needed. For example,
#
#   blog.posts.count
#
# is computed directly through SQL and does not trigger by itself the
# instantiation of the actual post records.
class ActiveRecord::Associations::CollectionProxy < ::ActiveRecord::Relation
  # @return [CollectionProxy] a new instance of CollectionProxy
  def initialize(klass, association); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Returns +self+, so several appends may be
  # chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def <<(*records); end

  # Equivalent to <tt>Array#==</tt>. Returns +true+ if the two arrays
  # contain the same number of elements and if each element is equal
  # to the corresponding element in the +other+ array, otherwise returns
  # +false+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   other = person.pets.to_ary
  #
  #   person.pets == other
  #   # => true
  #
  #   other = [Pet.new(id: 1), Pet.new(id: 2)]
  #
  #   person.pets == other
  #   # => false
  def ==(other); end

  def _select!(*args, &block); end

  # Returns +true+ if the collection is not empty.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count # => 0
  #   person.pets.any?  # => false
  #
  #   person.pets << Pet.new(name: 'Snoop')
  #   person.pets.count # => 1
  #   person.pets.any?  # => true
  #
  # You can also pass a +block+ to define criteria. The behavior
  # is the same, it returns true if the collection based on the
  # criteria is not empty.
  #
  #   person.pets
  #   # => [#<Pet name: "Snoop", group: "dogs">]
  #
  #   person.pets.any? do |pet|
  #     pet.group == 'cats'
  #   end
  #   # => false
  #
  #   person.pets.any? do |pet|
  #     pet.group == 'dogs'
  #   end
  #   # => true
  #
  # @return [Boolean]
  def any?(&block); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Returns +self+, so several appends may be
  # chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def append(*records); end

  def arel(*args, &block); end
  def bound_attributes(*args, &block); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  def build(attributes = T.unsafe(nil), &block); end

  def calculate(operation, column_name); end

  # Equivalent to +delete_all+. The difference is that returns +self+, instead
  # of an array with the deleted objects, so methods can be chained. See
  # +delete_all+ for more information.
  # Note that because +delete_all+ removes records by directly
  # running an SQL query into the database, the +updated_at+ column of
  # the object is not changed.
  def clear; end

  # Add one or more records to the collection by setting their foreign keys
  # to the association's primary key. Since #<< flattens its argument list and
  # inserts each record, +push+ and #concat behave identically. Returns +self+
  # so method calls may be chained.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets.concat(Pet.new(name: 'Fancy-Fancy'))
  #   person.pets.concat(Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo'))
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])
  #   person.pets.size # => 5
  def concat(*records); end

  # Count all records using SQL.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def count(column_name = T.unsafe(nil)); end

  # Returns a new object of the collection type that has been instantiated with
  # attributes, linked to this object and that has already been saved (if it
  # passes the validations).
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.create(name: 'Fancy-Fancy')
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 3
  #   person.pets.count # => 3
  #
  #   person.pets.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def create(attributes = T.unsafe(nil), &block); end

  # Like #create, except that if the record is invalid, raises an exception.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   class Pet
  #     validates :name, presence: true
  #   end
  #
  #   person.pets.create!(name: nil)
  #   # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
  def create!(attributes = T.unsafe(nil), &block); end

  def create_with(*args, &block); end
  def create_with!(*args, &block); end
  def create_with_value(*args, &block); end
  def create_with_value=(arg); end

  # Deletes the +records+ supplied from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy. Returns an array with the
  # deleted records.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>
  #
  # If it is set to <tt>:destroy</tt> all the +records+ are removed by calling
  # their +destroy+ method. See +destroy+ for more information.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 1
  #   person.pets
  #   # => [#<Pet id: 2, name: "Spook", person_id: 1>]
  #
  #   Pet.find(1, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the +records+ are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=1
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and executes delete on them.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete("1")
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.delete(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def delete(*records); end

  # Deletes all the records from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>,
  #   #       #<Pet id: 2, name: "Spook", person_id: nil>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: nil>
  #   #    ]
  #
  # Both +has_many+ and <tt>has_many :through</tt> dependencies default to the
  # +:delete_all+ strategy if the +:dependent+ option is set to +:destroy+.
  # Records are not instantiated and callbacks will not be fired.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the objects are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  def delete_all(dependent = T.unsafe(nil)); end

  # Destroys the +records+ supplied and removes them from the collection.
  # This method will _always_ remove record from the database ignoring
  # the +:dependent+ option. Returns an array with the removed records.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(2), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and then deletes them from the database.
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy("4")
  #   # => #<Pet id: 4, name: "Benny", person_id: 1>
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(5, 6)
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (4, 5, 6)
  def destroy(*records); end

  # Deletes the records of the collection directly from the database
  # ignoring the +:dependent+ option. Records are instantiated and it
  # invokes +before_remove+, +after_remove+ , +before_destroy+ and
  # +after_destroy+ callbacks.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy_all
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1) # => Couldn't find Pet with id=1
  def destroy_all; end

  # Specifies whether the records should be unique or not.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.select(:name)
  #   # => [
  #   #      #<Pet name: "Fancy-Fancy">,
  #   #      #<Pet name: "Fancy-Fancy">
  #   #    ]
  #
  #   person.pets.select(:name).distinct
  #   # => [#<Pet name: "Fancy-Fancy">]
  def distinct; end

  def distinct!(*args, &block); end
  def distinct_value(*args, &block); end
  def distinct_value=(arg); end
  def eager_load(*args, &block); end
  def eager_load!(*args, &block); end
  def eager_load_values(*args, &block); end
  def eager_load_values=(arg); end

  # Returns +true+ if the collection is empty. If the collection has been
  # loaded it is equivalent
  # to <tt>collection.size.zero?</tt>. If the collection has not been loaded,
  # it is equivalent to <tt>!collection.exists?</tt>. If the collection has
  # not already been loaded and you are going to fetch the records anyway it
  # is better to check <tt>collection.length.zero?</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count  # => 1
  #   person.pets.empty? # => false
  #
  #   person.pets.delete_all
  #
  #   person.pets.count  # => 0
  #   person.pets.empty? # => true
  #
  # @return [Boolean]
  def empty?; end

  def except(*args, &block); end
  def extending(*args, &block); end
  def extending!(*args, &block); end
  def extending_values(*args, &block); end
  def extending_values=(arg); end
  def extensions(*args, &block); end

  # Same as #first except returns only the fifth record.
  def fifth(*args); end

  # Finds an object in the collection responding to the +id+. Uses the same
  # rules as ActiveRecord::Base.find. Returns ActiveRecord::RecordNotFound
  # error if the object cannot be found.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=4
  #
  #   person.pets.find(2) { |pet| pet.name.downcase! }
  #   # => #<Pet id: 2, name: "fancy-fancy", person_id: 1>
  #
  #   person.pets.find(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def find(*args, &block); end

  # Returns the first record, or the first +n+ records, from the collection.
  # If the collection is empty, the first form returns +nil+, and the second
  # form returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.first # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.first(2)
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets          # => []
  #   another_person_without.pets.first    # => nil
  #   another_person_without.pets.first(3) # => []
  def first(*args); end

  # Same as #first except returns only the forty second record.
  # Also known as accessing "the reddit".
  def forty_two(*args); end

  # Same as #first except returns only the fourth record.
  def fourth(*args); end

  def from(*args, &block); end
  def from!(*args, &block); end
  def from_clause(*args, &block); end
  def from_clause=(arg); end
  def group(*args, &block); end
  def group!(*args, &block); end
  def group_values(*args, &block); end
  def group_values=(arg); end
  def having(*args, &block); end
  def having!(*args, &block); end
  def having_clause(*args, &block); end
  def having_clause=(arg); end

  # Returns +true+ if the given +record+ is present in the collection.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # => [#<Pet id: 20, name: "Snoop">]
  #
  #   person.pets.include?(Pet.find(20)) # => true
  #   person.pets.include?(Pet.find(21)) # => false
  #
  # @return [Boolean]
  def include?(record); end

  def includes(*args, &block); end
  def includes!(*args, &block); end
  def includes_values(*args, &block); end
  def includes_values=(arg); end
  def joins(*args, &block); end
  def joins!(*args, &block); end
  def joins_values(*args, &block); end
  def joins_values=(arg); end

  # Returns the last record, or the last +n+ records, from the collection.
  # If the collection is empty, the first form returns +nil+, and the second
  # form returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #
  #   person.pets.last(2)
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.last    # => nil
  #   another_person_without.pets.last(3) # => []
  def last(*args); end

  def left_joins(*args, &block); end
  def left_joins!(*args, &block); end
  def left_joins_values(*args, &block); end
  def left_joins_values=(arg); end
  def left_outer_joins(*args, &block); end
  def left_outer_joins!(*args, &block); end
  def left_outer_joins_values(*args, &block); end
  def left_outer_joins_values=(arg); end

  # Returns the size of the collection calling +size+ on the target.
  # If the collection has been already loaded, +length+ and +size+ are
  # equivalent. If not and you are going to need the records anyway this
  # method will take one less query. Otherwise +size+ is more efficient.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.length # => 3
  #   # executes something like SELECT "pets".* FROM "pets" WHERE "pets"."person_id" = 1
  #
  #   # Because the collection is loaded, you can
  #   # call the collection with no additional queries:
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def length; end

  def limit(*args, &block); end
  def limit!(*args, &block); end
  def limit_value(*args, &block); end
  def limit_value=(arg); end
  def load_target; end

  # Returns +true+ if the association has been loaded, otherwise +false+.
  #
  #   person.pets.loaded? # => false
  #   person.pets
  #   person.pets.loaded? # => true
  #
  # @return [Boolean]
  def loaded?; end

  def lock(*args, &block); end
  def lock!(*args, &block); end
  def lock_value(*args, &block); end
  def lock_value=(arg); end

  # Returns true if the collection has more than one record.
  # Equivalent to <tt>collection.size > 1</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count # => 1
  #   person.pets.many? # => false
  #
  #   person.pets << Pet.new(name: 'Snoopy')
  #   person.pets.count # => 2
  #   person.pets.many? # => true
  #
  # You can also pass a +block+ to define criteria. The
  # behavior is the same, it returns true if the collection
  # based on the criteria has more than one record.
  #
  #   person.pets
  #   # => [
  #   #      #<Pet name: "Gorby", group: "cats">,
  #   #      #<Pet name: "Puff", group: "cats">,
  #   #      #<Pet name: "Snoop", group: "dogs">
  #   #    ]
  #
  #   person.pets.many? do |pet|
  #     pet.group == 'dogs'
  #   end
  #   # => false
  #
  #   person.pets.many? do |pet|
  #     pet.group == 'cats'
  #   end
  #   # => true
  #
  # @return [Boolean]
  def many?(&block); end

  def merge(*args, &block); end
  def merge!(*args, &block); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  def new(attributes = T.unsafe(nil), &block); end

  def none(*args, &block); end
  def none!(*args, &block); end
  def offset(*args, &block); end
  def offset!(*args, &block); end
  def offset_value(*args, &block); end
  def offset_value=(arg); end
  def only(*args, &block); end
  def or(*args, &block); end
  def or!(*args, &block); end
  def order(*args, &block); end
  def order!(*args, &block); end
  def order_values(*args, &block); end
  def order_values=(arg); end
  def pluck(*column_names); end
  def preload(*args, &block); end
  def preload!(*args, &block); end
  def preload_values(*args, &block); end
  def preload_values=(arg); end

  # @raise [NoMethodError]
  def prepend(*args); end

  def proxy_association; end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Returns +self+, so several appends may be
  # chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  def push(*records); end

  def readonly(*args, &block); end
  def readonly!(*args, &block); end
  def readonly_value(*args, &block); end
  def readonly_value=(arg); end
  def records; end
  def references(*args, &block); end
  def references!(*args, &block); end
  def references_values(*args, &block); end
  def references_values=(arg); end

  # Reloads the collection from the database. Returns +self+.
  # Equivalent to <tt>collection(true)</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reload # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets(true)  # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  def reload; end

  def reorder(*args, &block); end
  def reorder!(*args, &block); end
  def reordering_value(*args, &block); end
  def reordering_value=(arg); end

  # Replaces this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
  #
  #   other_pets = [Pet.new(name: 'Puff', group: 'celebrities']
  #
  #   person.pets.replace(other_pets)
  #
  #   person.pets
  #   # => [#<Pet id: 2, name: "Puff", group: "celebrities", person_id: 1>]
  #
  # If the supplied array has an incorrect association type, it raises
  # an <tt>ActiveRecord::AssociationTypeMismatch</tt> error:
  #
  #   person.pets.replace(["doo", "ggie", "gaga"])
  #   # => ActiveRecord::AssociationTypeMismatch: Pet expected, got String
  def replace(other_array); end

  # Unloads the association. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reset # clears the pets cache
  #
  #   person.pets  # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  def reset; end

  def reset_scope; end
  def reverse_order(*args, &block); end
  def reverse_order!(*args, &block); end
  def reverse_order_value(*args, &block); end
  def reverse_order_value=(arg); end
  def rewhere(*args, &block); end

  # Returns a <tt>Relation</tt> object for the records in this association
  def scope; end

  def scoping(*args, &block); end

  # Same as #first except returns only the second record.
  def second(*args); end

  # Same as #first except returns only the second-to-last record.
  def second_to_last(*args); end

  # Works in two ways.
  #
  # *First:* Specify a subset of fields to be selected from the result set.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.select(:name)
  #   # => [
  #   #      #<Pet id: nil, name: "Fancy-Fancy">,
  #   #      #<Pet id: nil, name: "Spook">,
  #   #      #<Pet id: nil, name: "Choo-Choo">
  #   #    ]
  #
  #   person.pets.select(:id, :name )
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy">,
  #   #      #<Pet id: 2, name: "Spook">,
  #   #      #<Pet id: 3, name: "Choo-Choo">
  #   #    ]
  #
  # Be careful because this also means you're initializing a model
  # object with only the fields that you've selected. If you attempt
  # to access a field except +id+ that is not in the initialized record you'll
  # receive:
  #
  #   person.pets.select(:name).first.person_id
  #   # => ActiveModel::MissingAttributeError: missing attribute: person_id
  #
  # *Second:* You can pass a block so it can be used just like Array#select.
  # This builds an array of objects from the database for the scope,
  # converting them into an array and iterating through them using
  # Array#select.
  #
  #   person.pets.select { |pet| pet.name =~ /oo/ }
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.select(:name) { |pet| pet.name =~ /oo/ }
  #   # => [
  #   #      #<Pet id: 2, name: "Spook">,
  #   #      #<Pet id: 3, name: "Choo-Choo">
  #   #    ]
  def select(*fields, &block); end

  def select_values(*args, &block); end
  def select_values=(arg); end

  # Returns the size of the collection. If the collection hasn't been loaded,
  # it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
  #
  #   person.pets # This will execute a SELECT * FROM query
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 3
  #   # Because the collection is already loaded, this will behave like
  #   # collection.size and no SQL count query is executed.
  def size; end

  def spawn(*args, &block); end

  # Gives a record (or N records if a parameter is supplied) from the collection
  # using the same rules as <tt>ActiveRecord::Base.take</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.take # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.take(2)
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.take    # => nil
  #   another_person_without.pets.take(2) # => []
  def take(n = T.unsafe(nil)); end

  def target; end

  # Same as #first except returns only the third record.
  def third(*args); end

  # Same as #first except returns only the third-to-last record.
  def third_to_last(*args); end

  # Returns a new array of objects from the collection. If the collection
  # hasn't been loaded, it fetches the records from the database.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets = person.pets.to_ary
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets.replace([Pet.new(name: 'BooGoo')])
  #
  #   other_pets
  #   # => [#<Pet id: nil, name: "BooGoo", person_id: 1>]
  #
  #   person.pets
  #   # This is not affected by replace
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  def to_a; end

  # Returns a new array of objects from the collection. If the collection
  # hasn't been loaded, it fetches the records from the database.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets = person.pets.to_ary
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets.replace([Pet.new(name: 'BooGoo')])
  #
  #   other_pets
  #   # => [#<Pet id: nil, name: "BooGoo", person_id: 1>]
  #
  #   person.pets
  #   # This is not affected by replace
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  def to_ary; end

  # Specifies whether the records should be unique or not.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.select(:name)
  #   # => [
  #   #      #<Pet name: "Fancy-Fancy">,
  #   #      #<Pet name: "Fancy-Fancy">
  #   #    ]
  #
  #   person.pets.select(:name).distinct
  #   # => [#<Pet name: "Fancy-Fancy">]
  def uniq; end

  def uniq!(*args, &block); end
  def unscope(*args, &block); end
  def unscope!(*args, &block); end
  def unscope_values(*args, &block); end
  def unscope_values=(arg); end
  def where(*args, &block); end
  def where!(*args, &block); end
  def where_clause(*args, &block); end
  def where_clause=(arg); end

  private

  def exec_queries; end

  # @return [Boolean]
  def null_scope?; end
end

module ActiveRecord::Associations::ForeignAssociation
  # @return [Boolean]
  def foreign_key_present?; end
end

# This is the proxy that handles a has many association.
#
# If the association has a <tt>:through</tt> option further specialization
# is provided by its child HasManyThroughAssociation.
class ActiveRecord::Associations::HasManyAssociation < ::ActiveRecord::Associations::CollectionAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  # @return [Boolean]
  def empty?; end

  def handle_dependency; end
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  def _create_record(attributes, *_arg1); end
  def concat_records(records, *_arg1); end

  # Returns the number of records in this collection.
  #
  # If the association has a counter cache it gets that value. Otherwise
  # it will attempt to do a count via SQL, bounded to <tt>:limit</tt> if
  # there's one. Some configuration options like :group make it impossible
  # to do an SQL count, in those cases the array count will be used.
  #
  # That does not depend on whether the collection has already been loaded
  # or not. The +size+ method is the one that takes the loaded flag into
  # account and delegates to +count_records+ if needed.
  #
  # If the collection is empty the target is set to an empty array and
  # the loaded flag is set to true as well.
  def count_records; end

  def delete_count(method, scope); end
  def delete_or_nullify_all_records(method); end

  # Deletes the records according to the <tt>:dependent</tt> option.
  def delete_records(records, method); end

  def update_counter(difference, reflection = T.unsafe(nil)); end
  def update_counter_if_success(saved_successfully, difference); end
  def update_counter_in_memory(difference, reflection = T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasManyThroughAssociation < ::ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  # @return [HasManyThroughAssociation] a new instance of HasManyThroughAssociation
  def initialize(owner, reflection); end

  def concat(*records); end
  def concat_records(records); end
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  def build_record(attributes); end

  # The through record (built with build_record) is temporarily cached
  # so that it may be reused if insert_record is subsequently called.
  #
  # However, after insert_record has been called, the cache is cleared in
  # order to allow multiple instances of the same record in an association.
  def build_through_record(record); end

  def delete_or_nullify_all_records(method); end
  def delete_records(records, method); end
  def delete_through_records(records); end
  def find_target; end

  # NOTE - not sure that we can actually cope with inverses here
  #
  # @return [Boolean]
  def invertible_for?(record); end

  def options_for_through_record; end
  def save_through_record(record); end

  # @return [Boolean]
  def target_reflection_has_associated_record?; end

  def through_association; end
  def through_records_for(record); end
  def through_scope_attributes; end

  # @return [Boolean]
  def update_through_counter?(method); end
end

class ActiveRecord::Associations::HasOneAssociation < ::ActiveRecord::Associations::SingularAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  def delete(method = T.unsafe(nil)); end
  def handle_dependency; end
  def replace(record, save = T.unsafe(nil)); end

  private

  def nullify_owner_attributes(record); end
  def remove_target!(method); end

  # The reason that the save param for replace is false, if for create (not just build),
  # is because the setting of the foreign keys is actually handled by the scoping when
  # the record is instantiated, and so they are set straight away and do not need to be
  # updated within replace.
  def set_new_record(record); end

  def transaction_if(value); end
end

class ActiveRecord::Associations::HasOneThroughAssociation < ::ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  def replace(record); end

  private

  def create_through_record(record); end
end

class ActiveRecord::Associations::JoinDependency
  # base is the base class on which operation is taking place.
  # associations is the list of associations which are joined using hash, symbol or array.
  # joins is the list of all string join commands and arel nodes.
  #
  #  Example :
  #
  #  class Physician < ActiveRecord::Base
  #    has_many :appointments
  #    has_many :patients, through: :appointments
  #  end
  #
  #  If I execute `@physician.patients.to_a` then
  #    base # => Physician
  #    associations # => []
  #    joins # =>  [#<Arel::Nodes::InnerJoin: ...]
  #
  #  However if I execute `Physician.joins(:appointments).to_a` then
  #    base # => Physician
  #    associations # => [:appointments]
  #    joins # =>  []
  #
  # @return [JoinDependency] a new instance of JoinDependency
  def initialize(base, associations, joins); end

  # Returns the value of attribute alias_tracker.
  def alias_tracker; end

  def aliases; end

  # Returns the value of attribute base_klass.
  def base_klass; end

  def instantiate(result_set, aliases); end
  def join_constraints(outer_joins, join_type); end

  # Returns the value of attribute join_root.
  def join_root; end

  def reflections; end

  private

  def build(associations, base_klass); end
  def construct(ar_parent, parent, row, rs, seen, model_cache, aliases); end
  def construct_model(record, node, row, model_cache, id, aliases); end
  def construct_tables!(parent, node); end
  def find_reflection(klass, name); end
  def make_constraints(parent, child, tables, join_type); end
  def make_inner_joins(parent, child); end
  def make_left_outer_joins(parent, child); end
  def make_outer_joins(parent, child); end
  def table_alias_for(reflection, parent, join); end
  def table_aliases_for(parent, node); end
  def walk(left, right); end

  class << self
    def make_tree(associations); end
    def walk_tree(associations, hash); end
  end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  # @return [Aliases] a new instance of Aliases
  def initialize(tables); end

  def column_alias(node, column); end

  # An array of [column_name, alias] pairs for the table
  def column_aliases(node); end

  def columns; end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column < ::Struct
  # Returns the value of attribute alias
  #
  # @return [Object] the current value of alias
  def alias; end

  # Sets the attribute alias
  #
  # @param value [Object] the value to set the attribute alias to.
  # @return [Object] the newly set value
  def alias=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table < ::Struct
  def column_aliases; end
  def table; end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation < ::ActiveRecord::Associations::JoinDependency::JoinPart
  # @return [JoinAssociation] a new instance of JoinAssociation
  def initialize(reflection, children); end

  def aliased_table_name; end

  # Builds equality condition.
  #
  #  Example:
  #
  #  class Physician < ActiveRecord::Base
  #    has_many :appointments
  #  end
  #
  #  If I execute `Physician.joins(:appointments).to_a` then
  #    klass         # => Physician
  #    table         # => #<Arel::Table @name="appointments" ...>
  #    key           # =>  physician_id
  #    foreign_table # => #<Arel::Table @name="physicians" ...>
  #    foreign_key   # => id
  def build_constraint(klass, table, key, foreign_table, foreign_key); end

  def join_constraints(foreign_table, foreign_klass, node, join_type, tables, scope_chain, chain); end

  # @return [Boolean]
  def match?(other); end

  # The reflection of the association represented
  def reflection; end

  def table; end

  # Returns the value of attribute tables.
  def tables; end

  # Sets the attribute tables
  #
  # @param value the value to set the attribute tables to.
  def tables=(_arg0); end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation::JoinInformation < ::Struct
  # Returns the value of attribute binds
  #
  # @return [Object] the current value of binds
  def binds; end

  # Sets the attribute binds
  #
  # @param value [Object] the value to set the attribute binds to.
  # @return [Object] the newly set value
  def binds=(_); end

  # Returns the value of attribute joins
  #
  # @return [Object] the current value of joins
  def joins; end

  # Sets the attribute joins
  #
  # @param value [Object] the value to set the attribute joins to.
  # @return [Object] the newly set value
  def joins=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::Associations::JoinDependency::JoinBase < ::ActiveRecord::Associations::JoinDependency::JoinPart
  def aliased_table_name; end

  # @return [Boolean]
  def match?(other); end

  def table; end
end

# A JoinPart represents a part of a JoinDependency. It is inherited
# by JoinBase and JoinAssociation. A JoinBase represents the Active Record which
# everything else is being joined onto. A JoinAssociation represents an association which
# is joining to the base. A JoinAssociation may result in more than one actual join
# operations (for example a has_and_belongs_to_many JoinAssociation would result in
# two; one for the join table and one for the target table).
class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable

  # @return [JoinPart] a new instance of JoinPart
  def initialize(base_klass, children); end

  # The alias for the active_record's table
  #
  # @raise [NotImplementedError]
  def aliased_table_name; end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  def base_klass; end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  def children; end

  def column_names(*args, &block); end

  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Associations::JoinDependency::JoinPart] the object that the method was called on
  def each(&block); end

  def extract_record(row, column_names_with_alias); end
  def instantiate(row, aliases, &block); end

  # @return [Boolean]
  def match?(other); end

  def name; end
  def primary_key(*args, &block); end

  # An Arel::Table for the active_record
  #
  # @raise [NotImplementedError]
  def table; end

  def table_name(*args, &block); end
end

# Implements the details of eager loading of Active Record associations.
#
# Suppose that you have the following two Active Record models:
#
#   class Author < ActiveRecord::Base
#     # columns: name, age
#     has_many :books
#   end
#
#   class Book < ActiveRecord::Base
#     # columns: title, sales, author_id
#   end
#
# When you load an author with all associated books Active Record will make
# multiple queries like this:
#
#   Author.includes(:books).where(name: ['bell hooks', 'Homer']).to_a
#
#   => SELECT `authors`.* FROM `authors` WHERE `name` IN ('bell hooks', 'Homer')
#   => SELECT `books`.* FROM `books` WHERE `author_id` IN (2, 5)
#
# Active Record saves the ids of the records from the first query to use in
# the second. Depending on the number of associations involved there can be
# arbitrarily many SQL queries made.
#
# However, if there is a WHERE clause that spans across tables Active
# Record will fall back to a slightly more resource-intensive single query:
#
#   Author.includes(:books).where(books: {title: 'Illiad'}).to_a
#   => SELECT `authors`.`id` AS t0_r0, `authors`.`name` AS t0_r1, `authors`.`age` AS t0_r2,
#             `books`.`id`   AS t1_r0, `books`.`title`  AS t1_r1, `books`.`sales` AS t1_r2
#      FROM `authors`
#      LEFT OUTER JOIN `books` ON `authors`.`id` =  `books`.`author_id`
#      WHERE `books`.`title` = 'Illiad'
#
# This could result in many rows that contain redundant data and it performs poorly at scale
# and is therefore only used when necessary.
class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload

  # Eager loads the named associations for the given Active Record record(s).
  #
  # In this description, 'association name' shall refer to the name passed
  # to an association creation method. For example, a model that specifies
  # <tt>belongs_to :author</tt>, <tt>has_many :buyers</tt> has association
  # names +:author+ and +:buyers+.
  #
  # == Parameters
  # +records+ is an array of ActiveRecord::Base. This array needs not be flat,
  # i.e. +records+ itself may also contain arrays of records. In any case,
  # +preload_associations+ will preload the all associations records by
  # flattening +records+.
  #
  # +associations+ specifies one or more associations that you want to
  # preload. It may be:
  # - a Symbol or a String which specifies a single association name. For
  #   example, specifying +:books+ allows this method to preload all books
  #   for an Author.
  # - an Array which specifies multiple association names. This array
  #   is processed recursively. For example, specifying <tt>[:avatar, :books]</tt>
  #   allows this method to preload an author's avatar as well as all of his
  #   books.
  # - a Hash which specifies multiple association names, as well as
  #   association names for the to-be-preloaded association objects. For
  #   example, specifying <tt>{ author: :avatar }</tt> will preload a
  #   book's author, as well as that author's avatar.
  #
  # +:associations+ has the same format as the +:include+ option for
  # <tt>ActiveRecord::Base.find</tt>. So +associations+ could look like this:
  #
  #   :books
  #   [ :books, :author ]
  #   { author: :avatar }
  #   [ :books, { author: :avatar } ]
  def preload(records, associations, preload_scope = T.unsafe(nil)); end

  private

  def grouped_records(association, records); end

  # Returns a class containing the logic needed to load preload the data
  # and attach it to a relation. For example +Preloader::Association+ or
  # +Preloader::HasManyThrough+. The class returned implements a `run` method
  # that accepts a preloader.
  def preloader_for(reflection, owners, rhs_klass); end

  def preloaders_for_hash(association, records, scope); end

  # Loads all the given data into +records+ for a singular +association+.
  #
  # Functions by instantiating a preloader class such as Preloader::HasManyThrough and
  # call the +run+ method for each passed in class in the +records+ argument.
  #
  # Not all records have the same class, so group then preload group on the reflection
  # itself so that if various subclass share the same association then we do not split
  # them unnecessarily
  #
  # Additionally, polymorphic belongs_to associations can have multiple associated
  # classes, depending on the polymorphic_type field. So we group by the classes as
  # well.
  def preloaders_for_one(association, records, scope); end

  # Loads all the given data into +records+ for the +association+.
  def preloaders_on(association, records, scope); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
  # @return [AlreadyLoaded] a new instance of AlreadyLoaded
  def initialize(klass, owners, reflection, preload_scope); end

  # Returns the value of attribute owners.
  def owners; end

  def preloaded_records; end

  # Returns the value of attribute reflection.
  def reflection; end

  def run(preloader); end
end

class ActiveRecord::Associations::Preloader::Association
  # @return [Association] a new instance of Association
  def initialize(klass, owners, reflection, preload_scope); end

  # This is overridden by HABTM as the condition should be on the foreign_key column in
  # the join table
  def association_key; end

  # The name of the key on the associated records
  #
  # @raise [NotImplementedError]
  def association_key_name; end

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute model.
  def model; end

  def options; end

  # The name of the key on the model which declares the association
  #
  # @raise [NotImplementedError]
  def owner_key_name; end

  # Returns the value of attribute owners.
  def owners; end

  # @raise [NotImplementedError]
  def preload(preloader); end

  # Returns the value of attribute preload_scope.
  def preload_scope; end

  # Returns the value of attribute preloaded_records.
  def preloaded_records; end

  def query_scope(ids); end
  def records_for(ids); end

  # Returns the value of attribute reflection.
  def reflection; end

  def run(preloader); end
  def scope; end
  def table; end

  private

  def associated_records_by_owner(preloader); end
  def association_key_type; end
  def build_scope; end
  def convert_key(key); end

  # @return [Boolean]
  def key_conversion_required?; end

  def load_records(&block); end
  def owner_key_type; end
  def owner_keys; end
  def owners_by_key; end
  def reflection_scope; end
end

class ActiveRecord::Associations::Preloader::BelongsTo < ::ActiveRecord::Associations::Preloader::SingularAssociation
  def association_key_name; end
  def owner_key_name; end
end

class ActiveRecord::Associations::Preloader::CollectionAssociation < ::ActiveRecord::Associations::Preloader::Association
  private

  def preload(preloader); end
end

class ActiveRecord::Associations::Preloader::HasMany < ::ActiveRecord::Associations::Preloader::CollectionAssociation
  def association_key_name; end
  def owner_key_name; end
end

class ActiveRecord::Associations::Preloader::HasManyThrough < ::ActiveRecord::Associations::Preloader::CollectionAssociation
  include ::ActiveRecord::Associations::Preloader::ThroughAssociation

  def associated_records_by_owner(preloader); end
end

class ActiveRecord::Associations::Preloader::HasOne < ::ActiveRecord::Associations::Preloader::SingularAssociation
  def association_key_name; end
  def owner_key_name; end
end

class ActiveRecord::Associations::Preloader::HasOneThrough < ::ActiveRecord::Associations::Preloader::SingularAssociation
  include ::ActiveRecord::Associations::Preloader::ThroughAssociation
end

ActiveRecord::Associations::Preloader::NULL_RELATION = T.let(T.unsafe(nil), T.untyped)

class ActiveRecord::Associations::Preloader::NullPreloader
  class << self
    def new(klass, owners, reflection, preload_scope); end
    def owners; end
    def preloaded_records; end
    def run(preloader); end
  end
end

class ActiveRecord::Associations::Preloader::SingularAssociation < ::ActiveRecord::Associations::Preloader::Association
  private

  def preload(preloader); end
end

module ActiveRecord::Associations::Preloader::ThroughAssociation
  def associated_records_by_owner(preloader); end
  def source_reflection; end
  def through_reflection; end

  private

  def id_to_index_map(ids); end
  def reset_association(owners, association_name); end
  def target_records_from_association(association); end
  def through_scope; end
end

class ActiveRecord::Associations::SingularAssociation < ::ActiveRecord::Associations::Association
  # @yield [record]
  def build(attributes = T.unsafe(nil)); end

  def create(attributes = T.unsafe(nil), &block); end
  def create!(attributes = T.unsafe(nil), &block); end

  # Implements the reload reader method, e.g. foo.reload_bar for
  # Foo.has_one :bar
  def force_reload_reader; end

  # Implements the reader method, e.g. foo.bar for Foo.has_one :bar
  def reader(force_reload = T.unsafe(nil)); end

  # Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar
  def writer(record); end

  private

  # @raise [RecordInvalid]
  # @yield [record]
  def _create_record(attributes, raise_error = T.unsafe(nil)); end

  def create_scope; end
  def find_target; end
  def get_records; end

  # @raise [NotImplementedError]
  def replace(record); end

  def set_new_record(record); end
end

module ActiveRecord::Associations::ThroughAssociation
  def source_reflection(*args, &block); end
  def through_reflection(*args, &block); end

  protected

  # We merge in these scopes for two reasons:
  #
  #   1. To get the default_scope conditions for any of the other reflections in the chain
  #   2. To get the type conditions for any STI models in the chain
  def target_scope; end

  private

  def build_record(attributes); end

  # Construct attributes for :through pointing to owner and associate. This is used by the
  # methods which create and delete records on the association.
  #
  # We only support indirectly modifying through associations which have a belongs_to source.
  # This is the "has_many :tags, through: :taggings" situation, where the join model
  # typically has a belongs_to on both side. In other words, associations which could also
  # be represented as has_and_belongs_to_many associations.
  #
  # We do not support creating/deleting records on the association where the source has
  # some other type, because this opens up a whole can of worms, and in basically any
  # situation it is more natural for the user to just create or modify their join records
  # directly as required.
  def construct_join_attributes(*records); end

  def ensure_mutable; end
  def ensure_not_nested; end

  # @return [Boolean]
  def foreign_key_present?; end

  # Note: this does not capture all cases, for example it would be crazy to try to
  # properly support stale-checking for nested associations.
  def stale_state; end
end

class ActiveRecord::Attribute
  # This method should not be called directly.
  # Use #from_database or #from_user
  #
  # @return [Attribute] a new instance of Attribute
  def initialize(name, value_before_type_cast, type, original_attribute = T.unsafe(nil)); end

  def ==(other); end

  # @return [Boolean]
  def came_from_user?; end

  # @return [Boolean]
  def changed?; end

  # @return [Boolean]
  def changed_in_place?; end

  def eql?(other); end
  def forgetting_assignment; end

  # @return [Boolean]
  def has_been_read?; end

  def hash; end

  # @return [Boolean]
  def initialized?; end

  # Returns the value of attribute name.
  def name; end

  def original_value; end

  # Returns the value of attribute type.
  def type; end

  # @raise [NotImplementedError]
  def type_cast(*_arg0); end

  def value; end

  # Returns the value of attribute value_before_type_cast.
  def value_before_type_cast; end

  def value_for_database; end
  def with_cast_value(value); end
  def with_type(type); end
  def with_value_from_database(value); end
  def with_value_from_user(value); end

  protected

  def _original_value_for_database; end

  # Returns the value of attribute original_attribute.
  def assigned?; end

  # @return [Boolean]
  def changed_from_assignment?; end

  # Returns the value of attribute original_attribute.
  def original_attribute; end

  def original_value_for_database; end

  private

  def initialize_dup(other); end

  class << self
    def from_database(name, value, type); end
    def from_user(name, value, type, original_attribute = T.unsafe(nil)); end
    def null(name); end
    def uninitialized(name, type); end
    def with_cast_value(name, value, type); end
  end
end

class ActiveRecord::Attribute::FromDatabase < ::ActiveRecord::Attribute
  def _original_value_for_database; end
  def type_cast(value); end
end

class ActiveRecord::Attribute::FromUser < ::ActiveRecord::Attribute
  # @return [Boolean]
  def came_from_user?; end

  def type_cast(value); end
end

class ActiveRecord::Attribute::Null < ::ActiveRecord::Attribute
  # @return [Null] a new instance of Null
  def initialize(name); end

  def type_cast(*_arg0); end
  def with_type(type); end

  # @raise [ActiveModel::MissingAttributeError]
  def with_value_from_database(value); end

  # @raise [ActiveModel::MissingAttributeError]
  def with_value_from_user(value); end
end

class ActiveRecord::Attribute::Uninitialized < ::ActiveRecord::Attribute
  # @return [Uninitialized] a new instance of Uninitialized
  def initialize(name, type); end

  # @return [Boolean]
  def initialized?; end

  def original_value; end
  def value; end
  def value_for_database; end
end

ActiveRecord::Attribute::Uninitialized::UNINITIALIZED_ORIGINAL_VALUE = T.let(T.unsafe(nil), Object)

class ActiveRecord::Attribute::UserProvidedDefault < ::ActiveRecord::Attribute::FromUser
  # @return [UserProvidedDefault] a new instance of UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def value_before_type_cast; end
  def with_type(type); end

  protected

  # Returns the value of attribute user_provided_value.
  def user_provided_value; end
end

class ActiveRecord::Attribute::WithCastValue < ::ActiveRecord::Attribute
  # @return [Boolean]
  def changed_in_place?; end

  def type_cast(value); end
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  extend ::ActiveSupport::Concern

  # Alias for ActiveModel::AttributeAssignment#assign_attributes. See ActiveModel::AttributeAssignment.
  def attributes=(attributes); end

  private

  def _assign_attributes(attributes); end

  # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
  # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
  # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate
  # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the
  # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Integer and
  # f for Float. If all the values for a given attribute are empty, the attribute will be set to +nil+.
  def assign_multiparameter_attributes(pairs); end

  # Assign any deferred nested attributes after the base attributes have been set.
  def assign_nested_parameter_attributes(pairs); end

  def execute_callstack_for_multiparameter_attributes(callstack); end
  def extract_callstack_for_multiparameter_attributes(pairs); end
  def find_parameter_position(multiparameter_name); end
  def type_cast_attribute_value(multiparameter_name, value); end
end

# Raised when an error occurred while doing a mass assignment to an attribute through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
# The exception has an +attribute+ property that is the name of the offending attribute.
class ActiveRecord::AttributeAssignmentError < ::ActiveRecord::ActiveRecordError
  # @return [AttributeAssignmentError] a new instance of AttributeAssignmentError
  def initialize(message = T.unsafe(nil), exception = T.unsafe(nil), attribute = T.unsafe(nil)); end

  # Returns the value of attribute attribute.
  def attribute; end

  # Returns the value of attribute exception.
  def exception; end
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeDecorators::ClassMethods

  module GeneratedClassMethods
    def attribute_type_decorations; end
    def attribute_type_decorations=(value); end
    def attribute_type_decorations?; end
  end

  module GeneratedInstanceMethods; end
end

module ActiveRecord::AttributeDecorators::ClassMethods
  def decorate_attribute_type(column_name, decorator_name, &block); end
  def decorate_matching_attribute_types(matcher, decorator_name, &block); end

  private

  def load_schema!; end
end

class ActiveRecord::AttributeDecorators::TypeDecorator
  # @return [TypeDecorator] a new instance of TypeDecorator
  def initialize(decorations = T.unsafe(nil)); end

  def apply(name, type); end
  def clear(*args, &block); end
  def merge(*args); end

  private

  def decorators_for(name, type); end
  def matching(name, type); end
end

# = Active Record Attribute Methods
module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods

  # Returns the value of the attribute identified by <tt>attr_name</tt> after it has been typecast (for example,
  # "2004-12-12" in a date column is cast to a date object, like Date.new(2004, 12, 12)). It raises
  # <tt>ActiveModel::MissingAttributeError</tt> if the identified attribute is missing.
  #
  # Note: +:id+ is always present.
  #
  # Alias for the #read_attribute method.
  #
  #   class Person < ActiveRecord::Base
  #     belongs_to :organization
  #   end
  #
  #   person = Person.new(name: 'Francesco', age: '22')
  #   person[:name] # => "Francesco"
  #   person[:age]  # => 22
  #
  #   person = Person.select('id').first
  #   person[:name]            # => ActiveModel::MissingAttributeError: missing attribute: name
  #   person[:organization_id] # => ActiveModel::MissingAttributeError: missing attribute: organization_id
  def [](attr_name); end

  # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.
  # (Alias for the protected #write_attribute method).
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person[:age] = '22'
  #   person[:age] # => 22
  #   person[:age].class # => Integer
  def []=(attr_name, value); end

  # Returns the name of all database fields which have been read from this
  # model. This can be useful in development mode to determine which fields
  # need to be selected. For performance critical pages, selecting only the
  # required fields can be an easy performance win (assuming you aren't using
  # all of the fields on the model).
  #
  # For example:
  #
  #   class PostsController < ActionController::Base
  #     after_action :print_accessed_fields, only: :index
  #
  #     def index
  #       @posts = Post.all
  #     end
  #
  #     private
  #
  #     def print_accessed_fields
  #       p @posts.first.accessed_fields
  #     end
  #   end
  #
  # Which allows you to quickly change your code to:
  #
  #   class PostsController < ActionController::Base
  #     def index
  #       @posts = Post.select(:id, :title, :author_id, :updated_at)
  #     end
  #   end
  def accessed_fields; end

  # Returns an <tt>#inspect</tt>-like string for the value of the
  # attribute +attr_name+. String attributes are truncated up to 50
  # characters, Date and Time attributes are returned in the
  # <tt>:db</tt> format. Other attributes return the value of
  # <tt>#inspect</tt> without modification.
  #
  #   person = Person.create!(name: 'David Heinemeier Hansson ' * 3)
  #
  #   person.attribute_for_inspect(:name)
  #   # => "\"David Heinemeier Hansson David Heinemeier Hansson ...\""
  #
  #   person.attribute_for_inspect(:created_at)
  #   # => "\"2012-10-22 00:15:07\""
  #
  #   person.attribute_for_inspect(:tag_ids)
  #   # => "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]"
  def attribute_for_inspect(attr_name); end

  # Returns an array of names for the attributes available on this object.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  def attribute_names; end

  # Returns +true+ if the specified +attribute+ has been set by the user or by a
  # database load and is neither +nil+ nor <tt>empty?</tt> (the latter only applies
  # to objects that respond to <tt>empty?</tt>, most notably Strings). Otherwise, +false+.
  # Note that it always returns +true+ with boolean attributes.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: '', is_done: false)
  #   task.attribute_present?(:title)   # => false
  #   task.attribute_present?(:is_done) # => true
  #   task.title = 'Buy milk'
  #   task.is_done = true
  #   task.attribute_present?(:title)   # => true
  #   task.attribute_present?(:is_done) # => true
  #
  # @return [Boolean]
  def attribute_present?(attribute); end

  # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.create(name: 'Francesco', age: 22)
  #   person.attributes
  #   # => {"id"=>3, "created_at"=>Sun, 21 Oct 2012 04:53:04, "updated_at"=>Sun, 21 Oct 2012 04:53:04, "name"=>"Francesco", "age"=>22}
  def attributes; end

  # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.has_attribute?(:name)    # => true
  #   person.has_attribute?('age')    # => true
  #   person.has_attribute?(:nothing) # => false
  #
  # @return [Boolean]
  def has_attribute?(attr_name); end

  # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
  # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
  # which will all return +true+. It also defines the attribute methods if they have
  # not been generated.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.respond_to(:name)    # => true
  #   person.respond_to(:name=)   # => true
  #   person.respond_to(:name?)   # => true
  #   person.respond_to('age')    # => true
  #   person.respond_to('age=')   # => true
  #   person.respond_to('age?')   # => true
  #   person.respond_to(:nothing) # => false
  #
  # @return [Boolean]
  def respond_to?(name, include_private = T.unsafe(nil)); end

  protected

  def arel_attributes_with_values_for_create(attribute_names); end
  def arel_attributes_with_values_for_update(attribute_names); end

  # @return [Boolean]
  def attribute_method?(attr_name); end

  def clone_attribute_value(reader_method, attribute_name); end

  private

  # Returns a Hash of the Arel::Attributes and attribute values that have been
  # typecasted for use in an Arel insert/update method.
  def arel_attributes_with_values(attribute_names); end

  # Filters out the primary keys, from the attribute names, when the primary
  # key is to be generated (e.g. the id attribute has no value).
  def attributes_for_create(attribute_names); end

  # Filters the primary keys and readonly attributes from the attribute names.
  def attributes_for_update(attribute_names); end

  # @return [Boolean]
  def pk_attribute?(name); end

  # @return [Boolean]
  def readonly_attribute?(name); end

  def typecasted_attribute_value(name); end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes=(value); end
    def partial_writes?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

module ActiveRecord::AttributeMethods::AttrNames
  class << self
    def set_name_cache(name, value); end
  end
end

ActiveRecord::AttributeMethods::BLACKLISTED_CLASS_METHODS = T.let(T.unsafe(nil), Array)

# = Active Record Attribute Methods Before Type Cast
#
# ActiveRecord::AttributeMethods::BeforeTypeCast provides a way to
# read the value of the attributes before typecasting and deserialization.
#
#   class Task < ActiveRecord::Base
#   end
#
#   task = Task.new(id: '1', completed_on: '2012-10-21')
#   task.id           # => 1
#   task.completed_on # => Sun, 21 Oct 2012
#
#   task.attributes_before_type_cast
#   # => {"id"=>"1", "completed_on"=>"2012-10-21", ... }
#   task.read_attribute_before_type_cast('id')           # => "1"
#   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
#
# In addition to #read_attribute_before_type_cast and #attributes_before_type_cast,
# it declares a method for all attributes with the <tt>*_before_type_cast</tt>
# suffix.
#
#   task.id_before_type_cast           # => "1"
#   task.completed_on_before_type_cast # => "2012-10-21"
module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern

  # Returns a hash of attributes before typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: nil, is_done: true, completed_on: '2012-10-21')
  #   task.attributes
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>Sun, 21 Oct 2012, "created_at"=>nil, "updated_at"=>nil}
  #   task.attributes_before_type_cast
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>"2012-10-21", "created_at"=>nil, "updated_at"=>nil}
  def attributes_before_type_cast; end

  # Returns the value of the attribute identified by +attr_name+ before
  # typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(id: '1', completed_on: '2012-10-21')
  #   task.read_attribute('id')                            # => 1
  #   task.read_attribute_before_type_cast('id')           # => '1'
  #   task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012
  #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
  #   task.read_attribute_before_type_cast(:completed_on)  # => "2012-10-21"
  def read_attribute_before_type_cast(attr_name); end

  private

  # Handle *_before_type_cast for method_missing.
  def attribute_before_type_cast(attribute_name); end

  # @return [Boolean]
  def attribute_came_from_user?(attribute_name); end
end

module ActiveRecord::AttributeMethods::ClassMethods
  # Returns +true+ if +attribute+ is an attribute method and table exists,
  # +false+ otherwise.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_method?('name')   # => true
  #   Person.attribute_method?(:age=)    # => true
  #   Person.attribute_method?(:nothing) # => false
  #
  # @return [Boolean]
  def attribute_method?(attribute); end

  # Returns an array of column names as strings if it's not an abstract class and
  # table exists. Otherwise it returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  def attribute_names; end

  # @return [Boolean]
  def class_method_defined_within?(name, klass, superklass = T.unsafe(nil)); end

  # Returns the column object for the named attribute.
  # Returns a +ActiveRecord::ConnectionAdapters::NullColumn+ if the
  # named attribute does not exist.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
  #   # => #<ActiveRecord::ConnectionAdapters::Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>
  #
  #   person.column_for_attribute(:nothing)
  #   # => #<ActiveRecord::ConnectionAdapters::NullColumn:0xXXX @name=nil, @sql_type=nil, @cast_type=#<Type::Value>, ...>
  def column_for_attribute(name); end

  # A method name is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'save' is.)
  #
  # @return [Boolean]
  def dangerous_attribute_method?(name); end

  # A class method is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'new' is.)
  #
  # @return [Boolean]
  def dangerous_class_method?(method_name); end

  # Generates all the attribute related methods for columns in the database
  # accessors, mutators and query methods.
  def define_attribute_methods; end

  # Returns true if the given attribute exists, otherwise false.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.has_attribute?('name')   # => true
  #   Person.has_attribute?(:age)     # => true
  #   Person.has_attribute?(:nothing) # => false
  #
  # @return [Boolean]
  def has_attribute?(attr_name); end

  def inherited(child_class); end
  def initialize_generated_modules; end

  # Raises an ActiveRecord::DangerousAttributeError exception when an
  # \Active \Record method is defined in the model, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #     def save
  #       'already defined by Active Record'
  #     end
  #   end
  #
  #   Person.instance_method_already_implemented?(:save)
  #   # => ActiveRecord::DangerousAttributeError: save is defined by Active Record. Check to make sure that you don't have an attribute or method with the same name.
  #
  #   Person.instance_method_already_implemented?(:name)
  #   # => false
  #
  # @return [Boolean]
  def instance_method_already_implemented?(method_name); end

  # @return [Boolean]
  def method_defined_within?(name, klass, superklass = T.unsafe(nil)); end

  def undefine_attribute_methods; end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveModel::Dirty

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods

  # @return [Boolean]
  def attribute_changed_in_place?(attr_name); end

  def changed_attributes; end
  def changes; end
  def changes_applied; end
  def clear_attribute_changes(attr_names); end
  def clear_changes_information; end
  def previous_changes; end
  def raw_write_attribute(attr_name, *_arg1); end

  # <tt>reload</tt> the record and clears changed attributes.
  def reload(*_arg0); end

  # Attempts to +save+ the record and clears changed attributes if successful.
  def save(*_arg0); end

  # Attempts to <tt>save!</tt> the record and clears changed attributes if successful.
  def save!(*_arg0); end

  private

  def _create_record(*_arg0); end
  def _update_record(*_arg0); end
  def cache_changed_attributes; end

  # @return [Boolean]
  def changes_include?(attr_name); end

  def clear_attribute_change(attr_name); end
  def clear_changed_attributes_cache; end
  def initialize_dup(other); end
  def keys_for_partial_write; end
  def mutation_tracker; end
  def previous_mutation_tracker; end
  def store_original_attributes; end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(value); end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes=(value); end
    def partial_writes?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers?; end
    def partial_writes; end
    def partial_writes?; end
  end
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods < ::Module; end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods

  # Returns the primary key value.
  def id; end

  # Sets the primary key value.
  def id=(value); end

  # Queries the primary key value.
  #
  # @return [Boolean]
  def id?; end

  # Returns the primary key value before type cast.
  def id_before_type_cast; end

  # Returns the primary key previous value.
  def id_was; end

  # Returns this record's primary key value wrapped in an array if one is
  # available.
  def to_key; end

  protected

  # @return [Boolean]
  def attribute_method?(attr_name); end
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  # @return [Boolean]
  def dangerous_attribute_method?(method_name); end

  def define_method_attribute(attr_name); end
  def get_primary_key(base_name); end

  # Defines the primary key field -- can be overridden in subclasses.
  # Overwriting will negate any effect of the +primary_key_prefix_type+
  # setting, though.
  def primary_key; end

  # Sets the name of the primary key column.
  #
  #   class Project < ActiveRecord::Base
  #     self.primary_key = 'sysid'
  #   end
  #
  # You can also define the #primary_key method yourself:
  #
  #   class Project < ActiveRecord::Base
  #     def self.primary_key
  #       'foo_' + super
  #     end
  #   end
  #
  #   Project.primary_key # => "foo_id"
  def primary_key=(value); end

  # Returns a quoted version of the primary key name, used to construct
  # SQL statements.
  def quoted_primary_key; end

  def reset_primary_key; end

  private

  def suppress_composite_primary_key(pk); end
end

ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods::ID_ATTRIBUTE_METHODS = T.let(T.unsafe(nil), Set)

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern

  def query_attribute(attr_name); end

  private

  # Handle *? for method_missing.
  #
  # @return [Boolean]
  def attribute?(attribute_name); end
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods

  def _read_attribute(attr_name); end

  # Returns the value of the attribute identified by <tt>attr_name</tt> after
  # it has been typecast (for example, "2004-12-12" in a date column is cast
  # to a date object, like Date.new(2004, 12, 12)).
  def read_attribute(attr_name, &block); end

  private

  def attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Read::ClassMethods
  protected

  # We want to generate the methods via module_eval rather than
  # define_method, because define_method is slower on dispatch.
  # Evaluating many similar methods may use more memory as the instruction
  # sequences are duplicated and cached (in MRI).  define_method may
  # be slower on dispatch, but if you're careful about the closure
  # created, then define_method will consume much less memory.
  #
  # But sometimes the database might return columns with
  # characters that are not allowed in normal method names (like
  # 'my_column(omg)'. So to work around this we first define with
  # the __temp__ identifier, and then use alias method to rename
  # it to what we want.
  #
  # We are also defining a constant to hold the frozen string of
  # the attribute name. Using a constant means that we do not have
  # to allocate an object on each call to the attribute method.
  # Making it frozen means that it doesn't get duped when used to
  # key the @attributes in read_attribute.
  def define_method_attribute(name); end
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
end

module ActiveRecord::AttributeMethods::Serialization::ClassMethods
  # If you have an attribute that needs to be saved to the database as an
  # object, and retrieved as the same object, then specify the name of that
  # attribute using this method and it will be handled automatically. The
  # serialization is done through YAML. If +class_name+ is specified, the
  # serialized object must be of that class on assignment and retrieval.
  # Otherwise SerializationTypeMismatch will be raised.
  #
  # Empty objects as <tt>{}</tt>, in the case of +Hash+, or <tt>[]</tt>, in the case of
  # +Array+, will always be persisted as null.
  #
  # Keep in mind that database adapters handle certain serialization tasks
  # for you. For instance: +json+ and +jsonb+ types in PostgreSQL will be
  # converted between JSON object/array syntax and Ruby +Hash+ or +Array+
  # objects transparently. There is no need to use #serialize in this
  # case.
  #
  # For more complex cases, such as conversion to or from your application
  # domain objects, consider using the ActiveRecord::Attributes API.
  #
  # ==== Parameters
  #
  # * +attr_name+ - The field name that should be serialized.
  # * +class_name_or_coder+ - Optional, a coder object, which responds to `.load` / `.dump`
  #   or a class name that the object type should be equal to.
  #
  # ==== Example
  #
  #   # Serialize a preferences attribute.
  #   class User < ActiveRecord::Base
  #     serialize :preferences
  #   end
  #
  #   # Serialize preferences using JSON as coder.
  #   class User < ActiveRecord::Base
  #     serialize :preferences, JSON
  #   end
  #
  #   # Serialize preferences as Hash using YAML coder.
  #   class User < ActiveRecord::Base
  #     serialize :preferences, Hash
  #   end
  def serialize(attr_name, class_name_or_coder = T.unsafe(nil)); end
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods

  module GeneratedClassMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  private

  # @return [Boolean]
  def create_time_zone_conversion_attribute?(name, cast_type); end

  def inherited(subclass); end
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
  def cast(value); end
  def deserialize(value); end

  private

  def convert_time_to_time_zone(value); end
  def map_avoiding_infinite_recursion(value); end
  def set_time_zone_without_conversion(value); end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods

  def raw_write_attribute(attr_name, value); end

  # Updates the attribute identified by <tt>attr_name</tt> with the
  # specified +value+. Empty strings for Integer and Float columns are
  # turned into +nil+.
  def write_attribute(attr_name, value); end

  private

  # Handle *= for method_missing.
  def attribute=(attribute_name, value); end

  def write_attribute_with_type_cast(attr_name, value, should_type_cast); end
end

module ActiveRecord::AttributeMethods::Write::ClassMethods
  protected

  def define_method_attribute=(name); end
end

class ActiveRecord::AttributeMutationTracker
  # @return [AttributeMutationTracker] a new instance of AttributeMutationTracker
  def initialize(attributes); end

  # @return [Boolean]
  def changed?(attr_name); end

  # @return [Boolean]
  def changed_in_place?(attr_name); end

  def changed_values; end
  def changes; end
  def forget_change(attr_name); end

  protected

  # Returns the value of attribute attributes.
  def attributes; end

  private

  def attr_names; end
end

class ActiveRecord::AttributeSet
  # @return [AttributeSet] a new instance of AttributeSet
  def initialize(attributes); end

  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def accessed; end
  def deep_dup; end
  def except(*args, &block); end
  def fetch(*args, &block); end

  # This form is significantly faster on JRuby, and this is one of our biggest hotspots.
  # https://github.com/jruby/jruby/pull/2562
  def fetch_value(name); end

  def freeze; end

  # @return [Boolean]
  def key?(name); end

  def keys; end
  def map(&block); end
  def reset(key); end
  def to_h; end
  def to_hash; end
  def values_before_type_cast; end
  def write_cast_value(name, value); end
  def write_from_database(name, value); end
  def write_from_user(name, value); end

  protected

  # Returns the value of attribute attributes.
  def attributes; end

  private

  def initialize_clone(_); end
  def initialize_dup(_); end
  def initialized_attributes; end
end

class ActiveRecord::AttributeSet::Builder
  # @return [Builder] a new instance of Builder
  def initialize(types, default_attributes = T.unsafe(nil)); end

  def build_from_database(values = T.unsafe(nil), additional_types = T.unsafe(nil)); end

  # Returns the value of attribute default_attributes.
  def default_attributes; end

  # Returns the value of attribute types.
  def types; end
end

# See ActiveRecord::Attributes::ClassMethods for documentation
module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Attributes::ClassMethods

  module GeneratedClassMethods
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(value); end
    def attributes_to_define_after_schema_loads?; end
  end

  module GeneratedInstanceMethods; end
end

module ActiveRecord::Attributes::ClassMethods
  # Defines an attribute with a type on this model. It will override the
  # type of existing attributes if needed. This allows control over how
  # values are converted to and from SQL when assigned to a model. It also
  # changes the behavior of values passed to
  # {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]. This will let you use
  # your domain objects across much of Active Record, without having to
  # rely on implementation details or monkey patching.
  #
  # +name+ The name of the methods to define attribute methods for, and the
  # column which this will persist to.
  #
  # +cast_type+ A symbol such as +:string+ or +:integer+, or a type object
  # to be used for this attribute. See the examples below for more
  # information about providing custom type objects.
  #
  # ==== Options
  #
  # The following options are accepted:
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+.
  #
  # +array+ (PostgreSQL only) specifies that the type should be an array (see the
  # examples below).
  #
  # +range+ (PostgreSQL only) specifies that the type should be a range (see the
  # examples below).
  #
  # ==== Examples
  #
  # The type detected by Active Record can be overridden.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.decimal :price_in_cents
  #   end
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '10.1')
  #
  #   # before
  #   store_listing.price_in_cents # => BigDecimal.new(10.1)
  #
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :integer
  #   end
  #
  #   # after
  #   store_listing.price_in_cents # => 10
  #
  # A default can also be provided.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.string :my_string, default: "original default"
  #   end
  #
  #   StoreListing.new.my_string # => "original default"
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :my_string, :string, default: "new default"
  #   end
  #
  #   StoreListing.new.my_string # => "new default"
  #
  #   class Product < ActiveRecord::Base
  #     attribute :my_default_proc, :datetime, default: -> { Time.now }
  #   end
  #
  #   Product.new.my_default_proc # => 2015-05-30 11:04:48 -0600
  #   sleep 1
  #   Product.new.my_default_proc # => 2015-05-30 11:04:49 -0600
  #
  # \Attributes do not need to be backed by a database column.
  #
  #   # app/models/my_model.rb
  #   class MyModel < ActiveRecord::Base
  #     attribute :my_string, :string
  #     attribute :my_int_array, :integer, array: true
  #     attribute :my_float_range, :float, range: true
  #   end
  #
  #   model = MyModel.new(
  #     my_string: "string",
  #     my_int_array: ["1", "2", "3"],
  #     my_float_range: "[1,3.5]",
  #   )
  #   model.attributes
  #   # =>
  #     {
  #       my_string: "string",
  #       my_int_array: [1, 2, 3],
  #       my_float_range: 1.0..3.5
  #     }
  #
  # ==== Creating Custom Types
  #
  # Users may also define their own custom types, as long as they respond
  # to the methods defined on the value type. The method +deserialize+ or
  # +cast+ will be called on your type object, with raw input from the
  # database or from your controllers. See ActiveRecord::Type::Value for the
  # expected API. It is recommended that your type objects inherit from an
  # existing type, or from ActiveRecord::Type::Value
  #
  #   class MoneyType < ActiveRecord::Type::Integer
  #     def cast(value)
  #       if !value.kind_of?(Numeric) && value.include?('$')
  #         price_in_dollars = value.gsub(/\$/, '').to_f
  #         super(price_in_dollars * 100)
  #       else
  #         super
  #       end
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :money
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '$10.00')
  #   store_listing.price_in_cents # => 1000
  #
  # For more details on creating custom types, see the documentation for
  # ActiveRecord::Type::Value. For more details on registering your types
  # to be referenced by a symbol, see ActiveRecord::Type.register. You can
  # also pass a type object directly, in place of a symbol.
  #
  # ==== \Querying
  #
  # When {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where] is called, it will
  # use the type defined by the model class to convert the value to SQL,
  # calling +serialize+ on your type object. For example:
  #
  #   class Money < Struct.new(:amount, :currency)
  #   end
  #
  #   class MoneyType < Type::Value
  #     def initialize(currency_converter:)
  #       @currency_converter = currency_converter
  #     end
  #
  #     # value will be the result of +deserialize+ or
  #     # +cast+. Assumed to be an instance of +Money+ in
  #     # this case.
  #     def serialize(value)
  #       value_in_bitcoins = @currency_converter.convert_to_bitcoins(value)
  #       value_in_bitcoins.amount
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/product.rb
  #   class Product < ActiveRecord::Base
  #     currency_converter = ConversionRatesFromTheInternet.new
  #     attribute :price_in_bitcoins, :money, currency_converter: currency_converter
  #   end
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "USD"))
  #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.02230
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "GBP"))
  #   # => SELECT * FROM products WHERE price_in_bitcoins = 0.03412
  #
  # ==== Dirty Tracking
  #
  # The type of an attribute is given the opportunity to change how dirty
  # tracking is performed. The methods +changed?+ and +changed_in_place?+
  # will be called from ActiveModel::Dirty. See the documentation for those
  # methods in ActiveRecord::Type::Value for more details.
  def attribute(name, cast_type, **options); end

  # This is the low level API which sits beneath +attribute+. It only
  # accepts type objects, and will do its work immediately instead of
  # waiting for the schema to load. Automatic schema detection and
  # ClassMethods#attribute both call this under the hood. While this method
  # is provided so it can be used by plugin authors, application code
  # should probably use ClassMethods#attribute.
  #
  # +name+ The name of the attribute being defined. Expected to be a +String+.
  #
  # +cast_type+ The type object to use for this attribute.
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+. A proc can also be passed, and
  # will be called once each time a new value is needed.
  #
  # +user_provided_default+ Whether the default value should be cast using
  # +cast+ or +deserialize+.
  def define_attribute(name, cast_type, default: T.unsafe(nil), user_provided_default: T.unsafe(nil)); end

  def load_schema!; end

  private

  def define_default_attribute(name, value, type, from_user:); end
end

ActiveRecord::Attributes::ClassMethods::NO_DEFAULT_PROVIDED = T.let(T.unsafe(nil), Object)

# = Active Record Autosave Association
#
# AutosaveAssociation is a module that takes care of automatically saving
# associated records when their parent is saved. In addition to saving, it
# also destroys any associated records that were marked for destruction.
# (See #mark_for_destruction and #marked_for_destruction?).
#
# Saving of the parent, its associations, and the destruction of marked
# associations, all happen inside a transaction. This should never leave the
# database in an inconsistent state.
#
# If validations for any of the associations fail, their error messages will
# be applied to the parent.
#
# Note that it also means that associations marked for destruction won't
# be destroyed directly. They will however still be marked for destruction.
#
# Note that <tt>autosave: false</tt> is not same as not declaring <tt>:autosave</tt>.
# When the <tt>:autosave</tt> option is not present then new association records are
# saved but the updated association records are not saved.
#
# == Validation
#
# Child records are validated unless <tt>:validate</tt> is +false+.
#
# == Callbacks
#
# Association with autosave option defines several callbacks on your
# model (before_save, after_create, after_update). Please note that
# callbacks are executed in the order they were defined in
# model. You should avoid modifying the association content, before
# autosave callbacks are executed. Placing your callbacks after
# associations is usually a good practice.
#
# === One-to-one Example
#
#   class Post < ActiveRecord::Base
#     has_one :author, autosave: true
#   end
#
# Saving changes to the parent and its associated model can now be performed
# automatically _and_ atomically:
#
#   post = Post.find(1)
#   post.title       # => "The current global position of migrating ducks"
#   post.author.name # => "alloy"
#
#   post.title = "On the migration of ducks"
#   post.author.name = "Eloy Duran"
#
#   post.save
#   post.reload
#   post.title       # => "On the migration of ducks"
#   post.author.name # => "Eloy Duran"
#
# Destroying an associated model, as part of the parent's save action, is as
# simple as marking it for destruction:
#
#   post.author.mark_for_destruction
#   post.author.marked_for_destruction? # => true
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.author.id
#   Author.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.author # => nil
#
# Now it _is_ removed from the database:
#
#   Author.find_by(id: id).nil? # => true
#
# === One-to-many Example
#
# When <tt>:autosave</tt> is not declared new children are saved when their parent is saved:
#
#   class Post < ActiveRecord::Base
#     has_many :comments # :autosave option is not declared
#   end
#
#   post = Post.new(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   post.comments.create(body: 'hello world')
#   post.save # => saves both post and comment
#
# When <tt>:autosave</tt> is true all children are saved, no matter whether they
# are new records or not:
#
#   class Post < ActiveRecord::Base
#     has_many :comments, autosave: true
#   end
#
#   post = Post.create(title: 'ruby rocks')
#   post.comments.create(body: 'hello world')
#   post.comments[0].body = 'hi everyone'
#   post.comments.build(body: "good morning.")
#   post.title += "!"
#   post.save # => saves both post and comments.
#
# Destroying one of the associated models as part of the parent's save action
# is as simple as marking it for destruction:
#
#   post.comments # => [#<Comment id: 1, ...>, #<Comment id: 2, ...]>
#   post.comments[1].mark_for_destruction
#   post.comments[1].marked_for_destruction? # => true
#   post.comments.length # => 2
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.comments.last.id
#   Comment.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.comments.length # => 1
#
# Now it _is_ removed from the database:
#
#   Comment.find_by(id: id).nil? # => true
module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AutosaveAssociation::ClassMethods

  # Returns whether or not this record has been changed in any way (including whether
  # any of its nested autosave associations are likewise changed)
  #
  # @return [Boolean]
  def changed_for_autosave?; end

  # Returns the association for the parent being destroyed.
  #
  # Used to avoid updating the counter cache unnecessarily.
  def destroyed_by_association; end

  # Records the association that is being destroyed and destroying this
  # record in the process.
  def destroyed_by_association=(reflection); end

  # Marks this record to be destroyed as part of the parent's save transaction.
  # This does _not_ actually destroy the record instantly, rather child record will be destroyed
  # when <tt>parent.save</tt> is called.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  def mark_for_destruction; end

  # Returns whether or not this record will be destroyed as part of the parent's save transaction.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  #
  # @return [Boolean]
  def marked_for_destruction?; end

  # Reloads the attributes of the object as usual and clears <tt>marked_for_destruction</tt> flag.
  def reload(options = T.unsafe(nil)); end

  private

  def _ensure_no_duplicate_errors; end

  # Returns the record for an association collection that should be validated
  # or saved. If +autosave+ is +false+ only new records will be returned,
  # unless the parent is/was a new record itself.
  def associated_records_to_validate_or_save(association, new_record, autosave); end

  # Returns whether or not the association is valid and applies any errors to
  # the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt>
  # enabled records if they're marked_for_destruction? or destroyed.
  #
  # @return [Boolean]
  def association_valid?(reflection, record, index = T.unsafe(nil)); end

  # Is used as a before_save callback to check while saving a collection
  # association whether or not the parent was a new record before saving.
  def before_save_collection_association; end

  # go through nested autosave associations that are loaded in memory (without loading
  # any new ones), and return true if is changed for autosave
  #
  # @return [Boolean]
  def nested_records_changed_for_autosave?; end

  def normalize_reflection_attribute(indexed_attribute, reflection, index, attribute); end

  # If the record is new or it has changed, returns true.
  #
  # @return [Boolean]
  def record_changed?(reflection, record, key); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled.
  #
  # In addition, it will destroy the association if it was marked for destruction.
  def save_belongs_to_association(reflection); end

  # Saves any new associated records, or all loaded autosave associations if
  # <tt>:autosave</tt> is enabled on the association.
  #
  # In addition, it destroys all children that were marked for destruction
  # with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  def save_collection_association(reflection); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled
  # on the association.
  #
  # In addition, it will destroy the association if it was marked for
  # destruction with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  def save_has_one_association(reflection); end

  # Validate the associated records if <tt>:validate</tt> or
  # <tt>:autosave</tt> is turned on for the association specified by
  # +reflection+.
  def validate_collection_association(reflection); end

  # Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is
  # turned on for the association.
  def validate_single_association(reflection); end
end

module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
  class << self
    def build(model, reflection); end
    def valid_options; end
  end
end

module ActiveRecord::AutosaveAssociation::ClassMethods
  private

  # Adds validation and save callbacks for the association as specified by
  # the +reflection+.
  #
  # For performance reasons, we don't check whether to validate at runtime.
  # However the validation and callback methods are lazy and those methods
  # get created when they are invoked for the very first time. However,
  # this can change, for instance, when using nested attributes, which is
  # called _after_ the association has been defined. Since we don't want
  # the callbacks to get defined multiple times, there are guards that
  # check if the save or validation methods have already been defined
  # before actually defining them.
  def add_autosave_association_callbacks(reflection); end

  def define_autosave_validation_callbacks(reflection); end
  def define_non_cyclic_method(name, &block); end
end

# = Active Record
#
# Active Record objects don't specify their attributes directly, but rather infer them from
# the table definition with which they're linked. Adding, removing, and changing attributes
# and their type is done directly in the database. Any change is instantly reflected in the
# Active Record objects. The mapping that binds a given Active Record class to a certain
# database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
#
# See the mapping rules in table_name and the full example in link:files/activerecord/README_rdoc.html for more insight.
#
# == Creation
#
# Active Records accept constructor parameters either in a hash or as a block. The hash
# method is especially useful when you're receiving the data from somewhere else, like an
# HTTP request. It works like this:
#
#   user = User.new(name: "David", occupation: "Code Artist")
#   user.name # => "David"
#
# You can also use block initialization:
#
#   user = User.new do |u|
#     u.name = "David"
#     u.occupation = "Code Artist"
#   end
#
# And of course you can just create a bare object and specify the attributes after the fact:
#
#   user = User.new
#   user.name = "David"
#   user.occupation = "Code Artist"
#
# == Conditions
#
# Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
# The array form is to be used when the condition input is tainted and requires sanitization. The string form can
# be used for statements that don't involve tainted data. The hash form works much like the array form, except
# only equality and range is possible. Examples:
#
#   class User < ActiveRecord::Base
#     def self.authenticate_unsafely(user_name, password)
#       where("user_name = '#{user_name}' AND password = '#{password}'").first
#     end
#
#     def self.authenticate_safely(user_name, password)
#       where("user_name = ? AND password = ?", user_name, password).first
#     end
#
#     def self.authenticate_safely_simply(user_name, password)
#       where(user_name: user_name, password: password).first
#     end
#   end
#
# The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query
# and is thus susceptible to SQL-injection attacks if the <tt>user_name</tt> and +password+
# parameters come directly from an HTTP request. The <tt>authenticate_safely</tt> and
# <tt>authenticate_safely_simply</tt> both will sanitize the <tt>user_name</tt> and +password+
# before inserting them in the query, which will ensure that an attacker can't escape the
# query and fake the login (or worse).
#
# When using multiple parameters in the conditions, it can easily become hard to read exactly
# what the fourth or fifth question mark is supposed to represent. In those cases, you can
# resort to named bind variables instead. That's done by replacing the question marks with
# symbols and supplying a hash with values for the matching symbol keys:
#
#   Company.where(
#     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",
#     { id: 3, name: "37signals", division: "First", accounting_date: '2005-01-01' }
#   ).first
#
# Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
# operator. For instance:
#
#   Student.where(first_name: "Harvey", status: 1)
#   Student.where(params[:student])
#
# A range may be used in the hash to use the SQL BETWEEN operator:
#
#   Student.where(grade: 9..12)
#
# An array may be used in the hash to use the SQL IN operator:
#
#   Student.where(grade: [9,11,12])
#
# When joining tables, nested hashes or keys written in the form 'table_name.column_name'
# can be used to qualify the table name of a particular condition. For instance:
#
#   Student.joins(:schools).where(schools: { category: 'public' })
#   Student.joins(:schools).where('schools.category' => 'public' )
#
# == Overwriting default accessors
#
# All column values are automatically available through basic accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling
# +super+ to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses an integer of seconds to hold the length of the song
#
#     def length=(minutes)
#       super(minutes.to_i * 60)
#     end
#
#     def length
#       super / 60
#     end
#   end
#
# == Attribute query methods
#
# In addition to the basic accessors, query methods are also automatically available on the Active Record object.
# Query methods allow you to test whether an attribute value is present.
# Additionally, when dealing with numeric values, a query method will return false if the value is zero.
#
# For example, an Active Record User with the <tt>name</tt> attribute has a <tt>name?</tt> method that you can call
# to determine whether the user has a name:
#
#   user = User.new(name: "David")
#   user.name? # => true
#
#   anonymous = User.new(name: "")
#   anonymous.name? # => false
#
# == Accessing attributes before they have been typecasted
#
# Sometimes you want to be able to read the raw attribute data without having the column-determined
# typecast run its course first. That can be done by using the <tt><attribute>_before_type_cast</tt>
# accessors that all attributes have. For example, if your Account model has a <tt>balance</tt> attribute,
# you can call <tt>account.balance_before_type_cast</tt> or <tt>account.id_before_type_cast</tt>.
#
# This is especially useful in validation situations where the user might supply a string for an
# integer field and you want to display the original string back in an error message. Accessing the
# attribute normally would typecast the string to 0, which isn't what you want.
#
# == Dynamic attribute-based finders
#
# Dynamic attribute-based finders are a mildly deprecated way of getting (and/or creating) objects
# by simple queries without turning to SQL. They work by appending the name of an attribute
# to <tt>find_by_</tt> like <tt>Person.find_by_user_name</tt>.
# Instead of writing <tt>Person.find_by(user_name: user_name)</tt>, you can use
# <tt>Person.find_by_user_name(user_name)</tt>.
#
# It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an
# ActiveRecord::RecordNotFound error if they do not return any records,
# like <tt>Person.find_by_last_name!</tt>.
#
# It's also possible to use multiple attributes in the same <tt>find_by_</tt> by separating them with
# "_and_".
#
#  Person.find_by(user_name: user_name, password: password)
#  Person.find_by_user_name_and_password(user_name, password) # with dynamic finder
#
# It's even possible to call these dynamic finder methods on relations and named scopes.
#
#   Payment.order("created_on").find_by_amount(50)
#
# == Saving arrays, hashes, and other non-mappable objects in text columns
#
# Active Record can serialize any object in text columns using YAML. To do so, you must
# specify this with a call to the class method
# {serialize}[rdoc-ref:AttributeMethods::Serialization::ClassMethods#serialize].
# This makes it possible to store arrays, hashes, and other non-mappable objects without doing
# any additional work.
#
#   class User < ActiveRecord::Base
#     serialize :preferences
#   end
#
#   user = User.create(preferences: { "background" => "black", "display" => large })
#   User.find(user.id).preferences # => { "background" => "black", "display" => large }
#
# You can also specify a class option as the second parameter that'll raise an exception
# if a serialized object is retrieved as a descendant of a class not in the hierarchy.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, Hash
#   end
#
#   user = User.create(preferences: %w( one two three ))
#   User.find(user.id).preferences    # raises SerializationTypeMismatch
#
# When you specify a class option, the default value for that attribute will be a new
# instance of that class.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, OpenStruct
#   end
#
#   user = User.new
#   user.preferences.theme_color = "red"
#
#
# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a
# column that is named "type" by default. See ActiveRecord::Inheritance for
# more details.
#
# == Connection to multiple databases in different models
#
# Connections are usually created through
# {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] and retrieved
# by ActiveRecord::Base.connection. All classes inheriting from ActiveRecord::Base will use this
# connection. But you can also set a class-specific connection. For example, if Course is an
# ActiveRecord::Base, but resides in a different database, you can just say <tt>Course.establish_connection</tt>
# and Course and all of its subclasses will use this connection instead.
#
# This feature is implemented by keeping a connection pool in ActiveRecord::Base that is
# a hash indexed by the class. If a connection is requested, the
# {ActiveRecord::Base.retrieve_connection}[rdoc-ref:ConnectionHandling#retrieve_connection] method
# will go up the class-hierarchy until a connection is found in the connection pool.
#
# == Exceptions
#
# * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
# * AdapterNotSpecified - The configuration hash used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   didn't include an <tt>:adapter</tt> key.
# * AdapterNotFound - The <tt>:adapter</tt> key used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   specified a non-existent adapter
#   (or a bad spelling of an existing one).
# * AssociationTypeMismatch - The object assigned to the association wasn't of the type
#   specified in the association definition.
# * AttributeAssignmentError - An error occurred while doing a mass assignment through the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   You can inspect the +attribute+ property of the exception object to determine which attribute
#   triggered the error.
# * ConnectionNotEstablished - No connection has been established.
#   Use {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] before querying.
# * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   The +errors+ property of this exception contains an array of
#   AttributeAssignmentError
#   objects that should be inspected to determine which attributes triggered the errors.
# * RecordInvalid - raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
#   {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
#   when the record is invalid.
# * RecordNotFound - No record responded to the {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] method.
#   Either the row with the given ID doesn't exist or the row didn't meet the additional restrictions.
#   Some {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] calls do not raise this exception to signal
#   nothing was found, please check its documentation for further details.
# * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
# * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
#
# *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
# So it's possible to assign a logger to the class through <tt>Base.logger=</tt> which will then be used by all
# instances in the current object space.
class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::Persistence
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Inheritance
  include ::ActiveRecord::Scoping
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named
  include ::ActiveRecord::Sanitization
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::Locking::Pessimistic
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization
  include ::ActiveRecord::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveRecord::Associations
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::NestedAttributes
  include ::ActiveRecord::Aggregations
  include ::ActiveRecord::Transactions
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::Suppressor
  extend ::ActiveModel::Naming
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::Translation
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::CollectionCacheKey
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::Persistence::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Inheritance::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Scoping::Default::ClassMethods
  extend ::ActiveRecord::Scoping::Named::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::AttributeDecorators::ClassMethods
  extend ::ActiveRecord::Locking::Optimistic::ClassMethods
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
  extend ::ActiveRecord::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveRecord::Associations::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::NestedAttributes::ClassMethods
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Transactions::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods

  def _before_commit_callbacks; end
  def _before_commit_callbacks?; end
  def _before_commit_without_transaction_enrollment_callbacks; end
  def _before_commit_without_transaction_enrollment_callbacks?; end
  def _commit_callbacks; end
  def _commit_callbacks?; end
  def _commit_without_transaction_enrollment_callbacks; end
  def _commit_without_transaction_enrollment_callbacks?; end
  def _create_callbacks; end
  def _create_callbacks?; end
  def _destroy_callbacks; end
  def _destroy_callbacks?; end
  def _find_callbacks; end
  def _find_callbacks?; end
  def _initialize_callbacks; end
  def _initialize_callbacks?; end
  def _reflections; end
  def _reflections?; end
  def _rollback_callbacks; end
  def _rollback_callbacks?; end
  def _rollback_without_transaction_enrollment_callbacks; end
  def _rollback_without_transaction_enrollment_callbacks?; end
  def _run_before_commit_callbacks(&block); end
  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end
  def _run_commit_callbacks(&block); end
  def _run_commit_without_transaction_enrollment_callbacks(&block); end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_find_callbacks(&block); end
  def _run_initialize_callbacks(&block); end
  def _run_rollback_callbacks(&block); end
  def _run_rollback_without_transaction_enrollment_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_touch_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _save_callbacks?; end
  def _touch_callbacks; end
  def _touch_callbacks?; end
  def _update_callbacks; end
  def _update_callbacks?; end
  def _validate_callbacks; end
  def _validate_callbacks?; end
  def _validation_callbacks; end
  def _validation_callbacks?; end
  def _validators; end
  def _validators?; end
  def aggregate_reflections; end
  def aggregate_reflections?; end
  def attribute_aliases; end
  def attribute_aliases?; end
  def attribute_method_matchers; end
  def attribute_method_matchers?; end
  def cache_timestamp_format; end
  def cache_timestamp_format?; end
  def column_for_attribute(*args, &block); end
  def default_connection_handler; end
  def default_connection_handler?; end
  def default_scope_override; end
  def default_scopes; end
  def default_timezone; end
  def defined_enums; end
  def defined_enums?; end
  def dump_schema_after_migration; end
  def dump_schemas; end
  def error_on_ignored_order_or_limit; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def index_nested_attribute_errors; end
  def lock_optimistically; end
  def lock_optimistically?; end
  def logger; end
  def model_name(*args, &block); end
  def nested_attributes_options; end
  def nested_attributes_options?; end
  def partial_writes; end
  def partial_writes?; end
  def pluralize_table_names; end
  def pluralize_table_names?; end
  def primary_key_prefix_type; end
  def record_timestamps; end
  def record_timestamps=(_arg0); end
  def record_timestamps?; end
  def schema_format; end
  def skip_time_zone_conversion_for_attributes; end
  def skip_time_zone_conversion_for_attributes?; end
  def store_full_sti_class; end
  def store_full_sti_class?; end
  def table_name_prefix; end
  def table_name_prefix?; end
  def table_name_suffix; end
  def table_name_suffix?; end
  def time_zone_aware_attributes; end
  def time_zone_aware_types; end
  def time_zone_aware_types?; end
  def timestamped_migrations; end
  def type_for_attribute(*args, &block); end
  def validation_context; end
  def warn_on_records_fetched_greater_than; end

  private

  def validation_context=(_arg0); end

  class << self
    def _attr_readonly; end
    def _attr_readonly=(val); end
    def _attr_readonly?; end
    def _before_commit_callbacks; end
    def _before_commit_callbacks=(val); end
    def _before_commit_callbacks?; end
    def _before_commit_without_transaction_enrollment_callbacks; end
    def _before_commit_without_transaction_enrollment_callbacks=(val); end
    def _before_commit_without_transaction_enrollment_callbacks?; end
    def _commit_callbacks; end
    def _commit_callbacks=(val); end
    def _commit_callbacks?; end
    def _commit_without_transaction_enrollment_callbacks; end
    def _commit_without_transaction_enrollment_callbacks=(val); end
    def _commit_without_transaction_enrollment_callbacks?; end
    def _create_callbacks; end
    def _create_callbacks=(val); end
    def _create_callbacks?; end
    def _destroy_callbacks; end
    def _destroy_callbacks=(val); end
    def _destroy_callbacks?; end
    def _find_callbacks; end
    def _find_callbacks=(val); end
    def _find_callbacks?; end
    def _initialize_callbacks; end
    def _initialize_callbacks=(val); end
    def _initialize_callbacks?; end
    def _reflections; end
    def _reflections=(val); end
    def _reflections?; end
    def _rollback_callbacks; end
    def _rollback_callbacks=(val); end
    def _rollback_callbacks?; end
    def _rollback_without_transaction_enrollment_callbacks; end
    def _rollback_without_transaction_enrollment_callbacks=(val); end
    def _rollback_without_transaction_enrollment_callbacks?; end
    def _save_callbacks; end
    def _save_callbacks=(val); end
    def _save_callbacks?; end
    def _touch_callbacks; end
    def _touch_callbacks=(val); end
    def _touch_callbacks?; end
    def _update_callbacks; end
    def _update_callbacks=(val); end
    def _update_callbacks?; end
    def _validate_callbacks; end
    def _validate_callbacks=(val); end
    def _validate_callbacks?; end
    def _validation_callbacks; end
    def _validation_callbacks=(val); end
    def _validation_callbacks?; end
    def _validators; end
    def _validators=(val); end
    def _validators?; end
    def after_create(*args, &block); end
    def after_destroy(*args, &block); end
    def after_find(*args, &block); end
    def after_initialize(*args, &block); end
    def after_save(*args, &block); end
    def after_touch(*args, &block); end
    def after_update(*args, &block); end
    def aggregate_reflections; end
    def aggregate_reflections=(val); end
    def aggregate_reflections?; end
    def around_create(*args, &block); end
    def around_destroy(*args, &block); end
    def around_save(*args, &block); end
    def around_update(*args, &block); end
    def attribute_aliases; end
    def attribute_aliases=(val); end
    def attribute_aliases?; end
    def attribute_method_matchers; end
    def attribute_method_matchers=(val); end
    def attribute_method_matchers?; end
    def attribute_type_decorations; end
    def attribute_type_decorations=(val); end
    def attribute_type_decorations?; end
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(val); end
    def attributes_to_define_after_schema_loads?; end
    def before_create(*args, &block); end
    def before_destroy(*args, &block); end
    def before_save(*args, &block); end
    def before_update(*args, &block); end
    def belongs_to_required_by_default; end
    def belongs_to_required_by_default=(obj); end
    def cache_timestamp_format; end
    def cache_timestamp_format=(val); end
    def cache_timestamp_format?; end
    def configurations; end
    def configurations=(config); end
    def connection_handler; end
    def connection_handler=(handler); end
    def default_connection_handler; end
    def default_connection_handler=(val); end
    def default_connection_handler?; end
    def default_scope_override; end
    def default_scope_override=(val); end
    def default_scopes; end
    def default_scopes=(val); end
    def default_timezone; end
    def default_timezone=(obj); end
    def defined_enums; end
    def defined_enums=(val); end
    def defined_enums?; end
    def dump_schema_after_migration; end
    def dump_schema_after_migration=(obj); end
    def dump_schemas; end
    def dump_schemas=(obj); end
    def error_on_ignored_order_or_limit; end
    def error_on_ignored_order_or_limit=(obj); end
    def include_root_in_json; end
    def include_root_in_json=(val); end
    def include_root_in_json?; end
    def index_nested_attribute_errors; end
    def index_nested_attribute_errors=(obj); end
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(val); end
    def internal_metadata_table_name?; end
    def local_stored_attributes; end
    def local_stored_attributes=(_arg0); end
    def lock_optimistically; end
    def lock_optimistically=(val); end
    def lock_optimistically?; end
    def logger; end
    def logger=(obj); end
    def maintain_test_schema; end
    def maintain_test_schema=(obj); end
    def nested_attributes_options; end
    def nested_attributes_options=(val); end
    def nested_attributes_options?; end
    def partial_writes; end
    def partial_writes=(val); end
    def partial_writes?; end
    def pluralize_table_names; end
    def pluralize_table_names=(val); end
    def pluralize_table_names?; end
    def primary_key_prefix_type; end
    def primary_key_prefix_type=(obj); end
    def protected_environments; end
    def protected_environments=(val); end
    def protected_environments?; end
    def record_timestamps; end
    def record_timestamps=(val); end
    def record_timestamps?; end
    def schema_format; end
    def schema_format=(obj); end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(val); end
    def schema_migrations_table_name?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(val); end
    def skip_time_zone_conversion_for_attributes?; end
    def store_full_sti_class; end
    def store_full_sti_class=(val); end
    def store_full_sti_class?; end
    def table_name_prefix; end
    def table_name_prefix=(val); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(val); end
    def table_name_suffix?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes=(obj); end
    def time_zone_aware_types; end
    def time_zone_aware_types=(val); end
    def time_zone_aware_types?; end
    def timestamped_migrations; end
    def timestamped_migrations=(obj); end
    def warn_on_records_fetched_greater_than; end
    def warn_on_records_fetched_greater_than=(obj); end
  end
end

module ActiveRecord::Base::GeneratedAssociationMethods; end

module ActiveRecord::Batches
  # Looping through a collection of records from the database
  # (using the Scoping::Named::ClassMethods.all method, for example)
  # is very inefficient since it will try to instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work
  # with the records in batches, thereby greatly reducing memory consumption.
  #
  # The #find_each method uses #find_in_batches with a batch size of 1000 (or as
  # specified by the +:batch_size+ option).
  #
  #   Person.find_each do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").find_each do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #find_each, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_each.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   the order and limit have to be ignored due to batching.
  #
  # This is especially useful if you want multiple workers dealing with
  # the same processing queue. You can make worker 1 handle all the records
  # between id 0 and 10,000 and worker 2 handle from 10,000 and beyond
  # (by setting the +:start+ and +:finish+ option on each worker).
  #
  #   # Let's process for a batch of 2000 records, skipping the first 2000 rows
  #   Person.find_each(start: 2000, batch_size: 2000) do |person|
  #     person.party_all_night!
  #   end
  #
  # NOTE: It's not possible to set the order. That is automatically set to
  # ascending on the primary key ("id ASC") to make the batch ordering
  # work. This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: You can't set the limit either, that's used to control
  # the batch sizes.
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  # Yields each batch of records that was found by the find options as
  # an array.
  #
  #   Person.where("age > 21").find_in_batches do |group|
  #     sleep(50) # Make sure it doesn't get too crowded in there!
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # If you do not provide a block to #find_in_batches, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_in_batches.with_index do |group, batch|
  #     puts "Processing group ##{batch}"
  #     group.each(&:recover_from_last_night!)
  #   end
  #
  # To be yielded each record one by one, use #find_each instead.
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   the order and limit have to be ignored due to batching.
  #
  # This is especially useful if you want multiple workers dealing with
  # the same processing queue. You can make worker 1 handle all the records
  # between id 0 and 10,000 and worker 2 handle from 10,000 and beyond
  # (by setting the +:start+ and +:finish+ option on each worker).
  #
  #   # Let's process the next 2000 records
  #   Person.find_in_batches(start: 2000, batch_size: 2000) do |group|
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # NOTE: It's not possible to set the order. That is automatically set to
  # ascending on the primary key ("id ASC") to make the batch ordering
  # work. This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: You can't set the limit either, that's used to control
  # the batch sizes.
  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  # Yields ActiveRecord::Relation objects to work with a batch of records.
  #
  #   Person.where("age > 21").in_batches do |relation|
  #     relation.delete_all
  #     sleep(10) # Throttle the delete queries
  #   end
  #
  # If you do not provide a block to #in_batches, it will return a
  # BatchEnumerator which is enumerable.
  #
  #   Person.in_batches.each_with_index do |relation, batch_index|
  #     puts "Processing relation ##{batch_index}"
  #     relation.delete_all
  #   end
  #
  # Examples of calling methods on the returned BatchEnumerator object:
  #
  #   Person.in_batches.delete_all
  #   Person.in_batches.update_all(awesome: true)
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # ==== Options
  # * <tt>:of</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:load</tt> - Specifies if the relation should be loaded. Defaults to false.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   the order and limit have to be ignored due to batching.
  #
  # This is especially useful if you want to work with the
  # ActiveRecord::Relation object instead of the array of records, or if
  # you want multiple workers dealing with the same processing queue. You can
  # make worker 1 handle all the records between id 0 and 10,000 and worker 2
  # handle from 10,000 and beyond (by setting the +:start+ and +:finish+
  # option on each worker).
  #
  #   # Let's process the next 2000 records
  #   Person.in_batches(of: 2000, start: 2000).update_all(awesome: true)
  #
  # An example of calling where query method on the relation:
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all('age = age + 1')
  #     relation.where('age > 21').update_all(should_party: true)
  #     relation.where('age <= 21').delete_all
  #   end
  #
  # NOTE: If you are going to iterate through each record, you should call
  # #each_record on the yielded BatchEnumerator:
  #
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # NOTE: It's not possible to set the order. That is automatically set to
  # ascending on the primary key ("id ASC") to make the batch ordering
  # consistent. Therefore the primary key must be orderable, e.g. an integer
  # or a string.
  #
  # NOTE: You can't set the limit either, that's used to control the batch
  # sizes.
  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  private

  def act_on_order_or_limit_ignored(error_on_ignore); end
  def apply_limits(relation, start, finish); end
  def batch_order; end
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable

  # @return [BatchEnumerator] a new instance of BatchEnumerator
  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def delete_all(*args, &block); end
  def destroy_all(*args, &block); end

  # Yields an ActiveRecord::Relation object for each batch of records.
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all(awesome: true)
  #   end
  def each; end

  # Looping through a collection of records from the database (using the
  # +all+ method, for example) is very inefficient since it will try to
  # instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work with the
  # records in batches, thereby greatly reducing memory consumption.
  #
  #   Person.in_batches.each_record do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").in_batches(of: 10).each_record do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #each_record, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.in_batches.each_record.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  def each_record; end

  def update_all(*args, &block); end
end

ActiveRecord::Batches::ORDER_OR_LIMIT_IGNORED_MESSAGE = T.let(T.unsafe(nil), String)

module ActiveRecord::Calculations
  # Calculates the average value on a given column. Returns +nil+ if there's
  # no row. See #calculate for examples with options.
  #
  #   Person.average(:age) # => 35.8
  def average(column_name); end

  # This calculates aggregate values in the given column. Methods for #count, #sum, #average,
  # #minimum, and #maximum have been added as shortcuts.
  #
  #   Person.calculate(:count, :all) # The same as Person.count
  #   Person.average(:age) # SELECT AVG(age) FROM people...
  #
  #   # Selects the minimum age for any family without any minors
  #   Person.group(:last_name).having("min(age) > 17").minimum(:age)
  #
  #   Person.sum("2 * age")
  #
  # There are two basic forms of output:
  #
  # * Single aggregate value: The single value is type cast to Integer for COUNT, Float
  #   for AVG, and the given column's type for everything else.
  #
  # * Grouped values: This returns an ordered hash of the values and groups them. It
  #   takes either a column name, or the name of a belongs_to association.
  #
  #      values = Person.group('last_name').maximum(:age)
  #      puts values["Drake"]
  #      # => 43
  #
  #      drake  = Family.find_by(last_name: 'Drake')
  #      values = Person.group(:family).maximum(:age) # Person belongs_to :family
  #      puts values[drake]
  #      # => 43
  #
  #      values.each do |family, max_age|
  #        ...
  #      end
  def calculate(operation, column_name); end

  # Count the records.
  #
  #   Person.count
  #   # => the total count of all people
  #
  #   Person.count(:age)
  #   # => returns the total count of all people whose age is present in database
  #
  #   Person.count(:all)
  #   # => performs a COUNT(*) (:all is an alias for '*')
  #
  #   Person.distinct.count(:age)
  #   # => counts the number of different age values
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group],
  # it returns a Hash whose keys represent the aggregated column,
  # and the values are the respective amounts:
  #
  #   Person.group(:city).count
  #   # => { 'Rome' => 5, 'Paris' => 3 }
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group] for multiple columns, it returns a Hash whose
  # keys are an array containing the individual values of each column and the value
  # of each key would be the #count.
  #
  #   Article.group(:status, :category).count
  #   # =>  {["draft", "business"]=>10, ["draft", "technology"]=>4,
  #          ["published", "business"]=>0, ["published", "technology"]=>2}
  #
  # If #count is used with {Relation#select}[rdoc-ref:QueryMethods#select], it will count the selected columns:
  #
  #   Person.select(:age).count
  #   # => counts the number of different age values
  #
  # Note: not all valid {Relation#select}[rdoc-ref:QueryMethods#select] expressions are valid #count expressions. The specifics differ
  # between databases. In invalid cases, an error from the database is thrown.
  def count(column_name = T.unsafe(nil)); end

  # Pluck all the ID's for the relation using the table's primary key
  #
  #   Person.ids # SELECT people.id FROM people
  #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.person_id = people.id
  def ids; end

  # Calculates the maximum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.maximum(:age) # => 93
  def maximum(column_name); end

  # Calculates the minimum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.minimum(:age) # => 7
  def minimum(column_name); end

  # Use #pluck as a shortcut to select one or more attributes without
  # loading a bunch of records just to grab the attributes you want.
  #
  #   Person.pluck(:name)
  #
  # instead of
  #
  #   Person.all.map(&:name)
  #
  # Pluck returns an Array of attribute values type-casted to match
  # the plucked column names, if they can be deduced. Plucking an SQL fragment
  # returns String values by default.
  #
  #   Person.pluck(:name)
  #   # SELECT people.name FROM people
  #   # => ['David', 'Jeremy', 'Jose']
  #
  #   Person.pluck(:id, :name)
  #   # SELECT people.id, people.name FROM people
  #   # => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
  #
  #   Person.distinct.pluck(:role)
  #   # SELECT DISTINCT role FROM people
  #   # => ['admin', 'member', 'guest']
  #
  #   Person.where(age: 21).limit(5).pluck(:id)
  #   # SELECT people.id FROM people WHERE people.age = 21 LIMIT 5
  #   # => [2, 3]
  #
  #   Person.pluck('DATEDIFF(updated_at, created_at)')
  #   # SELECT DATEDIFF(updated_at, created_at) FROM people
  #   # => ['0', '27761', '173']
  #
  # See also #ids.
  def pluck(*column_names); end

  # Calculates the sum of values on a given column. The value is returned
  # with the same data type of the column, +0+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.sum(:age) # => 4562
  def sum(column_name = T.unsafe(nil), &block); end

  private

  def aggregate_column(column_name); end
  def build_count_subquery(relation, column_name, distinct); end

  # Converts the given keys to the value that the database adapter returns as
  # a usable column name:
  #
  #   column_alias_for("users.id")                 # => "users_id"
  #   column_alias_for("sum(id)")                  # => "sum_id"
  #   column_alias_for("count(distinct users.id)") # => "count_distinct_users_id"
  #   column_alias_for("count(*)")                 # => "count_all"
  def column_alias_for(keys); end

  def execute_grouped_calculation(operation, column_name, distinct); end
  def execute_simple_calculation(operation, column_name, distinct); end

  # @return [Boolean]
  def has_include?(column_name); end

  def operation_over_aggregate_column(column, operation, distinct); end
  def perform_calculation(operation, column_name); end
  def select_for_count; end
  def type_cast_calculated_value(value, type, operation = T.unsafe(nil)); end
  def type_for(field, &block); end
end

# = Active Record \Callbacks
#
# \Callbacks are hooks into the life cycle of an Active Record object that allow you to trigger logic
# before or after an alteration of the object state. This can be used to make sure that associated and
# dependent objects are deleted when {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] is called (by overwriting +before_destroy+) or
# to massage attributes before they're validated (by overwriting +before_validation+).
# As an example of the callbacks initiated, consider the {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] call for a new record:
#
# * (-) <tt>save</tt>
# * (-) <tt>valid</tt>
# * (1) <tt>before_validation</tt>
# * (-) <tt>validate</tt>
# * (2) <tt>after_validation</tt>
# * (3) <tt>before_save</tt>
# * (4) <tt>before_create</tt>
# * (-) <tt>create</tt>
# * (5) <tt>after_create</tt>
# * (6) <tt>after_save</tt>
# * (7) <tt>after_commit</tt>
#
# Also, an <tt>after_rollback</tt> callback can be configured to be triggered whenever a rollback is issued.
# Check out ActiveRecord::Transactions for more details about <tt>after_commit</tt> and
# <tt>after_rollback</tt>.
#
# Additionally, an <tt>after_touch</tt> callback is triggered whenever an
# object is touched.
#
# Lastly an <tt>after_find</tt> and <tt>after_initialize</tt> callback is triggered for each object that
# is found and instantiated by a finder, with <tt>after_initialize</tt> being triggered after new objects
# are instantiated as well.
#
# There are nineteen callbacks in total, which give you immense power to react and prepare for each state in the
# Active Record life cycle. The sequence for calling {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] for an existing record is similar,
# except that each <tt>_create</tt> callback is replaced by the corresponding <tt>_update</tt> callback.
#
# Examples:
#   class CreditCard < ActiveRecord::Base
#     # Strip everything but digits, so the user can specify "555 234 34" or
#     # "5552-3434" and both will mean "55523434"
#     before_validation(on: :create) do
#       self.number = number.gsub(/[^0-9]/, "") if attribute_present?("number")
#     end
#   end
#
#   class Subscription < ActiveRecord::Base
#     before_create :record_signup
#
#     private
#       def record_signup
#         self.signed_up_on = Date.today
#       end
#   end
#
#   class Firm < ActiveRecord::Base
#     # Disables access to the system, for associated clients and people when the firm is destroyed
#     before_destroy { |record| Person.where(firm_id: record.id).update_all(access: 'disabled')   }
#     before_destroy { |record| Client.where(client_of: record.id).update_all(access: 'disabled') }
#   end
#
# == Inheritable callback queues
#
# Besides the overwritable callback methods, it's also possible to register callbacks through the
# use of the callback macros. Their main advantage is that the macros add behavior into a callback
# queue that is kept intact down through an inheritance hierarchy.
#
#   class Topic < ActiveRecord::Base
#     before_destroy :destroy_author
#   end
#
#   class Reply < Topic
#     before_destroy :destroy_readers
#   end
#
# Now, when <tt>Topic#destroy</tt> is run only +destroy_author+ is called. When <tt>Reply#destroy</tt> is
# run, both +destroy_author+ and +destroy_readers+ are called. Contrast this to the following situation
# where the +before_destroy+ method is overridden:
#
#   class Topic < ActiveRecord::Base
#     def before_destroy() destroy_author end
#   end
#
#   class Reply < Topic
#     def before_destroy() destroy_readers end
#   end
#
# In that case, <tt>Reply#destroy</tt> would only run +destroy_readers+ and _not_ +destroy_author+.
# So, use the callback macros when you want to ensure that a certain callback is called for the entire
# hierarchy, and use the regular overwritable methods when you want to leave it up to each descendant
# to decide whether they want to call +super+ and trigger the inherited callbacks.
#
# *IMPORTANT:* In order for inheritance to work for the callback queues, you must specify the
# callbacks before specifying the associations. Otherwise, you might trigger the loading of a
# child before the parent has registered the callbacks and they won't be inherited.
#
# == Types of callbacks
#
# There are four types of callbacks accepted by the callback macros: Method references (symbol), callback objects,
# inline methods (using a proc), and inline eval methods (using a string). Method references and callback objects
# are the recommended approaches, inline methods using a proc are sometimes appropriate (such as for
# creating mix-ins), and inline eval methods are deprecated.
#
# The method reference callbacks work by specifying a protected or private method available in the object, like this:
#
#   class Topic < ActiveRecord::Base
#     before_destroy :delete_parents
#
#     private
#       def delete_parents
#         self.class.delete_all "parent_id = #{id}"
#       end
#   end
#
# The callback objects have methods named after the callback called with the record as the only parameter, such as:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new
#     after_save       EncryptionWrapper.new
#     after_initialize EncryptionWrapper.new
#   end
#
#   class EncryptionWrapper
#     def before_save(record)
#       record.credit_card_number = encrypt(record.credit_card_number)
#     end
#
#     def after_save(record)
#       record.credit_card_number = decrypt(record.credit_card_number)
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# So you specify the object you want messaged on a given callback. When that callback is triggered, the object has
# a method by the name of the callback messaged. You can make these callbacks more flexible by passing in other
# initialization data such as the name of the attribute to work with:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new("credit_card_number")
#     after_save       EncryptionWrapper.new("credit_card_number")
#     after_initialize EncryptionWrapper.new("credit_card_number")
#   end
#
#   class EncryptionWrapper
#     def initialize(attribute)
#       @attribute = attribute
#     end
#
#     def before_save(record)
#       record.send("#{@attribute}=", encrypt(record.send("#{@attribute}")))
#     end
#
#     def after_save(record)
#       record.send("#{@attribute}=", decrypt(record.send("#{@attribute}")))
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# == <tt>before_validation*</tt> returning statements
#
# If the +before_validation+ callback throws +:abort+, the process will be
# aborted and {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will return +false+.
# If {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] is called it will raise an ActiveRecord::RecordInvalid exception.
# Nothing will be appended to the errors object.
#
# == Canceling callbacks
#
# If a <tt>before_*</tt> callback throws +:abort+, all the later callbacks and
# the associated action are cancelled.
# Callbacks are generally run in the order they are defined, with the exception of callbacks defined as
# methods on the model, which are called last.
#
# == Ordering callbacks
#
# Sometimes the code needs that the callbacks execute in a specific order. For example, a +before_destroy+
# callback (+log_children+ in this case) should be executed before the children get destroyed by the
# <tt>dependent: :destroy</tt> option.
#
# Let's look at the code below:
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# In this case, the problem is that when the +before_destroy+ callback is executed, the children are not available
# because the {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] callback gets executed first.
# You can use the +prepend+ option on the +before_destroy+ callback to avoid this.
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children, prepend: true
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# This way, the +before_destroy+ gets executed before the <tt>dependent: :destroy</tt> is called, and the data is still available.
#
# == \Transactions
#
# The entire callback chain of a {#save}[rdoc-ref:Persistence#save], {#save!}[rdoc-ref:Persistence#save!],
# or {#destroy}[rdoc-ref:Persistence#destroy] call runs within a transaction. That includes <tt>after_*</tt> hooks.
# If everything goes fine a COMMIT is executed once the chain has been completed.
#
# If a <tt>before_*</tt> callback cancels the action a ROLLBACK is issued. You
# can also trigger a ROLLBACK raising an exception in any of the callbacks,
# including <tt>after_*</tt> hooks. Note, however, that in that case the client
# needs to be aware of it because an ordinary {#save}[rdoc-ref:Persistence#save] will raise such exception
# instead of quietly returning +false+.
#
# == Debugging callbacks
#
# The callback chain is accessible via the <tt>_*_callbacks</tt> method on an object. Active Model \Callbacks support
# <tt>:before</tt>, <tt>:after</tt> and <tt>:around</tt> as values for the <tt>kind</tt> property. The <tt>kind</tt> property
# defines what part of the chain the callback runs in.
#
# To find all callbacks in the before_save callback chain:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }
#
# Returns an array of callback objects that form the before_save chain.
#
# To further check if the before_save chain contains a proc defined as <tt>rest_when_dead</tt> use the <tt>filter</tt> property of the callback object:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }.collect(&:filter).include?(:rest_when_dead)
#
# Returns true or false depending on whether the proc is contained in the before_save callback chain on a Topic model.
module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  def destroy; end
  def touch(*_arg0); end

  private

  def _create_record; end
  def _update_record(*_arg0); end
  def create_or_update(*_arg0); end

  module GeneratedClassMethods
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _create_callbacks?; end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _destroy_callbacks?; end
    def _find_callbacks; end
    def _find_callbacks=(value); end
    def _find_callbacks?; end
    def _initialize_callbacks; end
    def _initialize_callbacks=(value); end
    def _initialize_callbacks?; end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _save_callbacks?; end
    def _touch_callbacks; end
    def _touch_callbacks=(value); end
    def _touch_callbacks?; end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _update_callbacks?; end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validation_callbacks?; end
  end

  module GeneratedInstanceMethods
    def _create_callbacks; end
    def _create_callbacks?; end
    def _destroy_callbacks; end
    def _destroy_callbacks?; end
    def _find_callbacks; end
    def _find_callbacks?; end
    def _initialize_callbacks; end
    def _initialize_callbacks?; end
    def _save_callbacks; end
    def _save_callbacks?; end
    def _touch_callbacks; end
    def _touch_callbacks?; end
    def _update_callbacks; end
    def _update_callbacks?; end
    def _validation_callbacks; end
    def _validation_callbacks?; end
  end
end

ActiveRecord::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

module ActiveRecord::Callbacks::ClassMethods
  include ::ActiveModel::Callbacks
end

module ActiveRecord::Coders; end

class ActiveRecord::Coders::JSON
  class << self
    def dump(obj); end
    def load(json); end
  end
end

class ActiveRecord::Coders::YAMLColumn
  # @return [YAMLColumn] a new instance of YAMLColumn
  def initialize(object_class = T.unsafe(nil)); end

  def assert_valid_value(obj); end
  def dump(obj); end
  def load(yaml); end

  # Returns the value of attribute object_class.
  def object_class; end

  # Sets the attribute object_class
  #
  # @param value the value to set the attribute object_class to.
  def object_class=(_arg0); end

  private

  def check_arity_of_constructor; end
end

module ActiveRecord::CollectionCacheKey
  def collection_cache_key(collection = T.unsafe(nil), timestamp_column = T.unsafe(nil)); end
end

class ActiveRecord::ConcurrentMigrationError < ::ActiveRecord::MigrationError
  # @return [ConcurrentMigrationError] a new instance of ConcurrentMigrationError
  def initialize(message = T.unsafe(nil)); end
end

ActiveRecord::ConcurrentMigrationError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# Raised when association is being configured improperly or user tries to use
# offset and limit together with
# {ActiveRecord::Base.has_many}[rdoc-ref:Associations::ClassMethods#has_many] or
# {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many]
# associations.
class ActiveRecord::ConfigurationError < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

# Active Record supports multiple database systems. AbstractAdapter and
# related classes form the abstraction layer which makes this possible.
# An AbstractAdapter represents a connection to a database, and provides an
# abstract interface for database-specific functionality such as establishing
# a connection, escaping values, building the right SQL fragments for +:offset+
# and +:limit+ options, etc.
#
# All the concrete database adapters follow the interface laid down in this class.
# {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling#connection] returns an AbstractAdapter object, which
# you can use.
#
# Most of the methods in the adapter are useful during migrations. Most
# notably, the instance methods provided by SchemaStatements are very useful.
class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::ColumnDumper
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [AbstractAdapter] a new instance of AbstractAdapter
  def initialize(connection, logger = T.unsafe(nil), config = T.unsafe(nil)); end

  def _checkin_callbacks; end
  def _checkin_callbacks?; end
  def _checkout_callbacks; end
  def _checkout_callbacks?; end
  def _run_checkin_callbacks(&block); end
  def _run_checkout_callbacks(&block); end

  # Checks whether the connection to the database is still active. This includes
  # checking whether the database is actually capable of responding, i.e. whether
  # the connection isn't stale.
  #
  # @return [Boolean]
  def active?; end

  # Returns the human-readable name of the adapter. Use mixed case - one
  # can always use downcase if needed.
  def adapter_name; end

  def arel_visitor; end
  def case_insensitive_comparison(table, attribute, column, value); end
  def case_sensitive_comparison(table, attribute, column, value); end

  # Clear any caching the database adapter may be doing, for example
  # clearing the prepared statement cache. This is database specific.
  def clear_cache!; end

  # Check the connection back in to the connection pool
  def close; end

  def collector; end
  def column_name_for_operation(operation, node); end
  def combine_bind_parameters(from_clause: T.unsafe(nil), join_clause: T.unsafe(nil), where_clause: T.unsafe(nil), having_clause: T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil)); end
  def delete(*_arg0); end

  # This is meant to be implemented by the adapters that support extensions
  def disable_extension(name); end

  # Override to turn off referential integrity while executing <tt>&block</tt>.
  def disable_referential_integrity; end

  # Disconnects from the database if already connected. Otherwise, this
  # method does nothing.
  def disconnect!; end

  # This is meant to be implemented by the adapters that support extensions
  def enable_extension(name); end

  # this method must only be called while holding connection pool's mutex
  def expire; end

  # A list of extensions, to be filled in by adapters that support them.
  def extensions; end

  # This is meant to be implemented by the adapters that support advisory
  # locks
  #
  # Return true if we got the lock, otherwise false
  def get_advisory_lock(lock_id); end

  # Returns the value of attribute owner.
  def in_use?; end

  # A list of index algorithms, to be filled by adapters that support them.
  def index_algorithms; end

  def insert(*_arg0); end

  # this method must only be called while holding connection pool's mutex
  def lease; end

  # Returns the value of attribute logger.
  def logger; end

  def lookup_cast_type(sql_type); end
  def new_column(name, default, sql_type_metadata, null, table_name, default_function = T.unsafe(nil), collation = T.unsafe(nil)); end

  # Returns the value of attribute owner.
  def owner; end

  # Returns the value of attribute pool.
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  def pool=(_arg0); end

  # Should primary key values be selected from their corresponding
  # sequence before the insert statement? If true, next_sequence_value
  # is called before each insert to set the record's primary key.
  #
  # @return [Boolean]
  def prefetch_primary_key?(table_name = T.unsafe(nil)); end

  # Returns the value of attribute prepared_statements.
  def prepared_statements; end

  # Provides access to the underlying database driver for this adapter. For
  # example, this method returns a Mysql2::Client object in case of Mysql2Adapter,
  # and a PG::Connection object in case of PostgreSQLAdapter.
  #
  # This is useful for when you need to call a proprietary method such as
  # PostgreSQL's lo_* methods.
  def raw_connection; end

  # Disconnects from the database if already connected, and establishes a
  # new connection with the database. Implementors should call super if they
  # override the default implementation.
  def reconnect!; end

  # This is meant to be implemented by the adapters that support advisory
  # locks.
  #
  # Return true if we released the lock, otherwise false
  def release_advisory_lock(lock_id); end

  # Returns true if its required to reload the connection between requests for development mode.
  #
  # @return [Boolean]
  def requires_reloading?; end

  # Reset the state of this connection, directing the DBMS to clear
  # transactions and other connection-related server-side state. Usually a
  # database-dependent operation.
  #
  # The default implementation does nothing; the implementation should be
  # overridden by concrete adapters.
  def reset!; end

  def rollback_db_transaction(*_arg0); end
  def rollback_to_savepoint(*_arg0); end

  # Returns the value of attribute schema_cache.
  def schema_cache; end

  def schema_cache=(cache); end
  def schema_creation; end

  # this method must only be called while holding connection pool's mutex (and a desire for segfaults)
  def steal!; end

  # Does this adapter support application-enforced advisory locking?
  #
  # @return [Boolean]
  def supports_advisory_locks?; end

  # @return [Boolean]
  def supports_bulk_alter?; end

  # Does this adapter support metadata comments on database objects (tables, columns, indexes)?
  #
  # @return [Boolean]
  def supports_comments?; end

  # Can comments for tables, columns, and indexes be specified in create/alter table statements?
  #
  # @return [Boolean]
  def supports_comments_in_create?; end

  # Does this adapter support datetime with precision?
  #
  # @return [Boolean]
  def supports_datetime_with_precision?; end

  # Does this adapter support DDL rollbacks in transactions? That is, would
  # CREATE TABLE or ALTER TABLE get rolled back by a transaction?
  #
  # @return [Boolean]
  def supports_ddl_transactions?; end

  # Does this adapter support explain?
  #
  # @return [Boolean]
  def supports_explain?; end

  # Does this adapter support expression indices?
  #
  # @return [Boolean]
  def supports_expression_index?; end

  # Does this adapter support database extensions?
  #
  # @return [Boolean]
  def supports_extensions?; end

  # Does this adapter support creating foreign key constraints?
  #
  # @return [Boolean]
  def supports_foreign_keys?; end

  # Does this adapter support index sort order?
  #
  # @return [Boolean]
  def supports_index_sort_order?; end

  # Does this adapter support creating indexes in the same statement as
  # creating the table?
  #
  # @return [Boolean]
  def supports_indexes_in_create?; end

  # Does this adapter support json data type?
  #
  # @return [Boolean]
  def supports_json?; end

  # Does this adapter support migrations?
  #
  # @return [Boolean]
  def supports_migrations?; end

  # Does this adapter support multi-value insert?
  #
  # @return [Boolean]
  def supports_multi_insert?; end

  # Does this adapter support partial indices?
  #
  # @return [Boolean]
  def supports_partial_index?; end

  # Can this adapter determine the primary key for tables not attached
  # to an Active Record class, such as join tables?
  #
  # @return [Boolean]
  def supports_primary_key?; end

  # Does this adapter support savepoints?
  #
  # @return [Boolean]
  def supports_savepoints?; end

  # Does this adapter support setting the isolation level for a transaction?
  #
  # @return [Boolean]
  def supports_transaction_isolation?; end

  # Does this adapter support views?
  #
  # @return [Boolean]
  def supports_views?; end

  def type_map; end
  def unprepared_statement; end
  def update(*_arg0); end

  # @return [Boolean]
  def valid_type?(type); end

  # Checks whether the connection to the database is still active (i.e. not stale).
  # This is done under the hood by calling #active?. If the connection
  # is no longer active, then this method will reconnect to the database.
  def verify!(*ignored); end

  # Returns the value of attribute visitor.
  def visitor; end

  # Sets the attribute visitor
  #
  # @param value the value to set the attribute visitor to.
  def visitor=(_arg0); end

  protected

  def column_for(table_name, column_name); end
  def extract_limit(sql_type); end
  def extract_precision(sql_type); end
  def extract_scale(sql_type); end
  def initialize_type_map(m); end
  def log(sql, name = T.unsafe(nil), binds = T.unsafe(nil), type_casted_binds = T.unsafe(nil), statement_name = T.unsafe(nil)); end
  def register_class_with_limit(mapping, key, klass); end
  def register_class_with_precision(mapping, key, klass); end
  def reload_type_map; end
  def translate_exception(exception, message); end
  def translate_exception_class(e, sql); end

  # @return [Boolean]
  def without_prepared_statement?(binds); end

  private

  # @return [Boolean]
  def can_perform_case_insensitive_comparison_for?(column); end

  class << self
    def _checkin_callbacks; end
    def _checkin_callbacks=(val); end
    def _checkin_callbacks?; end
    def _checkout_callbacks; end
    def _checkout_callbacks=(val); end
    def _checkout_callbacks?; end
    def type_cast_config_to_boolean(config); end
    def type_cast_config_to_integer(config); end
  end
end

ActiveRecord::ConnectionAdapters::AbstractAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)

class ActiveRecord::ConnectionAdapters::AbstractAdapter::BindCollector < ::Arel::Collectors::Bind
  def compile(bvs, conn); end
end

ActiveRecord::ConnectionAdapters::AbstractAdapter::SIMPLE_INT = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SQLString < ::Arel::Collectors::SQLString
  def compile(bvs, conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  # @return [SchemaCreation] a new instance of SchemaCreation
  def initialize(conn); end

  def accept(o); end

  private

  def action_sql(action, dependency); end
  def add_column_options!(sql, options); end
  def add_table_options!(create_sql, options); end
  def column_options(o); end
  def foreign_key_in_create(from_table, to_table, options); end
  def foreign_key_options(*args, &block); end
  def options_include_default?(*args, &block); end
  def quote_column_name(*args, &block); end
  def quote_default_expression(*args, &block); end
  def quote_table_name(*args, &block); end
  def supports_foreign_keys?(*args, &block); end
  def supports_indexes_in_create?(*args, &block); end
  def table_options(o); end
  def type_to_sql(*args, &block); end
  def visit_AddColumnDefinition(o); end
  def visit_AddForeignKey(o); end
  def visit_AlterTable(o); end
  def visit_ColumnDefinition(o); end
  def visit_DropForeignKey(name); end
  def visit_ForeignKeyDefinition(o); end
  def visit_PrimaryKeyDefinition(o); end
  def visit_TableDefinition(o); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable

  # @return [Version] a new instance of Version
  def initialize(version_string); end

  def <=>(version_string); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition < ::Struct; end

class ActiveRecord::ConnectionAdapters::AlterTable
  # @return [AlterTable] a new instance of AlterTable
  def initialize(td); end

  def add_column(name, type, options); end
  def add_foreign_key(to_table, options); end

  # Returns the value of attribute adds.
  def adds; end

  def drop_foreign_key(name); end

  # Returns the value of attribute foreign_key_adds.
  def foreign_key_adds; end

  # Returns the value of attribute foreign_key_drops.
  def foreign_key_drops; end

  def name; end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition < ::Struct; end

# An abstract definition of a column in a table.
class ActiveRecord::ConnectionAdapters::Column
  # Instantiates a new column in the table.
  #
  # +name+ is the column's name, such as <tt>supplier_id</tt> in <tt>supplier_id int</tt>.
  # +default+ is the type-casted default value, such as +new+ in <tt>sales_stage varchar(20) default 'new'</tt>.
  # +sql_type_metadata+ is various information about the type of the column
  # +null+ determines if this column allows +NULL+ values.
  #
  # @return [Column] a new instance of Column
  def initialize(name, default, sql_type_metadata = T.unsafe(nil), null = T.unsafe(nil), table_name = T.unsafe(nil), default_function = T.unsafe(nil), collation = T.unsafe(nil), comment: T.unsafe(nil), **_arg8); end

  def ==(other); end

  # @return [Boolean]
  def bigint?; end

  # Returns the value of attribute collation.
  def collation; end

  # Returns the value of attribute comment.
  def comment; end

  # Returns the value of attribute default.
  def default; end

  # Returns the value of attribute default_function.
  def default_function; end

  def eql?(other); end

  # @return [Boolean]
  def has_default?; end

  def hash; end

  # Returns the human name of the column name.
  #
  # ===== Examples
  #  Column.new('sales_stage', ...).human_name # => 'Sales stage'
  def human_name; end

  def limit(*args, &block); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute null.
  def null; end

  def precision(*args, &block); end
  def scale(*args, &block); end
  def sql_type(*args, &block); end

  # Returns the value of attribute sql_type_metadata.
  def sql_type_metadata; end

  # Returns the value of attribute table_name.
  def table_name; end

  def type(*args, &block); end

  protected

  def attributes_for_hash; end
end

# Abstract representation of a column definition. Instances of this type
# are typically created by methods in TableDefinition, and added to the
# +columns+ attribute of said TableDefinition object, in order to be used
# for generating a number of table creation or table changing SQL statements.
class ActiveRecord::ConnectionAdapters::ColumnDefinition < ::Struct
  # @return [Boolean]
  def primary_key?; end
end

# The goal of this module is to move Adapter specific column
# definitions to the Adapter instead of having it in the schema
# dumper itself. This code represents the normal case.
# We can then redefine how certain data types may be handled in the schema dumper on the
# Adapter level by over-writing this code inside the database specific adapters
module ActiveRecord::ConnectionAdapters::ColumnDumper
  def column_spec(column); end
  def column_spec_for_primary_key(column); end

  # Lists the valid migration options
  def migration_keys; end

  # This can be overridden on an Adapter level basis to support other
  # extended datatypes (Example: Adding an array option in the
  # PostgreSQL::ColumnDumper)
  def prepare_column_options(column); end

  private

  # @return [Boolean]
  def default_primary_key?(column); end

  def schema_collation(column); end
  def schema_default(column); end
  def schema_expression(column); end
  def schema_limit(column); end
  def schema_precision(column); end
  def schema_scale(column); end
  def schema_type(column); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  def bigint(*args, **options); end
  def binary(*args, **options); end
  def boolean(*args, **options); end
  def date(*args, **options); end
  def datetime(*args, **options); end
  def decimal(*args, **options); end
  def float(*args, **options); end
  def integer(*args, **options); end
  def numeric(*args, **options); end

  # Appends a primary key definition to the table definition.
  # Can be called multiple times, but this is probably not a good idea.
  def primary_key(name, type = T.unsafe(nil), **options); end

  def string(*args, **options); end
  def text(*args, **options); end
  def time(*args, **options); end
  def timestamp(*args, **options); end
end

# ConnectionHandler is a collection of ConnectionPool objects. It is used
# for keeping separate connection pools that connect to different databases.
#
# For example, suppose that you have 5 models, with the following hierarchy:
#
#   class Author < ActiveRecord::Base
#   end
#
#   class BankAccount < ActiveRecord::Base
#   end
#
#   class Book < ActiveRecord::Base
#     establish_connection "library_db"
#   end
#
#   class ScaryBook < Book
#   end
#
#   class GoodBook < Book
#   end
#
# And a database.yml that looked like this:
#
#   development:
#     database: my_application
#     host: localhost
#
#   library_db:
#     database: library
#     host: some.library.org
#
# Your primary database in the development environment is "my_application"
# but the Book model connects to a separate database called "library_db"
# (this can even be a database on a different machine).
#
# Book, ScaryBook and GoodBook will all use the same connection pool to
# "library_db" while Author, BankAccount, and any other models you create
# will use the default connection pool to "my_application".
#
# The various connection pools are managed by a single instance of
# ConnectionHandler accessible via ActiveRecord::Base.connection_handler.
# All Active Record models use this handler to determine the connection pool that they
# should use.
#
# The ConnectionHandler class is not coupled with the Active models, as it has no knowlodge
# about the model. The model, needs to pass a specification name to the handler,
# in order to lookup the correct connection pool.
class ActiveRecord::ConnectionAdapters::ConnectionHandler
  # @return [ConnectionHandler] a new instance of ConnectionHandler
  def initialize; end

  # Returns true if there are any active connections among the connection
  # pools that the ConnectionHandler is managing.
  #
  # @return [Boolean]
  def active_connections?; end

  # Returns any connections in use by the current thread back to the pool,
  # and also returns connections to the pool cached by threads that are no
  # longer alive.
  def clear_active_connections!; end

  def clear_all_connections!; end

  # Clears the cache which maps classes.
  #
  # See ConnectionPool#clear_reloadable_connections! for details.
  def clear_reloadable_connections!; end

  # Returns true if a connection that's accessible to this class has
  # already been opened.
  #
  # @return [Boolean]
  def connected?(spec_name); end

  def connection_pool_list; end
  def connection_pools; end
  def establish_connection(spec); end

  # Remove the connection for this class. This will close the active
  # connection and the defined connection (if they exist). The result
  # can be used as an argument for establish_connection, for easily
  # re-establishing the connection.
  def remove_connection(spec_name); end

  # Locate the connection of the nearest super class. This can be an
  # active or defined connection: if it is the latter, it will be
  # opened and set as the active connection for the class it was defined
  # for (not necessarily the current class).
  #
  # @raise [ConnectionNotEstablished]
  def retrieve_connection(spec_name); end

  # Retrieving the connection pool happens a lot so we cache it in @class_to_pool.
  # This makes retrieving the connection pool O(1) once the process is warm.
  # When a connection is established or removed, we invalidate the cache.
  #
  # Ideally we would use #fetch here, as class_to_pool[klass] may sometimes be nil.
  # However, benchmarking (https://gist.github.com/jonleighton/3552829) showed that
  # #fetch is significantly slower than #[]. So in the nil case, no caching will
  # take place, but that's ok since the nil case is not the common one that we wish
  # to optimise for.
  def retrieve_connection_pool(spec_name); end

  private

  def owner_to_pool; end
  def pool_from_any_process_for(spec_name); end
end

# Connection pool base class for managing Active Record database
# connections.
#
# == Introduction
#
# A connection pool synchronizes thread access to a limited number of
# database connections. The basic idea is that each thread checks out a
# database connection from the pool, uses that connection, and checks the
# connection back in. ConnectionPool is completely thread-safe, and will
# ensure that a connection cannot be used by two threads at the same time,
# as long as ConnectionPool's contract is correctly followed. It will also
# handle cases in which there are more threads than connections: if all
# connections have been checked out, and a thread tries to checkout a
# connection anyway, then ConnectionPool will wait until some other thread
# has checked in a connection.
#
# == Obtaining (checking out) a connection
#
# Connections can be obtained and used from a connection pool in several
# ways:
#
# 1. Simply use {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling.connection]
#    as with Active Record 2.1 and
#    earlier (pre-connection-pooling). Eventually, when you're done with
#    the connection(s) and wish it to be returned to the pool, you call
#    {ActiveRecord::Base.clear_active_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_active_connections!].
#    This will be the default behavior for Active Record when used in conjunction with
#    Action Pack's request handling cycle.
# 2. Manually check out a connection from the pool with
#    {ActiveRecord::Base.connection_pool.checkout}[rdoc-ref:#checkout]. You are responsible for
#    returning this connection to the pool when finished by calling
#    {ActiveRecord::Base.connection_pool.checkin(connection)}[rdoc-ref:#checkin].
# 3. Use {ActiveRecord::Base.connection_pool.with_connection(&block)}[rdoc-ref:#with_connection], which
#    obtains a connection, yields it as the sole argument to the block,
#    and returns it to the pool after the block completes.
#
# Connections in the pool are actually AbstractAdapter objects (or objects
# compatible with AbstractAdapter's interface).
#
# == Options
#
# There are several connection-pooling-related options that you can add to
# your database connection configuration:
#
# * +pool+: number indicating size of connection pool (default 5)
# * +checkout_timeout+: number of seconds to block and wait for a connection
#   before giving up and raising a timeout error (default 5 seconds).
# * +reaping_frequency+: frequency in seconds to periodically run the
#   Reaper, which attempts to find and recover connections from dead
#   threads, which can occur if a programmer forgets to close a
#   connection at the end of a thread or a thread dies unexpectedly.
#   Regardless of this setting, the Reaper will be invoked before every
#   blocking wait. (Default nil, which means don't schedule the Reaper).
#
# --
# Synchronization policy:
# * all public methods can be called outside +synchronize+
# * access to these i-vars needs to be in +synchronize+:
#   * @connections
#   * @now_connecting
# * private methods that require being called in a +synchronize+ blocks
#   are now explicitly documented
class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration

  # Creates a new ConnectionPool object. +spec+ is a ConnectionSpecification
  # object which describes database connection information (e.g. adapter,
  # host name, username, password, etc), as well as the maximum size for
  # this ConnectionPool.
  #
  # The default ConnectionPool maximum size is 5.
  #
  # @return [ConnectionPool] a new instance of ConnectionPool
  def initialize(spec); end

  # Is there an open connection that is being used for the current thread?
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods, connections obtained through
  # #checkout will not be detected by #active_connection?
  #
  # @return [Boolean]
  def active_connection?; end

  # Returns the value of attribute automatic_reconnect.
  def automatic_reconnect; end

  # Sets the attribute automatic_reconnect
  #
  # @param value the value to set the attribute automatic_reconnect to.
  def automatic_reconnect=(_arg0); end

  # Check-in a database connection back into the pool, indicating that you
  # no longer need this connection.
  #
  # +conn+: an AbstractAdapter object, which was obtained by earlier by
  # calling #checkout on this pool.
  def checkin(conn); end

  # Check-out a database connection from the pool, indicating that you want
  # to use it. You should call #checkin when you no longer need this.
  #
  # This is done by either returning and leasing existing connection, or by
  # creating a new connection and leasing it.
  #
  # If all connections are leased and the pool is at capacity (meaning the
  # number of currently leased connections is greater than or equal to the
  # size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.
  #
  # Returns: an AbstractAdapter object.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError no connection can be obtained from the pool.
  def checkout(checkout_timeout = T.unsafe(nil)); end

  # Returns the value of attribute checkout_timeout.
  def checkout_timeout; end

  # Sets the attribute checkout_timeout
  #
  # @param value the value to set the attribute checkout_timeout to.
  def checkout_timeout=(_arg0); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.config[:checkout_timeout] * 2</tt> seconds).
  def clear_reloadable_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # The pool first tries to gain ownership of all connections, if unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.config[:checkout_timeout] * 2</tt> seconds), the pool forcefully
  # clears the cache and reloads connections without any regard for other
  # connection owning threads.
  def clear_reloadable_connections!; end

  # Returns true if a connection has already been opened.
  #
  # @return [Boolean]
  def connected?; end

  # Retrieve the connection associated with the current thread, or call
  # #checkout to obtain one if necessary.
  #
  # #connection can be called any number of times; the connection is
  # held in a cache keyed by a thread.
  def connection; end

  # Returns the value of attribute connections.
  def connections; end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.config[:checkout_timeout] * 2</tt> seconds).
  def disconnect(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # The pool first tries to gain ownership of all connections, if unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.config[:checkout_timeout] * 2</tt> seconds), the pool is forcefully
  # disconnected without any regard for other connection owning threads.
  def disconnect!; end

  def num_waiting_in_queue; end

  # Recover lost connections for the pool. A lost connection can occur if
  # a programmer forgets to checkin a connection at the end of a thread
  # or a thread dies unexpectedly.
  def reap; end

  # Returns the value of attribute reaper.
  def reaper; end

  # Signal that the thread is finished with the current connection.
  # #release_connection releases the connection-thread association
  # and returns the connection to the pool.
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods, connections obtained through
  # #checkout will not be automatically released.
  def release_connection(owner_thread = T.unsafe(nil)); end

  # Remove a connection from the connection pool. The connection will
  # remain open and active but will no longer be managed by this pool.
  def remove(conn); end

  # Returns the value of attribute schema_cache.
  def schema_cache; end

  # Sets the attribute schema_cache
  #
  # @param value the value to set the attribute schema_cache to.
  def schema_cache=(_arg0); end

  # Returns the value of attribute size.
  def size; end

  # Returns the value of attribute spec.
  def spec; end

  # If a connection obtained through #connection or #with_connection methods
  # already exists yield it to the block. If no such connection
  # exists checkout a connection, yield it to the block, and checkin the
  # connection when finished.
  def with_connection; end

  private

  # Acquire a connection by one of 1) immediately removing one
  # from the queue of available connections, 2) creating a new
  # connection if the pool is not at capacity, 3) waiting on the
  # queue for a connection to become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if a connection could not be acquired
  #
  # --
  # Implementation detail: the connection returned by +acquire_connection+
  # will already be "+connection.lease+ -ed" to the current thread.
  def acquire_connection(checkout_timeout); end

  def adopt_connection(conn); end
  def attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # --
  # this is unfortunately not concurrent
  def bulk_make_new_connections(num_new_conns_needed); end

  def checkout_and_verify(c); end

  # --
  # Must be called in a synchronize block.
  def checkout_for_exclusive_access(checkout_timeout); end

  # @raise [ConnectionNotEstablished]
  def checkout_new_connection; end

  # --
  # From the discussion on GitHub:
  #  https://github.com/rails/rails/pull/14938#commitcomment-6601951
  # This hook-in method allows for easier monkey-patching fixes needed by
  # JRuby users that use Fibers.
  def connection_cache_key(thread); end

  def new_connection; end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  def release(conn, owner_thread = T.unsafe(nil)); end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  def remove_connection_from_thread_cache(conn, owner_thread = T.unsafe(nil)); end

  # If the pool is not at a +@size+ limit, establish new connection. Connecting
  # to the DB is done outside main synchronized section.
  # --
  # Implementation constraint: a newly established connection returned by this
  # method must be in the +.leased+ state.
  def try_to_checkout_new_connection; end

  # Take control of all existing connections so a "group" action such as
  # reload/disconnect can be performed safely. It is no longer enough to
  # wrap it in +synchronize+ because some pool's actions are allowed
  # to be performed outside of the main +synchronize+ block.
  def with_exclusively_acquired_all_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  def with_new_connections_blocked; end
end

# Adds the ability to turn a basic fair FIFO queue into one
# biased to some thread.
module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  # semantics of condition variables guarantee that +broadcast+, +broadcast_on_biased+,
  # +signal+ and +wait+ methods are only called while holding a lock
  #
  # @return [BiasedConditionVariable] a new instance of BiasedConditionVariable
  def initialize(lock, other_cond, preferred_thread); end

  def broadcast; end
  def broadcast_on_biased; end
  def signal; end
  def wait(timeout); end
end

# Connections must be leased while holding the main pool mutex. This is
# an internal subclass that also +.leases+ returned connections while
# still in queue's critical section (queue synchronizes with the same
# +@lock+ as the main pool) so that a returned connection is already
# leased and there is no need to re-enter synchronized block.
class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue < ::ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue

  private

  def internal_poll(timeout); end
end

# Threadsafe, fair, FIFO queue.  Meant to be used by ConnectionPool
# with which it shares a Monitor.  But could be a generic Queue.
#
# The Queue in stdlib's 'thread' could replace this class except
# stdlib's doesn't support waiting with a timeout.
class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  # @return [Queue] a new instance of Queue
  def initialize(lock = T.unsafe(nil)); end

  # Add +element+ to the queue.  Never blocks.
  def add(element); end

  # Test if any threads are currently waiting on the queue.
  #
  # @return [Boolean]
  def any_waiting?; end

  # Remove all elements from the queue.
  def clear; end

  # If +element+ is in the queue, remove and return it, or nil.
  def delete(element); end

  # Returns the number of threads currently waiting on this
  # queue.
  def num_waiting; end

  # Remove the head of the queue.
  #
  # If +timeout+ is not given, remove and return the head the
  # queue if the number of available elements is strictly
  # greater than the number of threads currently waiting (that
  # is, don't jump ahead in line).  Otherwise, return nil.
  #
  # If +timeout+ is given, block if there is no element
  # available, waiting up to +timeout+ seconds for an element to
  # become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if +timeout+ is given and no element
  # becomes available within +timeout+ seconds,
  def poll(timeout = T.unsafe(nil)); end

  private

  # Test if the queue currently contains any elements.
  #
  # @return [Boolean]
  def any?; end

  # A thread can remove an element from the queue without
  # waiting if and only if the number of currently available
  # connections is strictly greater than the number of waiting
  # threads.
  #
  # @return [Boolean]
  def can_remove_no_wait?; end

  def internal_poll(timeout); end

  # Remove and return the head the queue if the number of
  # available elements is strictly greater than the number of
  # threads currently waiting.  Otherwise, return nil.
  def no_wait_poll; end

  # Removes and returns the head of the queue if possible, or nil.
  def remove; end

  def synchronize(&block); end

  # Waits on the queue up to +timeout+ seconds, then removes and
  # returns the head of the queue.
  def wait_poll(timeout); end
end

# Every +frequency+ seconds, the reaper will call +reap+ on +pool+.
# A reaper instantiated with a nil frequency will never reap the
# connection pool.
#
# Configure the frequency by setting "reaping_frequency" in your
# database yaml file.
class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  # @return [Reaper] a new instance of Reaper
  def initialize(pool, frequency); end

  # Returns the value of attribute frequency.
  def frequency; end

  # Returns the value of attribute pool.
  def pool; end

  def run; end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  # @return [ConnectionSpecification] a new instance of ConnectionSpecification
  def initialize(name, config, adapter_method); end

  # Returns the value of attribute adapter_method.
  def adapter_method; end

  # Returns the value of attribute config.
  def config; end

  # Returns the value of attribute name.
  def name; end

  private

  def initialize_dup(original); end
end

# Expands a connection string into a hash.
class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  # == Example
  #
  #   url = "postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000"
  #   ConnectionUrlResolver.new(url).to_hash
  #   # => {
  #     "adapter"  => "postgresql",
  #     "host"     => "localhost",
  #     "port"     => 9000,
  #     "database" => "foo_test",
  #     "username" => "foo",
  #     "password" => "bar",
  #     "pool"     => "5",
  #     "timeout"  => "3000"
  #   }
  #
  # @return [ConnectionUrlResolver] a new instance of ConnectionUrlResolver
  def initialize(url); end

  # Converts the given URL to a full connection hash.
  def to_hash; end

  private

  # Returns name of the database.
  def database_from_path; end

  # Converts the query parameters of the URI into a hash.
  #
  #   "localhost?pool=5&reaping_frequency=2"
  #   # => { "pool" => "5", "reaping_frequency" => "2" }
  #
  # returns empty hash if no query present.
  #
  #   "localhost"
  #   # => {}
  def query_hash; end

  def raw_config; end
  def uri; end
  def uri_parser; end
end

# Builds a ConnectionSpecification from user input.
class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  # Accepts a hash two layers deep, keys on the first layer represent
  # environments such as "production". Keys must be strings.
  #
  # @return [Resolver] a new instance of Resolver
  def initialize(configurations); end

  def configurations; end

  # Returns a hash with database connection information.
  #
  # == Examples
  #
  # Full hash Configuration.
  #
  #   configurations = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3"}
  #
  # Initialized with URL configuration strings.
  #
  #   configurations = { "production" => "postgresql://localhost/foo" }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  def resolve(config); end

  # Expands each key in @configurations hash into fully resolved hash
  def resolve_all; end

  # Returns an instance of ConnectionSpecification for a given adapter.
  # Accepts a hash one layer deep that contains all connection information.
  #
  # == Example
  #
  #   config = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   spec = Resolver.new(config).spec(:production)
  #   spec.adapter_method
  #   # => "sqlite3_connection"
  #   spec.config
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" }
  #
  # @raise [AdapterNotSpecified]
  def spec(config, name = T.unsafe(nil)); end

  private

  # Returns fully resolved connection, accepts hash, string or symbol.
  # Always returns a hash.
  #
  # == Examples
  #
  # Symbol representing current environment.
  #
  #   Resolver.new("production" => {}).resolve_connection(:production)
  #   # => {}
  #
  # One layer deep hash of connection values.
  #
  #   Resolver.new({}).resolve_connection("adapter" => "sqlite3")
  #   # => { "adapter" => "sqlite3" }
  #
  # Connection URL.
  #
  #   Resolver.new({}).resolve_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  def resolve_connection(spec); end

  # Accepts a hash. Expands the "url" key that contains a
  # URL database connection to a full connection
  # hash and merges with the rest of the hash.
  # Connection details inside of the "url" key win any merge conflicts
  def resolve_hash_connection(spec); end

  # Takes the environment such as +:production+ or +:development+.
  # This requires that the @configurations was initialized with a key that
  # matches.
  #
  #   Resolver.new("production" => {}).resolve_symbol_connection(:production)
  #   # => {}
  def resolve_symbol_connection(spec); end

  # Takes a connection URL.
  #
  #   Resolver.new({}).resolve_url_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  def resolve_url_connection(url); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  # Returns the maximum allowed length for an index name. This
  # limit is enforced by \Rails and is less than or equal to
  # #index_name_length. The gap between
  # #index_name_length is to allow internal \Rails
  # operations to use prefixes in temporary operations.
  def allowed_index_name_length; end

  # Returns the maximum length of a column name.
  def column_name_length; end

  # Returns the maximum number of columns in a multicolumn index.
  def columns_per_multicolumn_index; end

  # Returns the maximum number of columns per table.
  def columns_per_table; end

  # Returns the maximum number of elements in an IN (x,y,z) clause.
  # nil means no limit.
  def in_clause_length; end

  # Returns the maximum length of an index name.
  def index_name_length; end

  # Returns the maximum number of indexes per table.
  def indexes_per_table; end

  # Returns maximum number of joins in a single query.
  def joins_per_query; end

  # Returns the maximum length of an SQL query.
  def sql_query_length; end

  # Returns the maximum length of a table alias.
  def table_alias_length; end

  # Returns the maximum length of a table name.
  def table_name_length; end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def initialize; end

  # Register a record with the current transaction so that its after_commit and after_rollback callbacks
  # can be called.
  def add_transaction_record(record); end

  # Begins the transaction (and turns off auto-committing).
  def begin_db_transaction; end

  # Begins the transaction with the isolation level set. Raises an error by
  # default; adapters that support setting the isolation level should implement
  # this method.
  #
  # @raise [ActiveRecord::TransactionIsolationError]
  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  # This is used in the StatementCache object. It returns an object that
  # can be used to query the database repeatedly.
  def cacheable_query(arel); end

  # Commits the transaction (and turns on auto-committing).
  def commit_db_transaction; end

  def commit_transaction(*args, &block); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is nil, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  def create(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil)); end

  def current_transaction(*args, &block); end
  def default_sequence_name(table, column); end

  # Executes the delete statement and returns the number of rows affected.
  def delete(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes the delete statement and returns the number of rows affected.
  def delete_sql(*args, &block); end

  def empty_insert_statement_value; end

  # Executes delete +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_delete(sql, name, binds); end

  # Executes insert +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_insert(sql, name, binds, pk = T.unsafe(nil), sequence_name = T.unsafe(nil)); end

  # Executes +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  #
  # @raise [NotImplementedError]
  def exec_query(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction; end

  # Executes update +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  def exec_update(sql, name, binds); end

  # Executes the SQL statement in the context of this connection and returns
  # the raw result from the connection adapter.
  # Note: depending on your database connector, the result returned by this
  # method may be manually memory managed. Consider using the exec_query
  # wrapper instead.
  #
  # @raise [NotImplementedError]
  def execute(sql, name = T.unsafe(nil)); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is nil, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  def insert(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Inserts the given fixture into the table. Overridden in adapters that require
  # something beyond a simple insert (eg. Oracle).
  def insert_fixture(fixture, table_name); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is nil, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  def insert_sql(*args, &block); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL adapters we redefine this to do that.
  def join_to_delete(update, select, key); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL adapters we redefine this to do that.
  def join_to_update(update, select, key); end

  def open_transactions(*args, &block); end

  # Set the sequence to the max value of the table's column.
  def reset_sequence!(table, column, sequence = T.unsafe(nil)); end

  def reset_transaction; end

  # Rolls back the transaction (and turns on auto-committing). Must be
  # done if the transaction block raises an exception or returns false.
  def rollback_db_transaction; end

  def rollback_to_savepoint(name = T.unsafe(nil)); end
  def rollback_transaction(*args, &block); end

  # Sanitizes the given LIMIT parameter in order to prevent SQL injection.
  #
  # The +limit+ may be anything that can evaluate to a string via #to_s. It
  # should look like an integer, or a comma-delimited list of integers, or
  # an Arel SQL literal.
  #
  # Returns Integer and Arel::Nodes::SqlLiteral limits as is.
  # Returns the sanitized limit parameter, either as an integer, or as a
  # string which contains a comma-delimited list of integers.
  def sanitize_limit(limit); end

  # Returns an ActiveRecord::Result instance.
  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil)); end

  # Returns a record hash with the column names as keys and column values
  # as values.
  def select_one(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns an array of arrays containing the field values.
  # Order is the same as that returned by +columns+.
  def select_rows(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns a single value from a record
  def select_value(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns an array of the values of the first column in a select:
  #   select_values("SELECT id FROM companies LIMIT 3") => [1,2,3]
  def select_values(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Returns +true+ when the connection adapter supports prepared statement
  # caching, otherwise returns +false+
  #
  # @return [Boolean]
  def supports_statement_cache?; end

  # Converts an arel AST to SQL
  def to_sql(arel, binds = T.unsafe(nil)); end

  # Runs the given block in a database transaction, and returns the result
  # of the block.
  #
  # == Nested transactions support
  #
  # Most databases don't support true nested transactions. At the time of
  # writing, the only database that supports true nested transactions that
  # we're aware of, is MS-SQL.
  #
  # In order to get around this problem, #transaction will emulate the effect
  # of nested transactions, by using savepoints:
  # http://dev.mysql.com/doc/refman/5.7/en/savepoint.html
  # Savepoints are supported by MySQL and PostgreSQL. SQLite3 version >= '3.6.8'
  # supports savepoints.
  #
  # It is safe to call this method if a database transaction is already open,
  # i.e. if #transaction is called within another #transaction block. In case
  # of a nested call, #transaction will behave as follows:
  #
  # - The block will be run without doing anything. All database statements
  #   that happen within the block are effectively appended to the already
  #   open database transaction.
  # - However, if +:requires_new+ is set, the block will be wrapped in a
  #   database savepoint acting as a sub-transaction.
  #
  # === Caveats
  #
  # MySQL doesn't support DDL transactions. If you perform a DDL operation,
  # then any created savepoints will be automatically released. For example,
  # if you've created a savepoint, then you execute a CREATE TABLE statement,
  # then the savepoint that was created will be automatically released.
  #
  # This means that, on MySQL, you shouldn't execute DDL operations inside
  # a #transaction call that you know might create a savepoint. Otherwise,
  # #transaction will raise exceptions when it tries to release the
  # already-automatically-released savepoints:
  #
  #   Model.connection.transaction do  # BEGIN
  #     Model.connection.transaction(requires_new: true) do  # CREATE SAVEPOINT active_record_1
  #       Model.connection.create_table(...)
  #       # active_record_1 now automatically released
  #     end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error!
  #   end
  #
  # == Transaction isolation
  #
  # If your database supports setting the isolation level for a transaction, you can set
  # it like so:
  #
  #   Post.transaction(isolation: :serializable) do
  #     # ...
  #   end
  #
  # Valid isolation levels are:
  #
  # * <tt>:read_uncommitted</tt>
  # * <tt>:read_committed</tt>
  # * <tt>:repeatable_read</tt>
  # * <tt>:serializable</tt>
  #
  # You should consult the documentation for your database to understand the
  # semantics of these different levels:
  #
  # * http://www.postgresql.org/docs/current/static/transaction-iso.html
  # * https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html
  #
  # An ActiveRecord::TransactionIsolationError will be raised if:
  #
  # * The adapter does not support setting the isolation level
  # * You are joining an existing open transaction
  # * You are creating a nested (savepoint) transaction
  #
  # The mysql2 and postgresql adapters support setting the transaction
  # isolation level.
  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels; end
  def transaction_manager; end

  # @return [Boolean]
  def transaction_open?; end

  def transaction_state; end

  # Executes the truncate statement.
  #
  # @raise [NotImplementedError]
  def truncate(table_name, name = T.unsafe(nil)); end

  # Executes the update statement and returns the number of rows affected.
  def update(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes the update statement and returns the number of rows affected.
  def update_sql(*args, &block); end

  def within_new_transaction(*args, &block); end

  protected

  def binds_from_relation(relation, binds); end
  def last_inserted_id(result); end

  # Returns an ActiveRecord::Result instance.
  def select(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  def select_prepared(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end
  def sql_for_insert(sql, pk, id_value, sequence_name, binds); end

  # Returns a subquery for the given key using the join information.
  def subquery_for(key, select); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(*_arg0); end

  # Returns the value of attribute preparable.
  def preparable; end

  def visit_Arel_Nodes_In(*_arg0); end
  def visit_Arel_Nodes_SqlLiteral(*_arg0); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition < ::Struct
  def column; end

  # @return [Boolean]
  def custom_primary_key?; end

  # @return [Boolean]
  def defined_for?(to_table_ord = T.unsafe(nil), to_table: T.unsafe(nil), **options); end

  def name; end
  def on_delete; end
  def on_update; end
  def primary_key; end

  private

  def default_primary_key; end
end

# Abstract representation of an index definition on a table. Instances of
# this type are typically created and returned by methods in database
# adapters. e.g. ActiveRecord::ConnectionAdapters::AbstractMysqlAdapter#indexes
class ActiveRecord::ConnectionAdapters::IndexDefinition < ::Struct; end

class ActiveRecord::ConnectionAdapters::NullColumn < ::ActiveRecord::ConnectionAdapters::Column
  # @return [NullColumn] a new instance of NullColumn
  def initialize(name); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  # @return [NullTransaction] a new instance of NullTransaction
  def initialize; end

  def add_record(record); end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def joinable?; end

  # @return [Boolean]
  def open?; end

  def state; end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition < ::Struct; end

module ActiveRecord::ConnectionAdapters::QueryCache
  def initialize(*_arg0); end

  # Enable the query cache within the block.
  def cache; end

  # Clears the query cache.
  #
  # One reason you may wish to call this method explicitly is between queries
  # that ask the database to randomize results. Otherwise the cache would see
  # the same SQL query and repeatedly return the same result each time, silently
  # undermining the randomness you were expecting.
  def clear_query_cache; end

  def disable_query_cache!; end
  def enable_query_cache!; end

  # Returns the value of attribute query_cache.
  def query_cache; end

  # Returns the value of attribute query_cache_enabled.
  def query_cache_enabled; end

  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil)); end

  # Disable the query cache within the block.
  def uncached; end

  private

  def cache_sql(sql, binds); end
  def configure_query_cache!; end

  # If arel is locked this is a SELECT ... FOR UPDATE or somesuch. Such
  # queries should not be cached.
  #
  # @return [Boolean]
  def locked?(arel); end

  class << self
    def dirties_query_cache(base, *method_names); end
    def included(base); end
  end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def initialize(*_arg0); end

  def disable_query_cache!; end
  def enable_query_cache!; end
  def query_cache_enabled; end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def fetch_type_metadata(sql_type); end

  # See docs for #type_cast_from_column
  def lookup_cast_type_from_column(column); end

  def prepare_binds_for_database(binds); end

  # Quotes the column value to help prevent
  # {SQL injection attacks}[http://en.wikipedia.org/wiki/SQL_injection].
  def quote(value, column = T.unsafe(nil)); end

  # Quotes the column name. Defaults to no quoting.
  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  # Quotes a string, escaping any ' (single quote) and \ (backslash)
  # characters.
  def quote_string(s); end

  # Quotes the table name. Defaults to column name quoting.
  def quote_table_name(table_name); end

  # Override to return the quoted table name for assignment. Defaults to
  # table quoting.
  #
  # This works for mysql2 where table.column can be used to
  # resolve ambiguity.
  #
  # We override this in the sqlite3 and postgresql adapters to use only
  # the column name (as per syntax requirements).
  def quote_table_name_for_assignment(table, attr); end

  # Quote date/time values for use in SQL input. Includes microseconds
  # if the value is a Time responding to usec.
  def quoted_date(value); end

  def quoted_false; end
  def quoted_time(value); end
  def quoted_true; end

  # Cast a +value+ to a type that the database understands. For example,
  # SQLite does not understand dates, so this method will convert a Date
  # to a String.
  def type_cast(value, column = T.unsafe(nil)); end

  # If you are having to call this function, you are likely doing something
  # wrong. The column does not have sufficient type information if the user
  # provided a custom type on the class level either explicitly (via
  # Attributes::ClassMethods#attribute) or implicitly (via
  # AttributeMethods::Serialization::ClassMethods#serialize, +time_zone_aware_attributes+).
  # In almost all cases, the sql type should only be used to change quoting behavior, when the primitive to
  # represent the type doesn't sufficiently reflect the differences
  # (varchar vs binary) for example. The type used to get this primitive
  # should have been provided before reaching the connection adapter.
  def type_cast_from_column(column, value); end

  def type_casted_binds(binds); end
  def unquoted_false; end
  def unquoted_true; end

  private

  def _quote(value); end
  def _type_cast(value); end
  def types_which_need_no_typecasting; end
end

class ActiveRecord::ConnectionAdapters::RealTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # @return [RealTransaction] a new instance of RealTransaction
  def initialize(connection, options, *args); end

  def commit; end
  def rollback; end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  # @return [ReferenceDefinition] a new instance of ReferenceDefinition
  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end

  def add_to(table); end

  protected

  # Returns the value of attribute foreign_key.
  def foreign_key; end

  # Returns the value of attribute index.
  def index; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute polymorphic.
  def polymorphic; end

  # Returns the value of attribute type.
  def type; end

  private

  def as_options(value); end
  def column_name; end
  def column_names; end
  def columns; end
  def foreign_key_options; end
  def foreign_table_name; end
  def index_options; end
  def polymorphic_options; end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # @return [SavepointTransaction] a new instance of SavepointTransaction
  def initialize(connection, savepoint_name, options, *args); end

  def commit; end

  # @return [Boolean]
  def full_rollback?; end

  def rollback; end
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name = T.unsafe(nil)); end
  def current_savepoint_name; end
  def exec_rollback_to_savepoint(name = T.unsafe(nil)); end
  def release_savepoint(name = T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  # @return [SchemaCache] a new instance of SchemaCache
  def initialize(conn); end

  # Add internal cache for table with +table_name+.
  def add(table_name); end

  # Clears out internal caches
  def clear!; end

  # Clear out internal caches for the data source +name+.
  def clear_data_source_cache!(name); end

  # Clear out internal caches for the data source +name+.
  def clear_table_cache!(*args, &block); end

  # Get the columns for a table
  def columns(table_name); end

  # Get the columns for a table as a hash, key is the column name
  # value is the column object.
  def columns_hash(table_name); end

  # Returns the value of attribute connection.
  def connection; end

  # Sets the attribute connection
  #
  # @param value the value to set the attribute connection to.
  def connection=(_arg0); end

  # A cached lookup for table existence.
  #
  # @return [Boolean]
  def data_source_exists?(name); end

  def data_sources(name); end
  def marshal_dump; end
  def marshal_load(array); end
  def primary_keys(table_name); end
  def size; end

  # A cached lookup for table existence.
  #
  # @return [Boolean]
  def table_exists?(*args, &block); end

  def tables(*args, &block); end

  # Returns the value of attribute version.
  def version; end

  private

  def initialize_dup(other); end
  def prepare_data_sources; end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable

  # Adds a reference. The reference column is an integer by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  # #add_reference and #add_belongs_to are acceptable.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:integer+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id integer column
  #
  #   add_reference(:products, :user)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns and appropriate index
  #
  #   add_reference(:products, :supplier, polymorphic: true, index: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: {to_table: :firms})
  def add_belongs_to(table_name, *args); end

  # Add a new +type+ column named +column_name+ to +table_name+.
  #
  # The +type+ parameter is normally one of the migrations native types,
  # which is one of the following:
  # <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>,
  # <tt>:integer</tt>, <tt>:bigint</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:numeric</tt>,
  # <tt>:datetime</tt>, <tt>:time</tt>, <tt>:date</tt>,
  # <tt>:binary</tt>, <tt>:boolean</tt>.
  #
  # You may use a type not in this list as long as it is supported by your
  # database (for example, "polygon" in MySQL), but this will not be database
  # agnostic and should usually be avoided.
  #
  # Available options are (none of these exists by default):
  # * <tt>:limit</tt> -
  #   Requests a maximum column length. This is number of characters for a <tt>:string</tt> column
  #   and number of bytes for <tt>:text</tt>, <tt>:binary</tt> and <tt>:integer</tt> columns.
  # * <tt>:default</tt> -
  #   The column's default value. Use nil for NULL.
  # * <tt>:null</tt> -
  #   Allows or disallows +NULL+ values in the column. This option could
  #   have been named <tt>:null_allowed</tt>.
  # * <tt>:precision</tt> -
  #   Specifies the precision for the <tt>:decimal</tt> and <tt>:numeric</tt> columns.
  # * <tt>:scale</tt> -
  #   Specifies the scale for the <tt>:decimal</tt> and <tt>:numeric</tt> columns.
  #
  # Note: The precision is the total number of significant digits
  # and the scale is the number of digits that can be stored following
  # the decimal point. For example, the number 123.45 has a precision of 5
  # and a scale of 2. A decimal with a precision of 5 and a scale of 2 can
  # range from -999.99 to 999.99.
  #
  # Please be aware of different RDBMS implementations behavior with
  # <tt>:decimal</tt> columns:
  # * The SQL standard says the default scale should be 0, <tt>:scale</tt> <=
  #   <tt>:precision</tt>, and makes no comments about the requirements of
  #   <tt>:precision</tt>.
  # * MySQL: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..30].
  #   Default is (10,0).
  # * PostgreSQL: <tt>:precision</tt> [1..infinity],
  #   <tt>:scale</tt> [0..infinity]. No default.
  # * SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>,
  #   but the maximum supported <tt>:precision</tt> is 16. No default.
  # * Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127].
  #   Default is (38,0).
  # * DB2: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..62].
  #   Default unknown.
  # * SqlServer?: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  #   Default (38,0).
  #
  # == Examples
  #
  #  add_column(:users, :picture, :binary, limit: 2.megabytes)
  #  # ALTER TABLE "users" ADD "picture" blob(2097152)
  #
  #  add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
  #  # ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL
  #
  #  add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
  #  # ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)
  #
  #  add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
  #  # ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)
  #
  #  # While :scale defaults to zero on most databases, it
  #  # probably wouldn't hurt to include it.
  #  add_column(:measurements, :huge_integer, :decimal, precision: 30)
  #  # ALTER TABLE "measurements" ADD "huge_integer" decimal(30)
  #
  #  # Defines a column with a database-specific type.
  #  add_column(:shapes, :triangle, 'polygon')
  #  # ALTER TABLE "shapes" ADD "triangle" polygon
  def add_column(table_name, column_name, type, options = T.unsafe(nil)); end

  # Adds a new foreign key. +from_table+ is the table with the key column,
  # +to_table+ contains the referenced primary key.
  #
  # The foreign key will be named after the following pattern: <tt>fk_rails_<identifier></tt>.
  # +identifier+ is a 10 character long string which is deterministically generated from the
  # +from_table+ and +column+. A custom name can be specified with the <tt>:name</tt> option.
  #
  # ====== Creating a simple foreign key
  #
  #   add_foreign_key :articles, :authors
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")
  #
  # ====== Creating a foreign key on a specific column
  #
  #   add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")
  #
  # ====== Creating a cascading foreign key
  #
  #   add_foreign_key :articles, :authors, on_delete: :cascade
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE
  #
  # The +options+ hash can include the following keys:
  # [<tt>:column</tt>]
  #   The foreign key column name on +from_table+. Defaults to <tt>to_table.singularize + "_id"</tt>
  # [<tt>:primary_key</tt>]
  #   The primary key column name on +to_table+. Defaults to +id+.
  # [<tt>:name</tt>]
  #   The constraint name. Defaults to <tt>fk_rails_<identifier></tt>.
  # [<tt>:on_delete</tt>]
  #   Action that happens <tt>ON DELETE</tt>. Valid values are +:nullify+, +:cascade+ and +:restrict+
  # [<tt>:on_update</tt>]
  #   Action that happens <tt>ON UPDATE</tt>. Valid values are +:nullify+, +:cascade+ and +:restrict+
  def add_foreign_key(from_table, to_table, options = T.unsafe(nil)); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  # The index will be named after the table and the column name(s), unless
  # you pass <tt>:name</tt> as an option.
  #
  # ====== Creating a simple index
  #
  #   add_index(:suppliers, :name)
  #
  # generates:
  #
  #   CREATE INDEX suppliers_name_index ON suppliers(name)
  #
  # ====== Creating a unique index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true)
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX accounts_branch_id_party_id_index ON accounts(branch_id, party_id)
  #
  # ====== Creating a named index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # generates:
  #
  #  CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
  #
  # ====== Creating an index with specific key length
  #
  #   add_index(:accounts, :name, name: 'by_name', length: 10)
  #
  # generates:
  #
  #   CREATE INDEX by_name ON accounts(name(10))
  #
  # ====== Creating an index with specific key lengths for multiple keys
  #
  #   add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
  #
  # generates:
  #
  #   CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
  #
  # Note: SQLite doesn't support index length.
  #
  # ====== Creating an index with a sort order (desc or asc, asc is the default)
  #
  #   add_index(:accounts, [:branch_id, :party_id, :surname], order: {branch_id: :desc, party_id: :asc})
  #
  # generates:
  #
  #   CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)
  #
  # Note: MySQL doesn't yet support index order (it accepts the syntax but ignores it).
  #
  # ====== Creating a partial index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active
  #
  # Note: Partial indexes are only supported for PostgreSQL and SQLite 3.8.0+.
  #
  # ====== Creating an index with a specific method
  #
  #   add_index(:developers, :name, using: 'btree')
  #
  # generates:
  #
  #   CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
  #   CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
  #
  # Note: only supported by PostgreSQL and MySQL
  #
  # ====== Creating an index with a specific type
  #
  #   add_index(:developers, :name, type: :fulltext)
  #
  # generates:
  #
  #   CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
  #
  # Note: only supported by MySQL.
  def add_index(table_name, column_name, options = T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  # Adds a reference. The reference column is an integer by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  # #add_reference and #add_belongs_to are acceptable.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:integer+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id integer column
  #
  #   add_reference(:products, :user)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns and appropriate index
  #
  #   add_reference(:products, :supplier, polymorphic: true, index: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: {to_table: :firms})
  def add_reference(table_name, *args); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to +table_name+.
  # Additional options (like +:null+) are forwarded to #add_column.
  #
  #   add_timestamps(:suppliers, null: true)
  def add_timestamps(table_name, options = T.unsafe(nil)); end

  def assume_migrated_upto_version(version, migrations_paths); end

  # Changes the column's definition according to the new options.
  # See TableDefinition#column for details of the options you can use.
  #
  #   change_column(:suppliers, :name, :string, limit: 80)
  #   change_column(:accounts, :description, :text)
  #
  # @raise [NotImplementedError]
  def change_column(table_name, column_name, type, options = T.unsafe(nil)); end

  # Changes the comment for a column or removes it if +nil+.
  #
  # @raise [NotImplementedError]
  def change_column_comment(table_name, column_name, comment); end

  # Sets a new default value for a column:
  #
  #   change_column_default(:suppliers, :qualification, 'new')
  #   change_column_default(:accounts, :authorized, 1)
  #
  # Setting the default to +nil+ effectively drops the default:
  #
  #   change_column_default(:users, :email, nil)
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_column_default(:posts, :state, from: nil, to: "draft")
  #
  # @raise [NotImplementedError]
  def change_column_default(table_name, column_name, default_or_changes); end

  # Sets or removes a <tt>NOT NULL</tt> constraint on a column. The +null+ flag
  # indicates whether the value can be +NULL+. For example
  #
  #   change_column_null(:users, :nickname, false)
  #
  # says nicknames cannot be +NULL+ (adds the constraint), whereas
  #
  #   change_column_null(:users, :nickname, true)
  #
  # allows them to be +NULL+ (drops the constraint).
  #
  # The method accepts an optional fourth argument to replace existing
  # <tt>NULL</tt>s with some other value. Use that one when enabling the
  # constraint if needed, since otherwise those rows would not be valid.
  #
  # Please note the fourth argument does not set a column's default.
  #
  # @raise [NotImplementedError]
  def change_column_null(table_name, column_name, null, default = T.unsafe(nil)); end

  # A block for changing columns in +table+.
  #
  #   # change_table() yields a Table instance
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other column alterations here
  #   end
  #
  # The +options+ hash can include the following keys:
  # [<tt>:bulk</tt>]
  #   Set this to true to make this a bulk alter query, such as
  #
  #     ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...
  #
  #   Defaults to false.
  #
  # ====== Add a column
  #
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #   end
  #
  # ====== Add 2 integer columns
  #
  #   change_table(:suppliers) do |t|
  #     t.integer :width, :height, null: false, default: 0
  #   end
  #
  # ====== Add created_at/updated_at columns
  #
  #   change_table(:suppliers) do |t|
  #     t.timestamps
  #   end
  #
  # ====== Add a foreign key column
  #
  #   change_table(:suppliers) do |t|
  #     t.references :company
  #   end
  #
  # Creates a <tt>company_id(integer)</tt> column.
  #
  # ====== Add a polymorphic foreign key column
  #
  #  change_table(:suppliers) do |t|
  #    t.belongs_to :company, polymorphic: true
  #  end
  #
  # Creates <tt>company_type(varchar)</tt> and <tt>company_id(integer)</tt> columns.
  #
  # ====== Remove a column
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company
  #  end
  #
  # ====== Remove several columns
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company_id
  #    t.remove :width, :height
  #  end
  #
  # ====== Remove an index
  #
  #  change_table(:suppliers) do |t|
  #    t.remove_index :company_id
  #  end
  #
  # See also Table for details on all of the various column transformation.
  def change_table(table_name, options = T.unsafe(nil)); end

  # Changes the comment for a table or removes it if +nil+.
  #
  # @raise [NotImplementedError]
  def change_table_comment(table_name, comment); end

  # Checks to see if a column exists in a given table.
  #
  #   # Check a column exists
  #   column_exists?(:suppliers, :name)
  #
  #   # Check a column exists of a particular type
  #   column_exists?(:suppliers, :name, :string)
  #
  #   # Check a column exists with a specific definition
  #   column_exists?(:suppliers, :name, :string, limit: 100)
  #   column_exists?(:suppliers, :name, :string, default: 'default')
  #   column_exists?(:suppliers, :name, :string, null: false)
  #   column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
  #
  # @return [Boolean]
  def column_exists?(table_name, column_name, type = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns an array of Column objects for the table specified by +table_name+.
  # See the concrete implementation for details on the expected parameter values.
  #
  # @raise [NotImplementedError]
  def columns(table_name); end

  # Given a set of columns and an ORDER BY clause, returns the columns for a SELECT DISTINCT.
  # PostgreSQL, MySQL, and Oracle overrides this for custom DISTINCT syntax - they
  # require the order columns appear in the SELECT.
  #
  #   columns_for_distinct("posts.id", ["posts.created_at desc"])
  def columns_for_distinct(columns, orders); end

  # Creates a new join table with the name created using the lexical order of the first two
  # arguments. These arguments can be a String or a Symbol.
  #
  #   # Creates a table called 'assemblies_parts' with no id.
  #   create_join_table(:assemblies, :parts)
  #
  # You can pass a +options+ hash can include the following keys:
  # [<tt>:table_name</tt>]
  #   Sets the table name overriding the default
  # [<tt>:column_options</tt>]
  #   Any extra options you want appended to the columns definition.
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Defaults to false.
  #
  # Note that #create_join_table does not create any indices by default; you can use
  # its block form to do so yourself:
  #
  #   create_join_table :products, :categories do |t|
  #     t.index :product_id
  #     t.index :category_id
  #   end
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
  #
  # generates:
  #
  #   CREATE TABLE assemblies_parts (
  #     assembly_id int NOT NULL,
  #     part_id int NOT NULL,
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8
  def create_join_table(table_1, table_2, options = T.unsafe(nil)); end

  # Creates a new table with the name +table_name+. +table_name+ may either
  # be a String or a Symbol.
  #
  # There are two ways to work with #create_table. You can use the block
  # form or the regular form, like this:
  #
  # === Block form
  #
  #   # create_table() passes a TableDefinition object to the block.
  #   # This form will not only create the table, but also columns for the
  #   # table.
  #
  #   create_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other fields here
  #   end
  #
  # === Block form, with shorthand
  #
  #   # You can also use the column types as method calls, rather than calling the column method.
  #   create_table(:suppliers) do |t|
  #     t.string :name, limit: 60
  #     # Other fields here
  #   end
  #
  # === Regular form
  #
  #   # Creates a table called 'suppliers' with no columns.
  #   create_table(:suppliers)
  #   # Add a column to 'suppliers'.
  #   add_column(:suppliers, :name, :string, {limit: 60})
  #
  # The +options+ hash can include the following keys:
  # [<tt>:id</tt>]
  #   Whether to automatically add a primary key column. Defaults to true.
  #   Join tables for {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many] should set it to false.
  #
  #   A Symbol can be used to specify the type of the generated primary key column.
  # [<tt>:primary_key</tt>]
  #   The name of the primary key, if one is to be added automatically.
  #   Defaults to +id+. If <tt>:id</tt> is false this option is ignored.
  #
  #   Note that Active Record models will automatically detect their
  #   primary key. This can be avoided by using
  #   {self.primary_key=}[rdoc-ref:AttributeMethods::PrimaryKey::ClassMethods#primary_key=] on the model
  #   to define the key explicitly.
  #
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:as</tt>]
  #   SQL to use to generate the table. When this option is used, the block is
  #   ignored, as are the <tt>:id</tt> and <tt>:primary_key</tt> options.
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
  #
  # generates:
  #
  #   CREATE TABLE suppliers (
  #     id int auto_increment PRIMARY KEY
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8
  #
  # ====== Rename the primary key column
  #
  #   create_table(:objects, primary_key: 'guid') do |t|
  #     t.column :name, :string, limit: 80
  #   end
  #
  # generates:
  #
  #   CREATE TABLE objects (
  #     guid int auto_increment PRIMARY KEY,
  #     name varchar(80)
  #   )
  #
  # ====== Change the primary key column type
  #
  #   create_table(:tags, id: :string) do |t|
  #     t.column :label, :string
  #   end
  #
  # generates:
  #
  #   CREATE TABLE tags (
  #     id varchar PRIMARY KEY,
  #     label varchar
  #   )
  #
  # ====== Do not add a primary key column
  #
  #   create_table(:categories_suppliers, id: false) do |t|
  #     t.column :category_id, :integer
  #     t.column :supplier_id, :integer
  #   end
  #
  # generates:
  #
  #   CREATE TABLE categories_suppliers (
  #     category_id int,
  #     supplier_id int
  #   )
  #
  # ====== Create a temporary table based on a query
  #
  #   create_table(:long_query, temporary: true,
  #     as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
  #
  # generates:
  #
  #   CREATE TEMPORARY TABLE long_query AS
  #     SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id
  #
  # See also TableDefinition#column for details on how to create columns.
  #
  # @yield [td]
  def create_table(table_name, comment: T.unsafe(nil), **options); end

  # Checks to see if the data source +name+ exists on the database.
  #
  #   data_source_exists?(:ebooks)
  #
  # @return [Boolean]
  def data_source_exists?(name); end

  # Returns the relation names useable to back Active Record models.
  # For most adapters this means all #tables and #views.
  def data_sources; end

  # Drops the join table specified by the given arguments.
  # See #create_join_table for details.
  #
  # Although this command ignores the block if one is given, it can be helpful
  # to provide one in a migration's +change+ method so it can be reverted.
  # In that case, the block will be used by #create_join_table.
  def drop_join_table(table_1, table_2, options = T.unsafe(nil)); end

  # Drops a table from the database.
  #
  # [<tt>:force</tt>]
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:if_exists</tt>]
  #   Set to +true+ to only drop the table if it exists.
  #   Defaults to false.
  #
  # Although this command ignores most +options+ and the block if one is given,
  # it can be helpful to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +options+ and the block will be used by #create_table.
  def drop_table(table_name, options = T.unsafe(nil)); end

  def dump_schema_information; end
  def foreign_key_column_for(table_name); end

  # Checks to see if a foreign key exists on a table for a given foreign key definition.
  #
  #   # Check a foreign key exists
  #   foreign_key_exists?(:accounts, :branches)
  #
  #   # Check a foreign key on a specified column exists
  #   foreign_key_exists?(:accounts, column: :owner_id)
  #
  #   # Check a foreign key with a custom name exists
  #   foreign_key_exists?(:accounts, name: "special_fk_name")
  #
  # @return [Boolean]
  def foreign_key_exists?(from_table, options_or_to_table = T.unsafe(nil)); end

  def foreign_key_for(from_table, options_or_to_table = T.unsafe(nil)); end
  def foreign_key_for!(from_table, options_or_to_table = T.unsafe(nil)); end
  def foreign_key_options(from_table, to_table, options); end

  # Returns an array of foreign keys for the given table.
  # The foreign keys are represented as ForeignKeyDefinition objects.
  #
  # @raise [NotImplementedError]
  def foreign_keys(table_name); end

  # Checks to see if an index exists on a table for a given index definition.
  #
  #   # Check an index exists
  #   index_exists?(:suppliers, :company_id)
  #
  #   # Check an index on multiple columns exists
  #   index_exists?(:suppliers, [:company_id, :company_type])
  #
  #   # Check a unique index exists
  #   index_exists?(:suppliers, :company_id, unique: true)
  #
  #   # Check an index with a custom name exists
  #   index_exists?(:suppliers, :company_id, name: "idx_company_id")
  #
  # @return [Boolean]
  def index_exists?(table_name, column_name, options = T.unsafe(nil)); end

  def index_name(table_name, options); end

  # Verifies the existence of an index with a given name.
  #
  # The default argument is returned if the underlying implementation does not define the indexes method,
  # as there's no way to determine the correct answer in that case.
  #
  # @return [Boolean]
  def index_name_exists?(table_name, index_name, default); end

  def initialize_internal_metadata_table; end

  # Should not be called normally, but this operation is non-destructive.
  # The migrations module handles this automatically.
  def initialize_schema_migrations_table; end

  def insert_versions_sql(versions); end
  def internal_string_options_for_primary_key; end

  # Returns a hash of mappings from the abstract data types to the native
  # database types. See TableDefinition#column for details on the recognized
  # abstract data types.
  def native_database_types; end

  # @return [Boolean]
  def options_include_default?(options); end

  # Returns just a table's primary key
  def primary_key(table_name); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  # #remove_reference and #remove_belongs_to are acceptable.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: true)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, index: true, foreign_key: true)
  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the column from the table definition.
  #
  #   remove_column(:suppliers, :qualification)
  #
  # The +type+ and +options+ parameters will be ignored if present. It can be helpful
  # to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +type+ and +options+ will be used by add_column.
  def remove_column(table_name, column_name, type = T.unsafe(nil), options = T.unsafe(nil)); end

  # Removes the given columns from the table definition.
  #
  #   remove_columns(:suppliers, :qualification, :experience)
  #
  # @raise [ArgumentError]
  def remove_columns(table_name, *column_names); end

  # Removes the given foreign key from the table. Any option parameters provided
  # will be used to re-add the foreign key in case of a migration rollback.
  # It is recommended that you provide any options used when creating the foreign
  # key so that the migration can be reverted properly.
  #
  # Removes the foreign key on +accounts.branch_id+.
  #
  #   remove_foreign_key :accounts, :branches
  #
  # Removes the foreign key on +accounts.owner_id+.
  #
  #   remove_foreign_key :accounts, column: :owner_id
  #
  # Removes the foreign key named +special_fk_name+ on the +accounts+ table.
  #
  #   remove_foreign_key :accounts, name: :special_fk_name
  #
  # The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key.
  def remove_foreign_key(from_table, options_or_to_table = T.unsafe(nil)); end

  # Removes the given index from the table.
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, :branch_id
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: :branch_id
  #
  # Removes the index on +branch_id+ and +party_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: [:branch_id, :party_id]
  #
  # Removes the index named +by_branch_party+ in the +accounts+ table.
  #
  #   remove_index :accounts, name: :by_branch_party
  def remove_index(table_name, options = T.unsafe(nil)); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  # #remove_reference and #remove_belongs_to are acceptable.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: true)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, index: true, foreign_key: true)
  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table definition.
  #
  #  remove_timestamps(:suppliers)
  def remove_timestamps(table_name, options = T.unsafe(nil)); end

  # Renames a column.
  #
  #   rename_column(:suppliers, :description, :name)
  #
  # @raise [NotImplementedError]
  def rename_column(table_name, column_name, new_column_name); end

  # Renames an index.
  #
  # Rename the +index_people_on_last_name+ index to +index_users_on_last_name+:
  #
  #   rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
  def rename_index(table_name, old_name, new_name); end

  # Renames a table.
  #
  #   rename_table('octopuses', 'octopi')
  #
  # @raise [NotImplementedError]
  def rename_table(table_name, new_name); end

  # Truncates a table alias according to the limits of the current adapter.
  def table_alias_for(table_name); end

  # Returns the table comment that's stored in database metadata.
  def table_comment(table_name); end

  # Checks to see if the table +table_name+ exists on the database.
  #
  #   table_exists?(:developers)
  #
  # @return [Boolean]
  def table_exists?(table_name); end

  def table_options(table_name); end

  # Returns an array of table names defined in the database.
  #
  # @raise [NotImplementedError]
  def tables(name = T.unsafe(nil)); end

  def type_to_sql(type, limit = T.unsafe(nil), precision = T.unsafe(nil), scale = T.unsafe(nil)); end
  def update_table_definition(table_name, base); end

  # Checks to see if the view +view_name+ exists on the database.
  #
  #   view_exists?(:ebooks)
  #
  # @return [Boolean]
  def view_exists?(view_name); end

  # Returns an array of view names defined in the database.
  #
  # @raise [NotImplementedError]
  def views; end

  protected

  def add_index_sort_order(quoted_columns, **options); end

  # Overridden by the MySQL adapter for supporting index lengths
  def add_options_for_index_columns(quoted_columns, **options); end

  # @raise [ArgumentError]
  def index_name_for_remove(table_name, options = T.unsafe(nil)); end

  def quoted_columns_for_index(column_names, **options); end
  def rename_column_indexes(table_name, column_name, new_column_name); end
  def rename_table_indexes(table_name, new_name); end

  private

  # @return [Boolean]
  def can_remove_index_by_name?(options); end

  def create_alter_table(name); end
  def create_table_definition(*args); end
  def extract_new_default_value(default_or_changes); end
  def foreign_key_name(table_name, options); end
  def index_column_names(column_names); end
  def index_name_options(column_names); end
  def validate_index_length!(table_name, new_name); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  # @return [SqlTypeMetadata] a new instance of SqlTypeMetadata
  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def hash; end

  # Returns the value of attribute limit.
  def limit; end

  # Returns the value of attribute precision.
  def precision; end

  # Returns the value of attribute scale.
  def scale; end

  # Returns the value of attribute sql_type.
  def sql_type; end

  # Returns the value of attribute type.
  def type; end

  protected

  def attributes_for_hash; end
end

# Represents an SQL table in an abstract way for updating a table.
# Also see TableDefinition and {connection.create_table}[rdoc-ref:SchemaStatements#create_table]
#
# Available transformations are:
#
#   change_table :table do |t|
#     t.primary_key
#     t.column
#     t.index
#     t.rename_index
#     t.timestamps
#     t.change
#     t.change_default
#     t.rename
#     t.references
#     t.belongs_to
#     t.string
#     t.text
#     t.integer
#     t.bigint
#     t.float
#     t.decimal
#     t.numeric
#     t.datetime
#     t.timestamp
#     t.time
#     t.date
#     t.binary
#     t.boolean
#     t.remove
#     t.remove_references
#     t.remove_belongs_to
#     t.remove_index
#     t.remove_timestamps
#   end
class ActiveRecord::ConnectionAdapters::Table
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods

  # @return [Table] a new instance of Table
  def initialize(table_name, base); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def belongs_to(*args); end

  # Changes the column's definition according to the new options.
  #
  #  t.change(:name, :string, limit: 80)
  #  t.change(:description, :text)
  #
  # See TableDefinition#column for details of the options you can use.
  def change(column_name, type, options = T.unsafe(nil)); end

  # Sets a new default value for a column.
  #
  #  t.change_default(:qualification, 'new')
  #  t.change_default(:authorized, 1)
  #  t.change_default(:status, from: nil, to: "draft")
  #
  # See {connection.change_column_default}[rdoc-ref:SchemaStatements#change_column_default]
  def change_default(column_name, default_or_changes); end

  # Adds a new column to the named table.
  #
  #  t.column(:name, :string)
  #
  # See TableDefinition#column for details of the options you can use.
  def column(column_name, type, options = T.unsafe(nil)); end

  # Checks to see if a column exists.
  #
  # t.string(:name) unless t.column_exists?(:name, :string)
  #
  # See {connection.column_exists?}[rdoc-ref:SchemaStatements#column_exists?]
  #
  # @return [Boolean]
  def column_exists?(column_name, type = T.unsafe(nil), options = T.unsafe(nil)); end

  # Adds a foreign key.
  #
  # t.foreign_key(:authors)
  #
  # See {connection.add_foreign_key}[rdoc-ref:SchemaStatements#add_foreign_key]
  def foreign_key(*args); end

  # Checks to see if a foreign key exists.
  #
  # t.foreign_key(:authors) unless t.foreign_key_exists?(:authors)
  #
  # See {connection.foreign_key_exists?}[rdoc-ref:SchemaStatements#foreign_key_exists?]
  #
  # @return [Boolean]
  def foreign_key_exists?(*args); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  #  t.index(:name)
  #  t.index([:branch_id, :party_id], unique: true)
  #  t.index([:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # See {connection.add_index}[rdoc-ref:SchemaStatements#add_index] for details of the options you can use.
  def index(column_name, options = T.unsafe(nil)); end

  # Checks to see if an index exists.
  #
  # unless t.index_exists?(:branch_id)
  #   t.index(:branch_id)
  # end
  #
  # See {connection.index_exists?}[rdoc-ref:SchemaStatements#index_exists?]
  #
  # @return [Boolean]
  def index_exists?(column_name, options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  def name; end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def references(*args); end

  # Removes the column(s) from the table definition.
  #
  #  t.remove(:qualification)
  #  t.remove(:qualification, :experience)
  #
  # See {connection.remove_columns}[rdoc-ref:SchemaStatements#remove_columns]
  def remove(*column_names); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  def remove_belongs_to(*args); end

  # Removes the given index from the table.
  #
  #   t.remove_index(:branch_id)
  #   t.remove_index(column: [:branch_id, :party_id])
  #   t.remove_index(name: :by_branch_party)
  #
  # See {connection.remove_index}[rdoc-ref:SchemaStatements#remove_index]
  def remove_index(options = T.unsafe(nil)); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  def remove_references(*args); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table.
  #
  #  t.remove_timestamps
  #
  # See {connection.remove_timestamps}[rdoc-ref:SchemaStatements#remove_timestamps]
  def remove_timestamps(options = T.unsafe(nil)); end

  # Renames a column.
  #
  #  t.rename(:description, :name)
  #
  # See {connection.rename_column}[rdoc-ref:SchemaStatements#rename_column]
  def rename(column_name, new_column_name); end

  # Renames the given index on the table.
  #
  #  t.rename_index(:user_id, :account_id)
  #
  # See {connection.rename_index}[rdoc-ref:SchemaStatements#rename_index]
  def rename_index(index_name, new_index_name); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to the table.
  #
  #  t.timestamps(null: false)
  #
  # See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  def timestamps(options = T.unsafe(nil)); end
end

# Represents the schema of an SQL table in an abstract way. This class
# provides methods for manipulating the schema representation.
#
# Inside migration files, the +t+ object in {create_table}[rdoc-ref:SchemaStatements#create_table]
# is actually of this type:
#
#   class SomeMigration < ActiveRecord::Migration[5.0]
#     def up
#       create_table :foo do |t|
#         puts t.class  # => "ActiveRecord::ConnectionAdapters::TableDefinition"
#       end
#     end
#
#     def down
#       ...
#     end
#   end
class ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods

  # @return [TableDefinition] a new instance of TableDefinition
  def initialize(name, temporary = T.unsafe(nil), options = T.unsafe(nil), as = T.unsafe(nil), comment: T.unsafe(nil)); end

  # Returns a ColumnDefinition for the column with name +name+.
  def [](name); end

  # Returns the value of attribute as.
  def as; end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def belongs_to(*args, **options); end

  # Instantiates a new column for the table.
  # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]
  # for available options.
  #
  # Additional options are:
  # * <tt>:index</tt> -
  #   Create an index for the column. Can be either <tt>true</tt> or an options hash.
  #
  # This method returns <tt>self</tt>.
  #
  # == Examples
  #
  #  # Assuming +td+ is an instance of TableDefinition
  #  td.column(:granted, :boolean, index: true)
  #
  # == Short-hand examples
  #
  # Instead of calling #column directly, you can also work with the short-hand definitions for the default types.
  # They use the type as the method name instead of as a parameter and allow for multiple columns to be defined
  # in a single statement.
  #
  # What can be written like this with the regular calls to column:
  #
  #   create_table :products do |t|
  #     t.column :shop_id,     :integer
  #     t.column :creator_id,  :integer
  #     t.column :item_number, :string
  #     t.column :name,        :string, default: "Untitled"
  #     t.column :value,       :string, default: "Untitled"
  #     t.column :created_at,  :datetime
  #     t.column :updated_at,  :datetime
  #   end
  #   add_index :products, :item_number
  #
  # can also be written as follows using the short-hand:
  #
  #   create_table :products do |t|
  #     t.integer :shop_id, :creator_id
  #     t.string  :item_number, index: true
  #     t.string  :name, :value, default: "Untitled"
  #     t.timestamps null: false
  #   end
  #
  # There's a short-hand method for each of the type values declared at the top. And then there's
  # TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.
  #
  # TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type
  # column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of
  # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option
  # will also create an index, similar to calling {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # So what can be written like this:
  #
  #   create_table :taggings do |t|
  #     t.integer :tag_id, :tagger_id, :taggable_id
  #     t.string  :tagger_type
  #     t.string  :taggable_type, default: 'Photo'
  #   end
  #   add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'
  #   add_index :taggings, [:tagger_id, :tagger_type]
  #
  # Can also be written as follows using references:
  #
  #   create_table :taggings do |t|
  #     t.references :tag, index: { name: 'index_taggings_on_tag_id' }
  #     t.references :tagger, polymorphic: true, index: true
  #     t.references :taggable, polymorphic: { default: 'Photo' }
  #   end
  def column(name, type, options = T.unsafe(nil)); end

  # Returns an array of ColumnDefinition objects for the columns of the table.
  def columns; end

  # Returns the value of attribute comment.
  def comment; end

  def foreign_key(table_name, options = T.unsafe(nil)); end

  # Returns the value of attribute foreign_keys.
  def foreign_keys; end

  # Adds index options to the indexes hash, keyed by column name
  # This is primarily used to track indexes that need to be created after the table
  #
  #   index(:account_id, name: 'index_projects_on_account_id')
  def index(column_name, options = T.unsafe(nil)); end

  # Returns the value of attribute indexes.
  def indexes; end

  # Sets the attribute indexes
  #
  # @param value the value to set the attribute indexes to.
  def indexes=(_arg0); end

  # Returns the value of attribute name.
  def name; end

  def new_column_definition(name, type, options); end

  # Returns the value of attribute options.
  def options; end

  def primary_keys(name = T.unsafe(nil)); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  def references(*args, **options); end

  # remove the column +name+ from the table.
  #   remove_column(:account_id)
  def remove_column(name); end

  # Returns the value of attribute temporary.
  def temporary; end

  # Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and
  # <tt>:updated_at</tt> to the table. See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  #
  #   t.timestamps null: false
  def timestamps(*args); end

  private

  def aliased_types(name, fallback); end
  def create_column_definition(name, type); end
end

class ActiveRecord::ConnectionAdapters::Transaction
  # @return [Transaction] a new instance of Transaction
  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def add_record(record); end
  def before_commit_records; end

  # @return [Boolean]
  def closed?; end

  def commit; end
  def commit_records; end

  # Returns the value of attribute connection.
  def connection; end

  # @return [Boolean]
  def full_rollback?; end

  # Sets the attribute joinable
  #
  # @param value the value to set the attribute joinable to.
  def joinable=(_arg0); end

  # @return [Boolean]
  def joinable?; end

  # @return [Boolean]
  def open?; end

  # Returns the value of attribute records.
  def records; end

  def rollback; end
  def rollback_records; end

  # Returns the value of attribute savepoint_name.
  def savepoint_name; end

  # Returns the value of attribute state.
  def state; end
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  # @return [TransactionManager] a new instance of TransactionManager
  def initialize(connection); end

  def begin_transaction(options = T.unsafe(nil)); end
  def commit_transaction; end
  def current_transaction; end
  def open_transactions; end
  def rollback_transaction(transaction = T.unsafe(nil)); end
  def within_new_transaction(options = T.unsafe(nil)); end

  private

  # Deallocate invalidated prepared statements outside of the transaction
  def after_failure_actions(transaction, error); end
end

ActiveRecord::ConnectionAdapters::TransactionManager::NULL_TRANSACTION = T.let(T.unsafe(nil), ActiveRecord::ConnectionAdapters::NullTransaction)

class ActiveRecord::ConnectionAdapters::TransactionState
  # @return [TransactionState] a new instance of TransactionState
  def initialize(state = T.unsafe(nil)); end

  # @return [Boolean]
  def committed?; end

  # @return [Boolean]
  def completed?; end

  # @return [Boolean]
  def finalized?; end

  # @return [Boolean]
  def rolledback?; end

  def set_state(state); end
end

ActiveRecord::ConnectionAdapters::TransactionState::VALID_STATES = T.let(T.unsafe(nil), Set)

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end
  def clear_all_connections!(*args, &block); end
  def clear_cache!; end
  def clear_reloadable_connections!(*args, &block); end

  # Returns +true+ if Active Record is connected.
  #
  # @return [Boolean]
  def connected?; end

  # Returns the connection currently associated with the class. This can
  # also be used to "borrow" the connection to do database work unrelated
  # to any of the specific Active Records.
  def connection; end

  # Returns the configuration of the associated connection as a hash:
  #
  #  ActiveRecord::Base.connection_config
  #  # => {pool: 5, timeout: 5000, database: "db/development.sqlite3", adapter: "sqlite3"}
  #
  # Please use only for reading.
  def connection_config; end

  def connection_id; end
  def connection_id=(connection_id); end
  def connection_pool; end

  # Return the specification id from this class otherwise look it up
  # in the parent.
  def connection_specification_name; end

  # Sets the attribute connection_specification_name
  #
  # @param value the value to set the attribute connection_specification_name to.
  def connection_specification_name=(_arg0); end

  # Establishes the connection to the database. Accepts a hash as input where
  # the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case)
  # example for regular databases (MySQL, PostgreSQL, etc):
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "mysql2",
  #     host:     "localhost",
  #     username: "myuser",
  #     password: "mypass",
  #     database: "somedatabase"
  #   )
  #
  # Example for SQLite database:
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "sqlite3",
  #     database: "path/to/dbfile"
  #   )
  #
  # Also accepts keys as strings (for parsing from YAML for example):
  #
  #   ActiveRecord::Base.establish_connection(
  #     "adapter"  => "sqlite3",
  #     "database" => "path/to/dbfile"
  #   )
  #
  # Or a URL:
  #
  #   ActiveRecord::Base.establish_connection(
  #     "postgres://myuser:mypass@localhost/somedatabase"
  #   )
  #
  # In case {ActiveRecord::Base.configurations}[rdoc-ref:Core.configurations]
  # is set (Rails automatically loads the contents of config/database.yml into it),
  # a symbol can also be given as argument, representing a key in the
  # configuration hash:
  #
  #   ActiveRecord::Base.establish_connection(:production)
  #
  # The exceptions AdapterNotSpecified, AdapterNotFound and +ArgumentError+
  # may be returned on an error.
  #
  # @raise [RuntimeError]
  def establish_connection(spec = T.unsafe(nil)); end

  def remove_connection(name = T.unsafe(nil)); end
  def retrieve_connection; end
end

ActiveRecord::ConnectionHandling::DEFAULT_ENV = T.let(T.unsafe(nil), Proc)

class ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig
  # @return [MergeAndResolveDefaultUrlConfig] a new instance of MergeAndResolveDefaultUrlConfig
  def initialize(raw_configurations); end

  # Returns fully resolved connection hashes.
  # Merges connection information from `ENV['DATABASE_URL']` if available.
  def resolve; end

  private

  def config; end
end

ActiveRecord::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

# Raised when connection to the database could not been established (for example when
# {ActiveRecord::Base.connection=}[rdoc-ref:ConnectionHandling#connection]
# is given a nil object).
class ActiveRecord::ConnectionNotEstablished < ::ActiveRecord::ActiveRecordError; end

# Raised when a connection could not be obtained within the connection
# acquisition timeout period: because max connections in pool
# are in use.
class ActiveRecord::ConnectionTimeoutError < ::ActiveRecord::ConnectionNotEstablished; end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Core::ClassMethods

  # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
  # attributes but not yet saved (pass a hash with key names matching the associated table column names).
  # In both instances, valid attribute keys are determined by the column names of the associated table --
  # hence you can't have attributes that aren't part of the table columns.
  #
  # ==== Example:
  #   # Instantiates a single new object
  #   User.new(first_name: 'Jamie')
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  def initialize(attributes = T.unsafe(nil)); end

  # Allows sort on objects
  def <=>(other_object); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  def ==(comparison_object); end

  def connection_handler; end

  # Populate +coder+ with attributes about this record that should be
  # serialized. The structure of +coder+ defined in this method is
  # guaranteed to match the structure of +coder+ passed to the #init_with
  # method.
  #
  # Example:
  #
  #   class Post < ActiveRecord::Base
  #   end
  #   coder = {}
  #   Post.new.encode_with(coder)
  #   coder # => {"attributes" => {"id" => nil, ... }}
  def encode_with(coder); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  def eql?(comparison_object); end

  # Clone and freeze the attributes hash such that associations are still
  # accessible, even on destroyed records, but cloned models will not be
  # frozen.
  def freeze; end

  # Returns +true+ if the attributes hash has been frozen.
  #
  # @return [Boolean]
  def frozen?; end

  # Delegates to id in order to allow two records of the same type and id to work with something like:
  #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  def hash; end

  # Initialize an empty model object from +coder+. +coder+ should be
  # the result of previously encoding an Active Record model, using
  # #encode_with.
  #
  #   class Post < ActiveRecord::Base
  #   end
  #
  #   old_post = Post.new(title: "hello world")
  #   coder = {}
  #   old_post.encode_with(coder)
  #
  #   post = Post.allocate
  #   post.init_with(coder)
  #   post.title # => 'hello world'
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  def init_with(coder); end

  # Returns the contents of the record as a nicely formatted string.
  def inspect; end

  # Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt>
  # when pp is required.
  def pretty_print(pp); end

  # Marks this record as read only.
  def readonly!; end

  # Returns +true+ if the record is read only. Records loaded through joins with piggy-back
  # attributes will be marked as read only since they cannot be saved.
  #
  # @return [Boolean]
  def readonly?; end

  # Returns a hash of the given methods with their names as keys and returned values as values.
  def slice(*methods); end

  private

  # @return [Boolean]
  def custom_inspect_method_defined?; end

  def init_internals; end
  def initialize_dup(other); end
  def initialize_internals_callback; end
  def thaw; end

  # Under Ruby 1.9, Array#flatten will call #to_ary (recursively) on each of the elements
  # of the array, and then rescues from the possible NoMethodError. If those elements are
  # ActiveRecord::Base's, then this triggers the various method_missing's that we have,
  # which significantly impacts upon performance.
  #
  # So we can avoid the method_missing hit by explicitly defining #to_ary as nil here.
  #
  # See also http://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
  def to_ary; end

  module GeneratedClassMethods
    def default_connection_handler; end
    def default_connection_handler=(value); end
    def default_connection_handler?; end
  end

  module GeneratedInstanceMethods
    def default_connection_handler; end
    def default_connection_handler?; end
  end
end

module ActiveRecord::Core::ClassMethods
  # Overwrite the default class equality method to provide support for association proxies.
  def ===(object); end

  def allocate; end
  def arel_attribute(name, table = T.unsafe(nil)); end

  # Returns the Arel engine.
  def arel_engine; end

  # Returns an instance of <tt>Arel::Table</tt> loaded with the current table name.
  #
  #   class Post < ActiveRecord::Base
  #     scope :published_and_commented, -> { published.and(self.arel_table[:comments_count].gt(0)) }
  #   end
  def arel_table; end

  def find(*ids); end
  def find_by(*args); end
  def find_by!(*args); end
  def generated_association_methods; end
  def inherited(child_class); end
  def initialize_find_by_cache; end
  def initialize_generated_modules; end

  # Returns a string like 'Post(id:integer, title:string, body:text)'
  def inspect; end

  def predicate_builder; end
  def type_caster; end

  private

  def cached_find_by_statement(key, &block); end
  def relation; end
  def table_metadata; end
end

# = Active Record Counter Cache
module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::CounterCache::ClassMethods

  private

  def _create_record(*_arg0); end
  def destroy_row; end
  def each_counter_cached_associations; end
end

module ActiveRecord::CounterCache::ClassMethods
  # Decrement a numeric field by one, via a direct SQL update.
  #
  # This works the same as #increment_counter but reduces the column value by
  # 1 instead of increasing it.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be decremented.
  # * +id+ - The id of the object that should be decremented or an array of ids.
  #
  # ==== Examples
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   DiscussionBoard.decrement_counter(:posts_count, 5)
  def decrement_counter(counter_name, id); end

  # Increment a numeric field by one, via a direct SQL update.
  #
  # This method is used primarily for maintaining counter_cache columns that are
  # used to store aggregate values. For example, a +DiscussionBoard+ may cache
  # posts_count and comments_count to avoid running an SQL query to calculate the
  # number of posts and comments there are, each time it is displayed.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be incremented.
  # * +id+ - The id of the object that should be incremented or an array of ids.
  #
  # ==== Examples
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   DiscussionBoard.increment_counter(:posts_count, 5)
  def increment_counter(counter_name, id); end

  # Resets one or more counter caches to their correct value using an SQL
  # count query. This is useful when adding new counter caches, or if the
  # counter has been corrupted or modified directly by SQL.
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to reset a counter on.
  # * +counters+ - One or more association counters to reset. Association name or counter name can be given.
  #
  # ==== Examples
  #
  #   # For Post with id #1 records reset the comments_count
  #   Post.reset_counters(1, :comments)
  def reset_counters(id, *counters); end

  # A generic "counter updater" implementation, intended primarily to be
  # used by #increment_counter and #decrement_counter, but which may also
  # be useful on its own. It simply does a direct SQL update for the record
  # with the given ID, altering the given hash of counters by the amount
  # given by the corresponding value:
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to update a counter on or an array of ids.
  # * +counters+ - A Hash containing the names of the fields
  #   to update as keys and the amount to update the field by as values.
  #
  # ==== Examples
  #
  #   # For the Post with id of 5, decrement the comment_count by 1, and
  #   # increment the action_count by 1
  #   Post.update_counters 5, comment_count: -1, action_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comment_count = COALESCE(comment_count, 0) - 1,
  #   #        action_count = COALESCE(action_count, 0) + 1
  #   #  WHERE id = 5
  #
  #   # For the Posts with id of 10 and 15, increment the comment_count by 1
  #   Post.update_counters [10, 15], comment_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comment_count = COALESCE(comment_count, 0) + 1
  #   #  WHERE id IN (10, 15)
  def update_counters(id, counters); end
end

# Raised when attribute has a name reserved by Active Record (when attribute
# has name of one of Active Record instance methods).
class ActiveRecord::DangerousAttributeError < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassMethods

  def &(*args, &block); end
  def +(*args, &block); end
  def -(*args, &block); end
  def [](*args, &block); end
  def all?(*args, &block); end
  def collect(*args, &block); end
  def columns_hash(*args, &block); end
  def compact(*args, &block); end
  def connection(*args, &block); end
  def each(*args, &block); end
  def encode_with(*args, &block); end
  def in_groups(*args, &block); end
  def in_groups_of(*args, &block); end
  def include?(*args, &block); end
  def index(*args, &block); end
  def join(*args, &block); end
  def length(*args, &block); end
  def map(*args, &block); end
  def primary_key(*args, &block); end
  def quoted_primary_key(*args, &block); end
  def quoted_table_name(*args, &block); end

  # @return [Boolean]
  def respond_to?(method, include_private = T.unsafe(nil)); end

  def reverse(*args, &block); end
  def sample(*args, &block); end
  def shuffle(*args, &block); end
  def split(*args, &block); end
  def table_name(*args, &block); end
  def to_ary(*args, &block); end
  def to_formatted_s(*args, &block); end
  def to_sentence(*args, &block); end
  def to_xml(*args, &block); end
  def |(*args, &block); end

  protected

  def method_missing(method, *args, &block); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args); end

  private

  def relation_class_for(klass); end
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods

  protected

  def method_missing(method, *args, &block); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def delegate(method, opts = T.unsafe(nil)); end
  def delegate_to_scoped_klass(method); end
  def name; end
end

module ActiveRecord::Delegation::DelegateCache
  def inherited(child_class); end
  def initialize_relation_delegate_cache; end
  def relation_delegate_class(klass); end
end

# This error is raised when trying to destroy a parent instance in N:1 or 1:1 associations
# (has_many, has_one) when there is at least 1 child associated instance.
# ex: if @project.tasks.size > 0, DeleteRestrictionError will be raised when trying to destroy @project
class ActiveRecord::DeleteRestrictionError < ::ActiveRecord::ActiveRecordError
  # @return [DeleteRestrictionError] a new instance of DeleteRestrictionError
  def initialize(name = T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationNameError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationNameError] a new instance of DuplicateMigrationNameError
  def initialize(name = T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationVersionError] a new instance of DuplicateMigrationVersionError
  def initialize(version = T.unsafe(nil)); end
end

module ActiveRecord::DynamicMatchers
  # @return [Boolean]
  def respond_to?(name, include_private = T.unsafe(nil)); end

  private

  def method_missing(name, *arguments, &block); end
end

class ActiveRecord::DynamicMatchers::FindBy < ::ActiveRecord::DynamicMatchers::Method
  def finder; end

  class << self
    def prefix; end
  end
end

class ActiveRecord::DynamicMatchers::FindByBang < ::ActiveRecord::DynamicMatchers::Method
  def finder; end

  class << self
    def prefix; end
    def suffix; end
  end
end

class ActiveRecord::DynamicMatchers::Method
  # @return [Method] a new instance of Method
  def initialize(model, name); end

  # Returns the value of attribute attribute_names.
  def attribute_names; end

  def define; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def valid?; end

  private

  # Given that the parameters starts with `_`, the finder needs to use the
  # same parameter name.
  def attributes_hash; end

  def body; end

  # @raise [NotImplementedError]
  def finder; end

  # The parameters in the signature may have reserved Ruby words, in order
  # to prevent errors, we start each param name with `_`.
  def signature; end

  class << self
    def match(model, name); end

    # Returns the value of attribute matchers.
    def matchers; end

    def pattern; end

    # @raise [NotImplementedError]
    def prefix; end

    def suffix; end
  end
end

# This error is raised when trying to eager load a polymorphic association using a JOIN.
# Eager loading polymorphic associations is only possible with
# {ActiveRecord::Relation#preload}[rdoc-ref:QueryMethods#preload].
class ActiveRecord::EagerLoadPolymorphicError < ::ActiveRecord::ActiveRecordError
  # @return [EagerLoadPolymorphicError] a new instance of EagerLoadPolymorphicError
  def initialize(reflection = T.unsafe(nil)); end
end

# Declare an enum attribute where the values map to integers in the database,
# but can be queried by name. Example:
#
#   class Conversation < ActiveRecord::Base
#     enum status: [ :active, :archived ]
#   end
#
#   # conversation.update! status: 0
#   conversation.active!
#   conversation.active? # => true
#   conversation.status  # => "active"
#
#   # conversation.update! status: 1
#   conversation.archived!
#   conversation.archived? # => true
#   conversation.status    # => "archived"
#
#   # conversation.status = 1
#   conversation.status = "archived"
#
#   conversation.status = nil
#   conversation.status.nil? # => true
#   conversation.status      # => nil
#
# Scopes based on the allowed values of the enum field will be provided
# as well. With the above example:
#
#   Conversation.active
#   Conversation.archived
#
# Of course, you can also query them directly if the scopes don't fit your
# needs:
#
#   Conversation.where(status: [:active, :archived])
#   Conversation.where.not(status: :active)
#
# You can set the default value from the database declaration, like:
#
#   create_table :conversations do |t|
#     t.column :status, :integer, default: 0
#   end
#
# Good practice is to let the first declared status be the default.
#
# Finally, it's also possible to explicitly map the relation between attribute and
# database integer with a hash:
#
#   class Conversation < ActiveRecord::Base
#     enum status: { active: 0, archived: 1 }
#   end
#
# Note that when an array is used, the implicit mapping from the values to database
# integers is derived from the order the values appear in the array. In the example,
# <tt>:active</tt> is mapped to +0+ as it's the first element, and <tt>:archived</tt>
# is mapped to +1+. In general, the +i+-th element is mapped to <tt>i-1</tt> in the
# database.
#
# Therefore, once a value is added to the enum array, its position in the array must
# be maintained, and new values should only be added to the end of the array. To
# remove unused values, the explicit hash syntax should be used.
#
# In rare circumstances you might need to access the mapping directly.
# The mappings are exposed through a class method with the pluralized attribute
# name, which return the mapping in a +HashWithIndifferentAccess+:
#
#   Conversation.statuses[:active]    # => 0
#   Conversation.statuses["archived"] # => 1
#
# Use that class method when you need to know the ordinal value of an enum.
# For example, you can use that when manually building SQL strings:
#
#   Conversation.where("status <> ?", Conversation.statuses[:archived])
#
# You can use the +:_prefix+ or +:_suffix+ options when you need to define
# multiple enums with same values. If the passed value is +true+, the methods
# are prefixed/suffixed with the name of the enum. It is also possible to
# supply a custom value:
#
#   class Conversation < ActiveRecord::Base
#     enum status: [:active, :archived], _suffix: true
#     enum comments_status: [:active, :inactive], _prefix: :comments
#   end
#
# With the above example, the bang and predicate methods along with the
# associated scopes are now prefixed and/or suffixed accordingly:
#
#   conversation.active_status!
#   conversation.archived_status? # => false
#
#   conversation.comments_inactive!
#   conversation.comments_active? # => false
module ActiveRecord::Enum
  def enum(definitions); end
  def inherited(base); end

  private

  def _enum_methods_module; end
  def detect_enum_conflict!(enum_name, method_name, klass_method = T.unsafe(nil)); end

  # @raise [ArgumentError]
  def raise_conflict_error(enum_name, method_name, type: T.unsafe(nil), source: T.unsafe(nil)); end

  class << self
    def extended(base); end
  end
end

ActiveRecord::Enum::ENUM_CONFLICT_MESSAGE = T.let(T.unsafe(nil), String)

class ActiveRecord::Enum::EnumType < ::ActiveModel::Type::Value
  # @return [EnumType] a new instance of EnumType
  def initialize(name, mapping, subtype); end

  def assert_valid_value(value); end
  def cast(value); end
  def deserialize(value); end
  def serialize(value); end
  def type(*args, &block); end

  protected

  # Returns the value of attribute mapping.
  def mapping; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute subtype.
  def subtype; end
end

class ActiveRecord::EnvironmentMismatchError < ::ActiveRecord::ActiveRecordError
  # @return [EnvironmentMismatchError] a new instance of EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

# Raised when a pool was unable to get ahold of all its connections
# to perform a "group" action such as
# {ActiveRecord::Base.connection_pool.disconnect!}[rdoc-ref:ConnectionAdapters::ConnectionPool#disconnect!]
# or {ActiveRecord::Base.clear_reloadable_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_reloadable_connections!].
class ActiveRecord::ExclusiveConnectionTimeoutError < ::ActiveRecord::ConnectionTimeoutError; end

module ActiveRecord::Explain
  # Executes the block with the collect flag enabled. Queries are collected
  # asynchronously by the subscriber and returned.
  def collecting_queries_for_explain; end

  # Makes the adapter execute EXPLAIN for the tuples of queries and bindings.
  # Returns a formatted string ready to be logged.
  def exec_explain(queries); end

  private

  def render_bind(attr); end
end

# This is a thread locals registry for EXPLAIN. For example
#
#   ActiveRecord::ExplainRegistry.queries
#
# returns the collected queries local to the current thread.
#
# See the documentation of ActiveSupport::PerThreadRegistry
# for further details.
class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [ExplainRegistry] a new instance of ExplainRegistry
  def initialize; end

  # Returns the value of attribute collect.
  def collect; end

  # Sets the attribute collect
  #
  # @param value the value to set the attribute collect to.
  def collect=(_arg0); end

  # @return [Boolean]
  def collect?; end

  # Returns the value of attribute queries.
  def queries; end

  # Sets the attribute queries
  #
  # @param value the value to set the attribute queries to.
  def queries=(_arg0); end

  def reset; end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  # @return [Boolean]
  def ignore_payload?(payload); end

  def start(name, id, payload); end
end

ActiveRecord::ExplainSubscriber::EXPLAINED_SQLS = T.let(T.unsafe(nil), Regexp)

# SCHEMA queries cannot be EXPLAINed, also we do not want to run EXPLAIN on
# our own EXPLAINs no matter how loopingly beautiful that would be.
#
# On the other hand, we want to monitor the performance of our real database
# queries, not the performance of the access to the query cache.
ActiveRecord::ExplainSubscriber::IGNORED_PAYLOADS = T.let(T.unsafe(nil), Array)

module ActiveRecord::FinderMethods
  # Returns true if a record exists in the table that matches the +id+ or
  # conditions given, or false otherwise. The argument can take six forms:
  #
  # * Integer - Finds the record with this primary key.
  # * String - Finds the record with a primary key corresponding to this
  #   string (such as <tt>'5'</tt>).
  # * Array - Finds the record that matches these +find+-style conditions
  #   (such as <tt>['name LIKE ?', "%#{query}%"]</tt>).
  # * Hash - Finds the record that matches these +find+-style conditions
  #   (such as <tt>{name: 'David'}</tt>).
  # * +false+ - Returns always +false+.
  # * No args - Returns +false+ if the table is empty, +true+ otherwise.
  #
  # For more information about specifying conditions as a hash or array,
  # see the Conditions section in the introduction to ActiveRecord::Base.
  #
  # Note: You can't pass in a condition as a string (like <tt>name =
  # 'Jamie'</tt>), since it would be sanitized and then queried against
  # the primary key column, like <tt>id = 'name = \'Jamie\''</tt>.
  #
  #   Person.exists?(5)
  #   Person.exists?('5')
  #   Person.exists?(['name LIKE ?', "%#{query}%"])
  #   Person.exists?(id: [1, 4, 8])
  #   Person.exists?(name: 'David')
  #   Person.exists?(false)
  #   Person.exists?
  #
  # @return [Boolean]
  def exists?(conditions = T.unsafe(nil)); end

  # Find the fifth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fifth # returns the fifth object fetched by SELECT * FROM people
  #   Person.offset(3).fifth # returns the fifth object from OFFSET 3 (which is OFFSET 7)
  #   Person.where(["user_name = :u", { u: user_name }]).fifth
  def fifth; end

  # Same as #fifth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fifth!; end

  # Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
  # If one or more records can not be found for the requested ids, then RecordNotFound will be raised. If the primary key
  # is an integer, find by id coerces its arguments using +to_i+.
  #
  #   Person.find(1)          # returns the object for ID = 1
  #   Person.find("1")        # returns the object for ID = 1
  #   Person.find("31-sarah") # returns the object for ID = 31
  #   Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
  #   Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)
  #   Person.find([1])        # returns an array for the object with ID = 1
  #   Person.where("administrator = 1").order("created_on DESC").find(1)
  #
  # NOTE: The returned records may not be in the same order as the ids you
  # provide since database rows are unordered. You will need to provide an explicit QueryMethods#order
  # option if you want the results to be sorted.
  #
  # ==== Find with lock
  #
  # Example for find with a lock: Imagine two concurrent transactions:
  # each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting
  # in two saves of <tt>person.visits = 3</tt>. By locking the row, the second
  # transaction has to wait until the first is finished; we get the
  # expected <tt>person.visits == 4</tt>.
  #
  #   Person.transaction do
  #     person = Person.lock(true).find(1)
  #     person.visits += 1
  #     person.save!
  #   end
  #
  # ==== Variations of #find
  #
  #   Person.where(name: 'Spartacus', rating: 4)
  #   # returns a chainable list (which can be empty).
  #
  #   Person.find_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or nil.
  #
  #   Person.find_or_initialize_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or returns a new instance (requires you call .save to persist against the database).
  #
  #   Person.find_or_create_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or creates it and returns it.
  #
  # ==== Alternatives for #find
  #
  #   Person.where(name: 'Spartacus', rating: 4).exists?(conditions = :none)
  #   # returns a boolean indicating if any record with the given conditions exist.
  #
  #   Person.where(name: 'Spartacus', rating: 4).select("field1, field2, field3")
  #   # returns a chainable list of instances with only the mentioned fields.
  #
  #   Person.where(name: 'Spartacus', rating: 4).ids
  #   # returns an Array of ids.
  #
  #   Person.where(name: 'Spartacus', rating: 4).pluck(:field1, :field2)
  #   # returns an Array of the required fields.
  def find(*args); end

  # Finds the first record matching the specified conditions. There
  # is no implied ordering so if order matters, you should specify it
  # yourself.
  #
  # If no record is found, returns <tt>nil</tt>.
  #
  #   Post.find_by name: 'Spartacus', rating: 4
  #   Post.find_by "published_at < ?", 2.weeks.ago
  def find_by(arg, *args); end

  # Like #find_by, except that if no record is found, raises
  # an ActiveRecord::RecordNotFound error.
  def find_by!(arg, *args); end

  # Find the first record (or first N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.first # returns the first object fetched by SELECT * FROM people ORDER BY people.id LIMIT 1
  #   Person.where(["user_name = ?", user_name]).first
  #   Person.where(["user_name = :u", { u: user_name }]).first
  #   Person.order("created_on DESC").offset(5).first
  #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people ORDER BY people.id LIMIT 3
  def first(limit = T.unsafe(nil)); end

  # Same as #first but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #first! accepts no arguments.
  def first!; end

  # Find the forty-second record. Also known as accessing "the reddit".
  # If no order is defined it will order by primary key.
  #
  #   Person.forty_two # returns the forty-second object fetched by SELECT * FROM people
  #   Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44)
  #   Person.where(["user_name = :u", { u: user_name }]).forty_two
  def forty_two; end

  # Same as #forty_two but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def forty_two!; end

  # Find the fourth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fourth # returns the fourth object fetched by SELECT * FROM people
  #   Person.offset(3).fourth # returns the fourth object from OFFSET 3 (which is OFFSET 6)
  #   Person.where(["user_name = :u", { u: user_name }]).fourth
  def fourth; end

  # Same as #fourth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fourth!; end

  # Find the last record (or last N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.last # returns the last object fetched by SELECT * FROM people
  #   Person.where(["user_name = ?", user_name]).last
  #   Person.order("created_on DESC").offset(5).last
  #   Person.last(3) # returns the last three objects fetched by SELECT * FROM people.
  #
  # Take note that in that last case, the results are sorted in ascending order:
  #
  #   [#<Person id:2>, #<Person id:3>, #<Person id:4>]
  #
  # and not:
  #
  #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
  def last(limit = T.unsafe(nil)); end

  # Same as #last but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #last! accepts no arguments.
  def last!; end

  # This method is called whenever no records are found with either a single
  # id or multiple ids and raises an ActiveRecord::RecordNotFound exception.
  #
  # The error message is different depending on whether a single id or
  # multiple ids are provided. If multiple ids are provided, then the number
  # of results obtained should be provided in the +result_size+ argument and
  # the expected number of results should be provided in the +expected_size+
  # argument.
  def raise_record_not_found_exception!(ids, result_size, expected_size, key = T.unsafe(nil)); end

  # Find the second record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second # returns the second object fetched by SELECT * FROM people
  #   Person.offset(3).second # returns the second object from OFFSET 3 (which is OFFSET 4)
  #   Person.where(["user_name = :u", { u: user_name }]).second
  def second; end

  # Same as #second but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second!; end

  # Find the second-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).second_to_last
  def second_to_last; end

  # Same as #second_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second_to_last!; end

  # Gives a record (or N records if a parameter is supplied) without any implied
  # order. The order will depend on the database implementation.
  # If an order is supplied it will be respected.
  #
  #   Person.take # returns an object fetched by SELECT * FROM people LIMIT 1
  #   Person.take(5) # returns 5 objects fetched by SELECT * FROM people LIMIT 5
  #   Person.where(["name LIKE '%?'", name]).take
  def take(limit = T.unsafe(nil)); end

  # Same as #take but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #take! accepts no arguments.
  def take!; end

  # Find the third record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third # returns the third object fetched by SELECT * FROM people
  #   Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5)
  #   Person.where(["user_name = :u", { u: user_name }]).third
  def third; end

  # Same as #third but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third!; end

  # Find the third-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third_to_last # returns the third-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).third_to_last # returns the third-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).third_to_last
  def third_to_last; end

  # Same as #third_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third_to_last!; end

  protected

  def find_nth(index, offset = T.unsafe(nil)); end
  def find_nth!(index); end
  def find_nth_from_last(index); end
  def find_nth_with_limit(index, limit); end
  def find_one(id); end
  def find_some(ids); end
  def find_some_ordered(ids); end
  def find_take; end
  def find_with_ids(*ids); end

  private

  def apply_join_dependency(relation, join_dependency); end
  def construct_join_dependency(joins = T.unsafe(nil)); end
  def construct_relation_for_association_calculations; end
  def find_last(limit); end
  def find_nth_with_limit_and_offset(index, limit, offset:); end
  def find_with_associations; end
  def limited_ids_for(relation); end
  def offset_index; end

  # @return [Boolean]
  def using_limitable_reflections?(reflections); end
end

ActiveRecord::FinderMethods::ONE_AS_ONE = T.let(T.unsafe(nil), String)

class ActiveRecord::Fixture
  include ::Enumerable

  # @return [Fixture] a new instance of Fixture
  def initialize(fixture, model_class); end

  def [](key); end
  def class_name; end
  def each; end
  def find; end

  # Returns the value of attribute fixture.
  def fixture; end

  # Returns the value of attribute model_class.
  def model_class; end

  # Returns the value of attribute fixture.
  def to_hash; end
end

class ActiveRecord::Fixture::FixtureError < ::StandardError; end
class ActiveRecord::Fixture::FormatError < ::ActiveRecord::Fixture::FixtureError; end
class ActiveRecord::FixtureClassNotFound < ::ActiveRecord::ActiveRecordError; end

# \Fixtures are a way of organizing data that you want to test against; in short, sample data.
#
# They are stored in YAML files, one file per model, which are placed in the directory
# appointed by <tt>ActiveSupport::TestCase.fixture_path=(path)</tt> (this is automatically
# configured for Rails, so you can just put your files in <tt><your-rails-app>/test/fixtures/</tt>).
# The fixture file ends with the +.yml+ file extension, for example:
# <tt><your-rails-app>/test/fixtures/web_sites.yml</tt>).
#
# The format of a fixture file looks like this:
#
#   rubyonrails:
#     id: 1
#     name: Ruby on Rails
#     url: http://www.rubyonrails.org
#
#   google:
#     id: 2
#     name: Google
#     url: http://www.google.com
#
# This fixture file includes two fixtures. Each YAML fixture (ie. record) is given a name and
# is followed by an indented list of key/value pairs in the "key: value" format. Records are
# separated by a blank line for your viewing pleasure.
#
# Note: Fixtures are unordered. If you want ordered fixtures, use the omap YAML type.
# See http://yaml.org/type/omap.html
# for the specification. You will need ordered fixtures when you have foreign key constraints
# on keys in the same table. This is commonly needed for tree structures. Example:
#
#    --- !omap
#    - parent:
#        id:         1
#        parent_id:  NULL
#        title:      Parent
#    - child:
#        id:         2
#        parent_id:  1
#        title:      Child
#
# = Using Fixtures in Test Cases
#
# Since fixtures are a testing construct, we use them in our unit and functional tests. There
# are two ways to use the fixtures, but first let's take a look at a sample unit test:
#
#   require 'test_helper'
#
#   class WebSiteTest < ActiveSupport::TestCase
#     test "web_site_count" do
#       assert_equal 2, WebSite.count
#     end
#   end
#
# By default, +test_helper.rb+ will load all of your fixtures into your test
# database, so this test will succeed.
#
# The testing environment will automatically load the all fixtures into the database before each
# test. To ensure consistent data, the environment deletes the fixtures before running the load.
#
# In addition to being available in the database, the fixture's data may also be accessed by
# using a special dynamic method, which has the same name as the model, and accepts the
# name of the fixture to instantiate:
#
#   test "find" do
#     assert_equal "Ruby on Rails", web_sites(:rubyonrails).name
#   end
#
# Alternatively, you may enable auto-instantiation of the fixture data. For instance, take the
# following tests:
#
#   test "find_alt_method_1" do
#     assert_equal "Ruby on Rails", @web_sites['rubyonrails']['name']
#   end
#
#   test "find_alt_method_2" do
#     assert_equal "Ruby on Rails", @rubyonrails.name
#   end
#
# In order to use these methods to access fixtured data within your testcases, you must specify one of the
# following in your ActiveSupport::TestCase-derived class:
#
# - to fully enable instantiated fixtures (enable alternate methods #1 and #2 above)
#     self.use_instantiated_fixtures = true
#
# - create only the hash for the fixtures, do not 'find' each instance (enable alternate method #1 only)
#     self.use_instantiated_fixtures = :no_instances
#
# Using either of these alternate methods incurs a performance hit, as the fixtured data must be fully
# traversed in the database to create the fixture hash and/or instance variables. This is expensive for
# large sets of fixtured data.
#
# = Dynamic fixtures with ERB
#
# Some times you don't care about the content of the fixtures as much as you care about the volume.
# In these cases, you can mix ERB in with your YAML fixtures to create a bunch of fixtures for load
# testing, like:
#
#   <% 1.upto(1000) do |i| %>
#   fix_<%= i %>:
#     id: <%= i %>
#     name: guy_<%= i %>
#   <% end %>
#
# This will create 1000 very simple fixtures.
#
# Using ERB, you can also inject dynamic values into your fixtures with inserts like
# <tt><%= Date.today.strftime("%Y-%m-%d") %></tt>.
# This is however a feature to be used with some caution. The point of fixtures are that they're
# stable units of predictable sample data. If you feel that you need to inject dynamic values, then
# perhaps you should reexamine whether your application is properly testable. Hence, dynamic values
# in fixtures are to be considered a code smell.
#
# Helper methods defined in a fixture will not be available in other fixtures, to prevent against
# unwanted inter-test dependencies. Methods used by multiple fixtures should be defined in a module
# that is included in ActiveRecord::FixtureSet.context_class.
#
# - define a helper method in `test_helper.rb`
#     module FixtureFileHelpers
#       def file_sha(path)
#         Digest::SHA2.hexdigest(File.read(Rails.root.join('test/fixtures', path)))
#       end
#     end
#     ActiveRecord::FixtureSet.context_class.include FixtureFileHelpers
#
# - use the helper method in a fixture
#     photo:
#       name: kitten.png
#       sha: <%= file_sha 'files/kitten.png' %>
#
# = Transactional Tests
#
# Test cases can use begin+rollback to isolate their changes to the database instead of having to
# delete+insert for every test case.
#
#   class FooTest < ActiveSupport::TestCase
#     self.use_transactional_tests = true
#
#     test "godzilla" do
#       assert !Foo.all.empty?
#       Foo.destroy_all
#       assert Foo.all.empty?
#     end
#
#     test "godzilla aftermath" do
#       assert !Foo.all.empty?
#     end
#   end
#
# If you preload your test database with all fixture data (probably in the rake task) and use
# transactional tests, then you may omit all fixtures declarations in your test cases since
# all the data's already there and every case rolls back its changes.
#
# In order to use instantiated fixtures with preloaded data, set +self.pre_loaded_fixtures+ to
# true. This will provide access to fixture data for every table that has been loaded through
# fixtures (depending on the value of +use_instantiated_fixtures+).
#
# When *not* to use transactional tests:
#
# 1. You're testing whether a transaction works correctly. Nested transactions don't commit until
#    all parent transactions commit, particularly, the fixtures transaction which is begun in setup
#    and rolled back in teardown. Thus, you won't be able to verify
#    the results of your transaction until Active Record supports nested transactions or savepoints (in progress).
# 2. Your database does not support transactions. Every Active Record database supports transactions except MySQL MyISAM.
#    Use InnoDB, MaxDB, or NDB instead.
#
# = Advanced Fixtures
#
# Fixtures that don't specify an ID get some extra features:
#
# * Stable, autogenerated IDs
# * Label references for associations (belongs_to, has_one, has_many)
# * HABTM associations as inline lists
#
# There are some more advanced features available even if the id is specified:
#
# * Autofilled timestamp columns
# * Fixture label interpolation
# * Support for YAML defaults
#
# == Stable, Autogenerated IDs
#
# Here, have a monkey fixture:
#
#   george:
#     id: 1
#     name: George the Monkey
#
#   reginald:
#     id: 2
#     name: Reginald the Pirate
#
# Each of these fixtures has two unique identifiers: one for the database
# and one for the humans. Why don't we generate the primary key instead?
# Hashing each fixture's label yields a consistent ID:
#
#   george: # generated id: 503576764
#     name: George the Monkey
#
#   reginald: # generated id: 324201669
#     name: Reginald the Pirate
#
# Active Record looks at the fixture's model class, discovers the correct
# primary key, and generates it right before inserting the fixture
# into the database.
#
# The generated ID for a given label is constant, so we can discover
# any fixture's ID without loading anything, as long as we know the label.
#
# == Label references for associations (belongs_to, has_one, has_many)
#
# Specifying foreign keys in fixtures can be very fragile, not to
# mention difficult to read. Since Active Record can figure out the ID of
# any fixture from its label, you can specify FK's by label instead of ID.
#
# === belongs_to
#
# Let's break out some more monkeys and pirates.
#
#   ### in pirates.yml
#
#   reginald:
#     id: 1
#     name: Reginald the Pirate
#     monkey_id: 1
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     pirate_id: 1
#
# Add a few more monkeys and pirates and break this into multiple files,
# and it gets pretty hard to keep track of what's going on. Let's
# use labels instead of IDs:
#
#   ### in pirates.yml
#
#   reginald:
#     name: Reginald the Pirate
#     monkey: george
#
#   ### in monkeys.yml
#
#   george:
#     name: George the Monkey
#     pirate: reginald
#
# Pow! All is made clear. Active Record reflects on the fixture's model class,
# finds all the +belongs_to+ associations, and allows you to specify
# a target *label* for the *association* (monkey: george) rather than
# a target *id* for the *FK* (<tt>monkey_id: 1</tt>).
#
# ==== Polymorphic belongs_to
#
# Supporting polymorphic relationships is a little bit more complicated, since
# Active Record needs to know what type your association is pointing at. Something
# like this should look familiar:
#
#   ### in fruit.rb
#
#   belongs_to :eater, polymorphic: true
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#     eater_id: 1
#     eater_type: Monkey
#
# Can we do better? You bet!
#
#   apple:
#     eater: george (Monkey)
#
# Just provide the polymorphic target type and Active Record will take care of the rest.
#
# === has_and_belongs_to_many
#
# Time to give our monkey some fruit.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#
#   orange:
#     id: 2
#     name: orange
#
#   grape:
#     id: 3
#     name: grape
#
#   ### in fruits_monkeys.yml
#
#   apple_george:
#     fruit_id: 1
#     monkey_id: 1
#
#   orange_george:
#     fruit_id: 2
#     monkey_id: 1
#
#   grape_george:
#     fruit_id: 3
#     monkey_id: 1
#
# Let's make the HABTM fixture go away.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     fruits: apple, orange, grape
#
#   ### in fruits.yml
#
#   apple:
#     name: apple
#
#   orange:
#     name: orange
#
#   grape:
#     name: grape
#
# Zap! No more fruits_monkeys.yml file. We've specified the list of fruits
# on George's fixture, but we could've just as easily specified a list
# of monkeys on each fruit. As with +belongs_to+, Active Record reflects on
# the fixture's model class and discovers the +has_and_belongs_to_many+
# associations.
#
# == Autofilled Timestamp Columns
#
# If your table/model specifies any of Active Record's
# standard timestamp columns (+created_at+, +created_on+, +updated_at+, +updated_on+),
# they will automatically be set to <tt>Time.now</tt>.
#
# If you've set specific values, they'll be left alone.
#
# == Fixture label interpolation
#
# The label of the current fixture is always available as a column value:
#
#   geeksomnia:
#     name: Geeksomnia's Account
#     subdomain: $LABEL
#     email: $LABEL@email.com
#
# Also, sometimes (like when porting older join table fixtures) you'll need
# to be able to get a hold of the identifier for a given label. ERB
# to the rescue:
#
#   george_reginald:
#     monkey_id: <%= ActiveRecord::FixtureSet.identify(:reginald) %>
#     pirate_id: <%= ActiveRecord::FixtureSet.identify(:george) %>
#
# == Support for YAML defaults
#
# You can set and reuse defaults in your fixtures YAML file.
# This is the same technique used in the +database.yml+ file to specify
# defaults:
#
#   DEFAULTS: &DEFAULTS
#     created_on: <%= 3.weeks.ago.to_s(:db) %>
#
#   first:
#     name: Smurf
#     <<: *DEFAULTS
#
#   second:
#     name: Fraggle
#     <<: *DEFAULTS
#
# Any fixture labeled "DEFAULTS" is safely ignored.
#
# == Configure the fixture model class
#
# It's possible to set the fixture's model class directly in the YAML file.
# This is helpful when fixtures are loaded outside tests and
# +set_fixture_class+ is not available (e.g.
# when running <tt>rails db:fixtures:load</tt>).
#
#   _fixture:
#     model_class: User
#   david:
#     name: David
#
# Any fixtures labeled "_fixture" are safely ignored.
class ActiveRecord::FixtureSet
  # @return [FixtureSet] a new instance of FixtureSet
  def initialize(connection, name, class_name, path, config = T.unsafe(nil)); end

  def [](x); end
  def []=(k, v); end
  def all_loaded_fixtures; end
  def all_loaded_fixtures=(obj); end

  # Returns the value of attribute config.
  def config; end

  def each(&block); end

  # Returns the value of attribute fixtures.
  def fixtures; end

  # Returns the value of attribute model_class.
  def model_class; end

  # Returns the value of attribute name.
  def name; end

  def size; end

  # Returns the value of attribute table_name.
  def table_name; end

  # Returns a hash of rows to be inserted. The key is the table, the value is
  # a list of rows to insert to that table.
  def table_rows; end

  private

  def add_join_records(rows, row, association); end
  def column_names; end

  # @return [Boolean]
  def has_primary_key_column?; end

  def inheritance_column_name; end
  def model_class=(class_name); end
  def primary_key_name; end
  def primary_key_type; end

  # Loads the fixtures from the YAML file at +path+.
  # If the file sets the +model_class+ and current instance value is not set,
  # it uses the file value.
  def read_fixture_files(path); end

  def timestamp_column_names; end
  def yaml_file_path(path); end

  class << self
    def all_loaded_fixtures; end
    def all_loaded_fixtures=(obj); end
    def cache_fixtures(connection, fixtures_map); end
    def cache_for_connection(connection); end
    def cached_fixtures(connection, keys_to_fetch = T.unsafe(nil)); end

    # Superclass for the evaluation contexts used by ERB fixtures.
    def context_class; end

    def create_fixtures(fixtures_directory, fixture_set_names, class_names = T.unsafe(nil), config = T.unsafe(nil)); end
    def default_fixture_model_name(fixture_set_name, config = T.unsafe(nil)); end
    def default_fixture_table_name(fixture_set_name, config = T.unsafe(nil)); end

    # @return [Boolean]
    def fixture_is_cached?(connection, table_name); end

    # Returns a consistent, platform-independent identifier for +label+.
    # Integer identifiers are values less than 2^30. UUIDs are RFC 4122 version 5 SHA-1 hashes.
    def identify(label, column_type = T.unsafe(nil)); end

    def instantiate_all_loaded_fixtures(object, load_instances = T.unsafe(nil)); end
    def instantiate_fixtures(object, fixture_set, load_instances = T.unsafe(nil)); end
    def reset_cache; end
    def update_all_loaded_fixtures(fixtures_map); end
  end
end

class ActiveRecord::FixtureSet::ClassCache
  # @return [ClassCache] a new instance of ClassCache
  def initialize(class_names, config); end

  def [](fs_name); end

  private

  def default_fixture_model(fs_name, config); end
  def insert_class(class_names, name, klass); end
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable

  # @return [File] a new instance of File
  def initialize(file); end

  def each(&block); end
  def model_class; end

  private

  def config_row; end
  def prepare_erb(content); end
  def raw_rows; end
  def render(content); end
  def rows; end

  # Validate our unmarshalled data.
  #
  # @raise [Fixture::FormatError]
  def validate(data); end

  class << self
    # Open a fixture file named +file+.  When called with a block, the block
    # is called with the filehandle and the filehandle is automatically closed
    # when the block finishes.
    def open(file); end
  end
end

class ActiveRecord::FixtureSet::HasManyThroughProxy < ::ActiveRecord::FixtureSet::ReflectionProxy
  def join_table; end
  def lhs_key; end
  def rhs_key; end
end

# --
# An instance of FixtureSet is normally stored in a single YAML file and
# possibly in a folder with the same name.
# ++
ActiveRecord::FixtureSet::MAX_ID = T.let(T.unsafe(nil), Integer)

class ActiveRecord::FixtureSet::ReflectionProxy
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  def initialize(association); end

  def join_table; end
  def name; end
  def primary_key_type; end
end

class ActiveRecord::FixtureSet::RenderContext
  class << self
    def create_subclass; end
  end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationNotFoundError] a new instance of HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPointlessSourceTypeError] a new instance of HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicSourceError] a new instance of HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicThroughError] a new instance of HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughCantAssociateNewRecords < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughCantAssociateNewRecords] a new instance of HasManyThroughCantAssociateNewRecords
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end

class ActiveRecord::HasManyThroughCantDissociateNewRecords < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughCantDissociateNewRecords] a new instance of HasManyThroughCantDissociateNewRecords
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughSourceAssociationNotFoundError] a new instance of HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasOneAssociationPolymorphicThroughError] a new instance of HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection < ::ActiveRecord::ActiveRecordError
  # @return [HasOneThroughCantAssociateThroughCollection] a new instance of HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), through_reflection = T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end
class ActiveRecord::HasOneThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

class ActiveRecord::IllegalMigrationNameError < ::ActiveRecord::MigrationError
  # @return [IllegalMigrationNameError] a new instance of IllegalMigrationNameError
  def initialize(name = T.unsafe(nil)); end
end

# Raised when a relation cannot be mutated because it's already loaded.
#
#   class Task < ActiveRecord::Base
#   end
#
#   relation = Task.all
#   relation.loaded? # => true
#
#   # Methods which try to mutate a loaded relation fail.
#   relation.where!(title: 'TODO')  # => ActiveRecord::ImmutableRelation
#   relation.limit!(5)              # => ActiveRecord::ImmutableRelation
class ActiveRecord::ImmutableRelation < ::ActiveRecord::ActiveRecordError; end

# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a column that by
# default is named "type" (can be changed by overwriting <tt>Base.inheritance_column</tt>).
# This means that an inheritance looking like this:
#
#   class Company < ActiveRecord::Base; end
#   class Firm < Company; end
#   class Client < Company; end
#   class PriorityClient < Client; end
#
# When you do <tt>Firm.create(name: "37signals")</tt>, this record will be saved in
# the companies table with type = "Firm". You can then fetch this row again using
# <tt>Company.where(name: '37signals').first</tt> and it will return a Firm object.
#
# Be aware that because the type column is an attribute on the record every new
# subclass will instantly be marked as dirty and the type column will be included
# in the list of changed attributes on the record. This is different from non
# STI classes:
#
#   Company.new.changed? # => false
#   Firm.new.changed?    # => true
#   Firm.new.changes     # => {"type"=>["","Firm"]}
#
# If you don't have a type column defined in your table, single-table inheritance won't
# be triggered. In that case, it'll work just like normal subclasses with no special magic
# for differentiating between them or reloading the right type with find.
#
# Note, all the attributes for all the cases are kept in the same table. Read more:
# http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Inheritance::ClassMethods

  private

  # Sets the attribute used for single table inheritance to this class name if this is not the
  # ActiveRecord::Base descendant.
  # Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to
  # do Reply.new without having to set <tt>Reply[Reply.inheritance_column] = "Reply"</tt> yourself.
  # No such attribute would be set for objects of the Message class in that example.
  def ensure_proper_type; end

  def initialize_dup(other); end
  def initialize_internals_callback; end

  module GeneratedClassMethods
    def store_full_sti_class; end
    def store_full_sti_class=(value); end
    def store_full_sti_class?; end
  end

  module GeneratedInstanceMethods
    def store_full_sti_class; end
    def store_full_sti_class?; end
  end
end

module ActiveRecord::Inheritance::ClassMethods
  # Set this to true if this is an abstract class (see <tt>abstract_class?</tt>).
  # If you are using inheritance with ActiveRecord and don't want child classes
  # to utilize the implied STI table name of the parent class, this will need to be true.
  # For example, given the following:
  #
  #   class SuperClass < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   class Child < SuperClass
  #     self.table_name = 'the_table_i_really_want'
  #   end
  #
  #
  # <tt>self.abstract_class = true</tt> is required to make <tt>Child<.find,.create, or any Arel method></tt> use <tt>the_table_i_really_want</tt> instead of a table called <tt>super_classes</tt>
  def abstract_class; end

  # Set this to true if this is an abstract class (see <tt>abstract_class?</tt>).
  # If you are using inheritance with ActiveRecord and don't want child classes
  # to utilize the implied STI table name of the parent class, this will need to be true.
  # For example, given the following:
  #
  #   class SuperClass < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   class Child < SuperClass
  #     self.table_name = 'the_table_i_really_want'
  #   end
  #
  #
  # <tt>self.abstract_class = true</tt> is required to make <tt>Child<.find,.create, or any Arel method></tt> use <tt>the_table_i_really_want</tt> instead of a table called <tt>super_classes</tt>
  def abstract_class=(_arg0); end

  # Returns whether this class is an abstract class or not.
  #
  # @return [Boolean]
  def abstract_class?; end

  # Returns the class descending directly from ActiveRecord::Base, or
  # an abstract class, if any, in the inheritance hierarchy.
  #
  # If A extends ActiveRecord::Base, A.base_class will return A. If B descends from A
  # through some arbitrarily deep hierarchy, B.base_class will return A.
  #
  # If B < A and C < B and if A is an abstract_class then both B.base_class
  # and C.base_class would return B as the answer since A is an abstract_class.
  def base_class; end

  # Returns +true+ if this does not need STI type condition. Returns
  # +false+ if STI type condition needs to be applied.
  #
  # @return [Boolean]
  def descends_from_active_record?; end

  # @return [Boolean]
  def finder_needs_type_condition?; end

  # Determines if one of the attributes passed in is the inheritance column,
  # and if the inheritance column is attr accessible, it initializes an
  # instance of the given subclass instead of the base class.
  def new(*args, &block); end

  def sti_name; end

  protected

  # Returns the class type of the record using the current module as a prefix. So descendants of
  # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
  def compute_type(type_name); end

  private

  # Called by +instantiate+ to decide which class to use for a new
  # record instance. For single-table inheritance, we check the record
  # for a +type+ column and return the corresponding class.
  def discriminate_class_for_record(record); end

  def find_sti_class(type_name); end

  # Detect the subclass from the inheritance column of attrs. If the inheritance column value
  # is not self or a valid subclass, raises ActiveRecord::SubclassNotFound
  def subclass_from_attributes(attrs); end

  def type_condition(table = T.unsafe(nil)); end

  # @return [Boolean]
  def using_single_table_inheritance?(record); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Integration::ClassMethods

  # Returns a cache key that can be used to identify this record.
  #
  #   Product.new.cache_key     # => "products/new"
  #   Product.find(5).cache_key # => "products/5" (updated_at not available)
  #   Person.find(5).cache_key  # => "people/5-20071224150000" (updated_at available)
  #
  # You can also pass a list of named timestamps, and the newest in the list will be
  # used to generate the key:
  #
  #   Person.find(5).cache_key(:updated_at, :last_reviewed_at)
  def cache_key(*timestamp_names); end

  # Returns a String, which Action Pack uses for constructing a URL to this
  # object. The default implementation returns this record's id as a String,
  # or nil if this record's unsaved.
  #
  # For example, suppose that you have a User model, and that you have a
  # <tt>resources :users</tt> route. Normally, +user_path+ will
  # construct a path with the user object's 'id' in it:
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/1"
  #
  # You can override +to_param+ in your model to make +user_path+ construct
  # a path using the user's name instead of the user's id:
  #
  #   class User < ActiveRecord::Base
  #     def to_param  # overridden
  #       name
  #     end
  #   end
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/Phusion"
  def to_param; end

  module GeneratedClassMethods
    def cache_timestamp_format; end
    def cache_timestamp_format=(value); end
    def cache_timestamp_format?; end
  end

  module GeneratedInstanceMethods
    def cache_timestamp_format; end
    def cache_timestamp_format?; end
  end
end

module ActiveRecord::Integration::ClassMethods
  # Defines your model's +to_param+ method to generate "pretty" URLs
  # using +method_name+, which can be any attribute or method that
  # responds to +to_s+.
  #
  #   class User < ActiveRecord::Base
  #     to_param :name
  #   end
  #
  #   user = User.find_by(name: 'Fancy Pants')
  #   user.id         # => 123
  #   user_path(user) # => "/users/123-fancy-pants"
  #
  # Values longer than 20 characters will be truncated. The value
  # is truncated word by word.
  #
  #   user = User.find_by(name: 'David Heinemeier Hansson')
  #   user.id         # => 125
  #   user_path(user) # => "/users/125-david"
  #
  # Because the generated param begins with the record's +id+, it is
  # suitable for passing to +find+. In a controller, for example:
  #
  #   params[:id]               # => "123-fancy-pants"
  #   User.find(params[:id]).id # => 123
  def to_param(method_name = T.unsafe(nil)); end
end

# This class is used to create a table that keeps track of values and keys such
# as which environment migrations were run in.
class ActiveRecord::InternalMetadata < ::ActiveRecord::Base
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods

  class << self
    def [](key); end
    def []=(key, value); end
    def _validators; end
    def attribute_type_decorations; end

    # Creates an internal metadata table with columns +key+ and +value+
    def create_table; end

    def defined_enums; end

    # @return [Boolean]
    def original_table_exists?; end

    def original_table_name; end
    def primary_key; end

    # @return [Boolean]
    def table_exists?; end

    def table_name; end
  end
end

class ActiveRecord::InternalMetadata::ActiveRecord_AssociationRelation < ::ActiveRecord::AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Associations_CollectionProxy < ::ActiveRecord::Associations::CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Relation < ::ActiveRecord::Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods; end

# Raised when a record cannot be inserted or updated because it references a non-existent record.
class ActiveRecord::InvalidForeignKey < ::ActiveRecord::WrappedDatabaseException; end

class ActiveRecord::InverseOfAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  # @return [InverseOfAssociationNotFoundError] a new instance of InverseOfAssociationNotFoundError
  def initialize(reflection = T.unsafe(nil), associated_class = T.unsafe(nil)); end
end

# Exception that can be raised to stop migrations from being rolled back.
# For example the following migration is not reversible.
# Rolling back this migration will raise an ActiveRecord::IrreversibleMigration error.
#
#   class IrreversibleMigrationExample < ActiveRecord::Migration[5.0]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       execute <<-SQL
#         ALTER TABLE distributors
#           ADD CONSTRAINT zipchk
#             CHECK (char_length(zipcode) = 5) NO INHERIT;
#       SQL
#     end
#   end
#
# There are two ways to mitigate this problem.
#
# 1. Define <tt>#up</tt> and <tt>#down</tt> methods instead of <tt>#change</tt>:
#
#  class ReversibleMigrationExample < ActiveRecord::Migration[5.0]
#    def up
#      create_table :distributors do |t|
#        t.string :zipcode
#      end
#
#      execute <<-SQL
#        ALTER TABLE distributors
#          ADD CONSTRAINT zipchk
#            CHECK (char_length(zipcode) = 5) NO INHERIT;
#      SQL
#    end
#
#    def down
#      execute <<-SQL
#        ALTER TABLE distributors
#          DROP CONSTRAINT zipchk
#      SQL
#
#      drop_table :distributors
#    end
#  end
#
# 2. Use the #reversible method in <tt>#change</tt> method:
#
#   class ReversibleMigrationExample < ActiveRecord::Migration[5.0]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       reversible do |dir|
#         dir.up do
#           execute <<-SQL
#             ALTER TABLE distributors
#               ADD CONSTRAINT zipchk
#                 CHECK (char_length(zipcode) = 5) NO INHERIT;
#           SQL
#         end
#
#         dir.down do
#           execute <<-SQL
#             ALTER TABLE distributors
#               DROP CONSTRAINT zipchk
#           SQL
#         end
#       end
#     end
#   end
class ActiveRecord::IrreversibleMigration < ::ActiveRecord::MigrationError; end

# IrreversibleOrderError is raised when a relation's order is too complex for
# +reverse_order+ to automatically reverse.
class ActiveRecord::IrreversibleOrderError < ::ActiveRecord::ActiveRecordError; end

class ActiveRecord::LazyAttributeHash
  # @return [LazyAttributeHash] a new instance of LazyAttributeHash
  def initialize(types, values, additional_types, default_attributes, delegate_hash = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def deep_dup; end
  def each_key(*args, &block); end
  def encode_with(coder); end
  def except(*args, &block); end
  def fetch(*args, &block); end
  def init_with(coder); end

  # @return [Boolean]
  def key?(key); end

  def marshal_dump; end
  def marshal_load(values); end
  def select; end
  def transform_values(*args, &block); end

  protected

  # Returns the value of attribute additional_types.
  def additional_types; end

  # Returns the value of attribute default_attributes.
  def default_attributes; end

  # Returns the value of attribute delegate_hash.
  def delegate_hash; end

  def materialize; end

  # Returns the value of attribute types.
  def types; end

  # Returns the value of attribute values.
  def values; end

  private

  def assign_default_value(name); end
  def initialize_dup(_); end
end

module ActiveRecord::LegacyYamlAdapter
  class << self
    def convert(klass, coder); end
  end
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  class << self
    def convert(klass, coder); end
  end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  class << self
    def convert(klass, coder); end
  end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end
  def encode_with(coder); end
  def init_with(coder); end
  def serialize(value); end
end

# == What is Optimistic Locking
#
# Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of
# conflicts with the data. It does this by checking whether another process has made changes to a record since
# it was opened, an <tt>ActiveRecord::StaleObjectError</tt> exception is thrown if that has occurred
# and the update is ignored.
#
# Check out <tt>ActiveRecord::Locking::Pessimistic</tt> for an alternative.
#
# == Usage
#
# Active Record supports optimistic locking if the +lock_version+ field is present. Each update to the
# record increments the +lock_version+ column and the locking facilities ensure that records instantiated twice
# will let the last one saved raise a +StaleObjectError+ if the first was also updated. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.first_name = "should fail"
#   p2.save # Raises an ActiveRecord::StaleObjectError
#
# Optimistic locking will also check for stale data when objects are destroyed. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.destroy # Raises an ActiveRecord::StaleObjectError
#
# You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging,
# or otherwise apply the business logic needed to resolve the conflict.
#
# This locking mechanism will function inside a single Ruby process. To make it work across all
# web requests, the recommended approach is to add +lock_version+ as a hidden field to your form.
#
# This behavior can be turned off by setting <tt>ActiveRecord::Base.lock_optimistically = false</tt>.
# To override the name of the +lock_version+ column, set the <tt>locking_column</tt> class attribute:
#
#   class Person < ActiveRecord::Base
#     self.locking_column = :lock_person
#   end
module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Locking::Optimistic::ClassMethods

  # @return [Boolean]
  def locking_enabled?; end

  private

  def _create_record(attribute_names = T.unsafe(nil), *_arg1); end
  def _update_record(attribute_names = T.unsafe(nil)); end
  def destroy_row; end
  def increment_lock; end
  def relation_for_destroy; end

  module GeneratedClassMethods
    def lock_optimistically; end
    def lock_optimistically=(value); end
    def lock_optimistically?; end
  end

  module GeneratedInstanceMethods
    def lock_optimistically; end
    def lock_optimistically?; end
  end
end

module ActiveRecord::Locking::Optimistic::ClassMethods
  # The version column used for optimistic locking. Defaults to +lock_version+.
  def locking_column; end

  # Set the column to use for optimistic locking. Defaults to +lock_version+.
  def locking_column=(value); end

  # Returns true if the +lock_optimistically+ flag is set to true
  # (which it is, by default) and the table includes the
  # +locking_column+ column (defaults to +lock_version+).
  #
  # @return [Boolean]
  def locking_enabled?; end

  # Reset the column used for optimistic locking back to the +lock_version+ default.
  def reset_locking_column; end

  # Make sure the lock version column gets updated when counters are
  # updated.
  def update_counters(id, counters); end

  private

  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `lock_optimistically`, or
  # `locking_column` would not be picked up.
  def inherited(subclass); end
end

ActiveRecord::Locking::Optimistic::ClassMethods::DEFAULT_LOCKING_COLUMN = T.let(T.unsafe(nil), String)

# Locking::Pessimistic provides support for row-level locking using
# SELECT ... FOR UPDATE and other lock types.
#
# Chain <tt>ActiveRecord::Base#find</tt> to <tt>ActiveRecord::QueryMethods#lock</tt> to obtain an exclusive
# lock on the selected rows:
#   # select * from accounts where id=1 for update
#   Account.lock.find(1)
#
# Call <tt>lock('some locking clause')</tt> to use a database-specific locking clause
# of your own such as 'LOCK IN SHARE MODE' or 'FOR UPDATE NOWAIT'. Example:
#
#   Account.transaction do
#     # select * from accounts where name = 'shugo' limit 1 for update
#     shugo = Account.where("name = 'shugo'").lock(true).first
#     yuko = Account.where("name = 'yuko'").lock(true).first
#     shugo.balance -= 100
#     shugo.save!
#     yuko.balance += 100
#     yuko.save!
#   end
#
# You can also use <tt>ActiveRecord::Base#lock!</tt> method to lock one record by id.
# This may be better if you don't need to lock every row. Example:
#
#   Account.transaction do
#     # select * from accounts where ...
#     accounts = Account.where(...)
#     account1 = accounts.detect { |account| ... }
#     account2 = accounts.detect { |account| ... }
#     # select * from accounts where id=? for update
#     account1.lock!
#     account2.lock!
#     account1.balance -= 100
#     account1.save!
#     account2.balance += 100
#     account2.save!
#   end
#
# You can start a transaction and acquire the lock in one go by calling
# <tt>with_lock</tt> with a block. The block is called from within
# a transaction, the object is already locked. Example:
#
#   account = Account.first
#   account.with_lock do
#     # This block is called within a transaction,
#     # account is already locked.
#     account.balance -= 100
#     account.save!
#   end
#
# Database-specific information on row locking:
#   MySQL: http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html
#   PostgreSQL: http://www.postgresql.org/docs/current/interactive/sql-select.html#SQL-FOR-UPDATE-SHARE
module ActiveRecord::Locking::Pessimistic
  # Obtain a row lock on this record. Reloads the record to obtain the requested
  # lock. Pass an SQL locking clause to append the end of the SELECT statement
  # or pass true for "FOR UPDATE" (the default, an exclusive row lock). Returns
  # the locked record.
  def lock!(lock = T.unsafe(nil)); end

  # Wraps the passed block in a transaction, locking the object
  # before yielding. You can pass the SQL locking clause
  # as argument (see <tt>lock!</tt>).
  def with_lock(lock = T.unsafe(nil)); end
end

class ActiveRecord::LogSubscriber < ::ActiveSupport::LogSubscriber
  # @return [LogSubscriber] a new instance of LogSubscriber
  def initialize; end

  def sql(event); end

  private

  def colorize_payload_name(name, payload_name); end
  def logger; end
  def render_bind(attr, value); end
  def sql_color(sql); end
  def type_casted_binds(casted_binds); end

  class << self
    def reset_runtime; end
    def runtime; end
    def runtime=(value); end
  end
end

ActiveRecord::LogSubscriber::IGNORE_PAYLOAD_NAMES = T.let(T.unsafe(nil), Array)

# = Active Record Migrations
#
# Migrations can manage the evolution of a schema used by several physical
# databases. It's a solution to the common problem of adding a field to make
# a new feature work in your local database, but being unsure of how to
# push that change to other developers and to the production server. With
# migrations, you can describe the transformations in self-contained classes
# that can be checked into version control systems and executed against
# another database that might be one, two, or five versions behind.
#
# Example of a simple migration:
#
#   class AddSsl < ActiveRecord::Migration[5.0]
#     def up
#       add_column :accounts, :ssl_enabled, :boolean, default: true
#     end
#
#     def down
#       remove_column :accounts, :ssl_enabled
#     end
#   end
#
# This migration will add a boolean flag to the accounts table and remove it
# if you're backing out of the migration. It shows how all migrations have
# two methods +up+ and +down+ that describes the transformations
# required to implement or remove the migration. These methods can consist
# of both the migration specific methods like +add_column+ and +remove_column+,
# but may also contain regular Ruby code for generating data needed for the
# transformations.
#
# Example of a more complex migration that also needs to initialize data:
#
#   class AddSystemSettings < ActiveRecord::Migration[5.0]
#     def up
#       create_table :system_settings do |t|
#         t.string  :name
#         t.string  :label
#         t.text    :value
#         t.string  :type
#         t.integer :position
#       end
#
#       SystemSetting.create  name:  'notice',
#                             label: 'Use notice?',
#                             value: 1
#     end
#
#     def down
#       drop_table :system_settings
#     end
#   end
#
# This migration first adds the +system_settings+ table, then creates the very
# first row in it using the Active Record model that relies on the table. It
# also uses the more advanced +create_table+ syntax where you can specify a
# complete table schema in one block call.
#
# == Available transformations
#
# === Creation
#
# * <tt>create_join_table(table_1, table_2, options)</tt>: Creates a join
#   table having its name as the lexical order of the first two
#   arguments. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#create_join_table for
#   details.
# * <tt>create_table(name, options)</tt>: Creates a table called +name+ and
#   makes the table object available to a block that can then add columns to it,
#   following the same format as +add_column+. See example above. The options hash
#   is for fragments like "DEFAULT CHARSET=UTF-8" that are appended to the create
#   table definition.
# * <tt>add_column(table_name, column_name, type, options)</tt>: Adds a new column
#   to the table called +table_name+
#   named +column_name+ specified to be one of the following types:
#   <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:float</tt>,
#   <tt>:decimal</tt>, <tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>,
#   <tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>. A default value can be
#   specified by passing an +options+ hash like <tt>{ default: 11 }</tt>.
#   Other options include <tt>:limit</tt> and <tt>:null</tt> (e.g.
#   <tt>{ limit: 50, null: false }</tt>) -- see
#   ActiveRecord::ConnectionAdapters::TableDefinition#column for details.
# * <tt>add_foreign_key(from_table, to_table, options)</tt>: Adds a new
#   foreign key. +from_table+ is the table with the key column, +to_table+ contains
#   the referenced primary key.
# * <tt>add_index(table_name, column_names, options)</tt>: Adds a new index
#   with the name of the column. Other options include
#   <tt>:name</tt>, <tt>:unique</tt> (e.g.
#   <tt>{ name: 'users_name_index', unique: true }</tt>) and <tt>:order</tt>
#   (e.g. <tt>{ order: { name: :desc } }</tt>).
# * <tt>add_reference(:table_name, :reference_name)</tt>: Adds a new column
#   +reference_name_id+ by default an integer. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#add_reference for details.
# * <tt>add_timestamps(table_name, options)</tt>: Adds timestamps (+created_at+
#   and +updated_at+) columns to +table_name+.
#
# === Modification
#
# * <tt>change_column(table_name, column_name, type, options)</tt>:  Changes
#   the column to a different type using the same parameters as add_column.
# * <tt>change_column_default(table_name, column_name, default)</tt>: Sets a
#   default value for +column_name+ defined by +default+ on +table_name+.
# * <tt>change_column_null(table_name, column_name, null, default = nil)</tt>:
#   Sets or removes a +NOT NULL+ constraint on +column_name+. The +null+ flag
#   indicates whether the value can be +NULL+. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#change_column_null for
#   details.
# * <tt>change_table(name, options)</tt>: Allows to make column alterations to
#   the table called +name+. It makes the table object available to a block that
#   can then add/remove columns, indexes or foreign keys to it.
# * <tt>rename_column(table_name, column_name, new_column_name)</tt>: Renames
#   a column but keeps the type and content.
# * <tt>rename_index(table_name, old_name, new_name)</tt>: Renames an index.
# * <tt>rename_table(old_name, new_name)</tt>: Renames the table called +old_name+
#   to +new_name+.
#
# === Deletion
#
# * <tt>drop_table(name)</tt>: Drops the table called +name+.
# * <tt>drop_join_table(table_1, table_2, options)</tt>: Drops the join table
#   specified by the given arguments.
# * <tt>remove_column(table_name, column_name, type, options)</tt>: Removes the column
#   named +column_name+ from the table called +table_name+.
# * <tt>remove_columns(table_name, *column_names)</tt>: Removes the given
#   columns from the table definition.
# * <tt>remove_foreign_key(from_table, options_or_to_table)</tt>: Removes the
#   given foreign key from the table called +table_name+.
# * <tt>remove_index(table_name, column: column_names)</tt>: Removes the index
#   specified by +column_names+.
# * <tt>remove_index(table_name, name: index_name)</tt>: Removes the index
#   specified by +index_name+.
# * <tt>remove_reference(table_name, ref_name, options)</tt>: Removes the
#   reference(s) on +table_name+ specified by +ref_name+.
# * <tt>remove_timestamps(table_name, options)</tt>: Removes the timestamp
#   columns (+created_at+ and +updated_at+) from the table definition.
#
# == Irreversible transformations
#
# Some transformations are destructive in a manner that cannot be reversed.
# Migrations of that kind should raise an <tt>ActiveRecord::IrreversibleMigration</tt>
# exception in their +down+ method.
#
# == Running migrations from within Rails
#
# The Rails package has several tools to help create and apply migrations.
#
# To generate a new migration, you can use
#   rails generate migration MyNewMigration
#
# where MyNewMigration is the name of your migration. The generator will
# create an empty migration file <tt>timestamp_my_new_migration.rb</tt>
# in the <tt>db/migrate/</tt> directory where <tt>timestamp</tt> is the
# UTC formatted date and time that the migration was generated.
#
# There is a special syntactic shortcut to generate migrations that add fields to a table.
#
#   rails generate migration add_fieldname_to_tablename fieldname:string
#
# This will generate the file <tt>timestamp_add_fieldname_to_tablename.rb</tt>, which will look like this:
#   class AddFieldnameToTablename < ActiveRecord::Migration[5.0]
#     def change
#       add_column :tablenames, :fieldname, :string
#     end
#   end
#
# To run migrations against the currently configured database, use
# <tt>rails db:migrate</tt>. This will update the database by running all of the
# pending migrations, creating the <tt>schema_migrations</tt> table
# (see "About the schema_migrations table" section below) if missing. It will also
# invoke the db:schema:dump task, which will update your db/schema.rb file
# to match the structure of your database.
#
# To roll the database back to a previous migration version, use
# <tt>rails db:migrate VERSION=X</tt> where <tt>X</tt> is the version to which
# you wish to downgrade. Alternatively, you can also use the STEP option if you
# wish to rollback last few migrations. <tt>rails db:migrate STEP=2</tt> will rollback
# the latest two migrations.
#
# If any of the migrations throw an <tt>ActiveRecord::IrreversibleMigration</tt> exception,
# that step will fail and you'll have some manual work to do.
#
# == Database support
#
# Migrations are currently supported in MySQL, PostgreSQL, SQLite,
# SQL Server, and Oracle (all supported databases except DB2).
#
# == More examples
#
# Not all migrations change the schema. Some just fix the data:
#
#   class RemoveEmptyTags < ActiveRecord::Migration[5.0]
#     def up
#       Tag.all.each { |tag| tag.destroy if tag.pages.empty? }
#     end
#
#     def down
#       # not much we can do to restore deleted data
#       raise ActiveRecord::IrreversibleMigration, "Can't recover the deleted tags"
#     end
#   end
#
# Others remove columns when they migrate up instead of down:
#
#   class RemoveUnnecessaryItemAttributes < ActiveRecord::Migration[5.0]
#     def up
#       remove_column :items, :incomplete_items_count
#       remove_column :items, :completed_items_count
#     end
#
#     def down
#       add_column :items, :incomplete_items_count
#       add_column :items, :completed_items_count
#     end
#   end
#
# And sometimes you need to do something in SQL not abstracted directly by migrations:
#
#   class MakeJoinUnique < ActiveRecord::Migration[5.0]
#     def up
#       execute "ALTER TABLE `pages_linked_pages` ADD UNIQUE `page_id_linked_page_id` (`page_id`,`linked_page_id`)"
#     end
#
#     def down
#       execute "ALTER TABLE `pages_linked_pages` DROP INDEX `page_id_linked_page_id`"
#     end
#   end
#
# == Using a model after changing its table
#
# Sometimes you'll want to add a column in a migration and populate it
# immediately after. In that case, you'll need to make a call to
# <tt>Base#reset_column_information</tt> in order to ensure that the model has the
# latest column data from after the new column was added. Example:
#
#   class AddPeopleSalary < ActiveRecord::Migration[5.0]
#     def up
#       add_column :people, :salary, :integer
#       Person.reset_column_information
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#   end
#
# == Controlling verbosity
#
# By default, migrations will describe the actions they are taking, writing
# them to the console as they happen, along with benchmarks describing how
# long each step took.
#
# You can quiet them down by setting ActiveRecord::Migration.verbose = false.
#
# You can also insert your own messages and benchmarks by using the +say_with_time+
# method:
#
#   def up
#     ...
#     say_with_time "Updating salaries..." do
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#     ...
#   end
#
# The phrase "Updating salaries..." would then be printed, along with the
# benchmark for the block when the block completes.
#
# == Timestamped Migrations
#
# By default, Rails generates migrations that look like:
#
#    20080717013526_your_migration_name.rb
#
# The prefix is a generation timestamp (in UTC).
#
# If you'd prefer to use numeric prefixes, you can turn timestamped migrations
# off by setting:
#
#    config.active_record.timestamped_migrations = false
#
# In application.rb.
#
# == Reversible Migrations
#
# Reversible migrations are migrations that know how to go +down+ for you.
# You simply supply the +up+ logic, and the Migration system figures out
# how to execute the down commands for you.
#
# To define a reversible migration, define the +change+ method in your
# migration like this:
#
#   class TenderloveMigration < ActiveRecord::Migration[5.0]
#     def change
#       create_table(:horses) do |t|
#         t.column :content, :text
#         t.column :remind_at, :datetime
#       end
#     end
#   end
#
# This migration will create the horses table for you on the way up, and
# automatically figure out how to drop the table on the way down.
#
# Some commands like +remove_column+ cannot be reversed.  If you care to
# define how to move up and down in these cases, you should define the +up+
# and +down+ methods as before.
#
# If a command cannot be reversed, an
# <tt>ActiveRecord::IrreversibleMigration</tt> exception will be raised when
# the migration is moving down.
#
# For a list of commands that are reversible, please see
# <tt>ActiveRecord::Migration::CommandRecorder</tt>.
#
# == Transactional Migrations
#
# If the database adapter supports DDL transactions, all migrations will
# automatically be wrapped in a transaction. There are queries that you
# can't execute inside a transaction though, and for these situations
# you can turn the automatic transactions off.
#
#   class ChangeEnum < ActiveRecord::Migration[5.0]
#     disable_ddl_transaction!
#
#     def up
#       execute "ALTER TYPE model_size ADD VALUE 'new_value'"
#     end
#   end
#
# Remember that you can still open your own transactions, even if you
# are in a Migration with <tt>self.disable_ddl_transaction!</tt>.
class ActiveRecord::Migration
  # @return [Migration] a new instance of Migration
  def initialize(name = T.unsafe(nil), version = T.unsafe(nil)); end

  def announce(message); end
  def connection; end
  def copy(destination, sources, options = T.unsafe(nil)); end
  def disable_ddl_transaction; end
  def down; end
  def exec_migration(conn, direction); end
  def method_missing(method, *arguments, &block); end

  # Execute this migration in the named direction
  def migrate(direction); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Determines the version number of the next migration.
  def next_migration_number(number); end

  # Finds the correct table name given an Active Record object.
  # Uses the Active Record object's own table_name, or pre/suffix from the
  # options passed in.
  def proper_table_name(name, options = T.unsafe(nil)); end

  # Used to specify an operation that can be run in one direction or another.
  # Call the methods +up+ and +down+ of the yielded object to run a block
  # only in one given direction.
  # The whole block will be called in the right order within the migration.
  #
  # In the following example, the looping on users will always be done
  # when the three columns 'first_name', 'last_name' and 'full_name' exist,
  # even when migrating down:
  #
  #    class SplitNameMigration < ActiveRecord::Migration[5.0]
  #      def change
  #        add_column :users, :first_name, :string
  #        add_column :users, :last_name, :string
  #
  #        reversible do |dir|
  #          User.reset_column_information
  #          User.all.each do |u|
  #            dir.up   { u.first_name, u.last_name = u.full_name.split(' ') }
  #            dir.down { u.full_name = "#{u.first_name} #{u.last_name}" }
  #            u.save
  #          end
  #        end
  #
  #        revert { add_column :users, :full_name, :string }
  #      end
  #    end
  def reversible; end

  # Reverses the migration commands for the given block and
  # the given migrations.
  #
  # The following migration will remove the table 'horses'
  # and create the table 'apples' on the way up, and the reverse
  # on the way down.
  #
  #   class FixTLMigration < ActiveRecord::Migration[5.0]
  #     def change
  #       revert do
  #         create_table(:horses) do |t|
  #           t.text :content
  #           t.datetime :remind_at
  #         end
  #       end
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # Or equivalently, if +TenderloveMigration+ is defined as in the
  # documentation for Migration:
  #
  #   require_relative '20121212123456_tenderlove_migration'
  #
  #   class FixupTLMigration < ActiveRecord::Migration[5.0]
  #     def change
  #       revert TenderloveMigration
  #
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # This command can be nested.
  def revert(*migration_classes); end

  # @return [Boolean]
  def reverting?; end

  # Runs the given migration classes.
  # Last argument can specify options:
  # - :direction (default is :up)
  # - :revert (default is false)
  def run(*migration_classes); end

  def say(message, subitem = T.unsafe(nil)); end
  def say_with_time(message); end
  def suppress_messages; end

  # Builds a hash for use in ActiveRecord::Migration#proper_table_name using
  # the Active Record object's table_name prefix and suffix
  def table_name_options(config = T.unsafe(nil)); end

  def up; end
  def verbose; end
  def verbose=(obj); end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end

  def write(text = T.unsafe(nil)); end

  private

  def execute_block; end

  class << self
    def [](version); end

    # Raises <tt>ActiveRecord::PendingMigrationError</tt> error if any migrations are pending.
    #
    # @raise [ActiveRecord::PendingMigrationError]
    def check_pending!(connection = T.unsafe(nil)); end

    def current_version; end
    def delegate; end
    def delegate=(_arg0); end
    def disable_ddl_transaction; end

    # Disable the transaction wrapping this migration.
    # You can still create your own transactions even after calling #disable_ddl_transaction!
    #
    # For more details read the {"Transactional Migrations" section above}[rdoc-ref:Migration].
    def disable_ddl_transaction!; end

    def disable_ddl_transaction=(_arg0); end
    def inherited(subclass); end
    def load_schema_if_pending!; end
    def maintain_test_schema!; end
    def method_missing(name, *args, &block); end
    def migrate(direction); end
    def nearest_delegate; end
    def verbose; end
    def verbose=(obj); end
  end
end

# This class is used to verify that all migrations have been run before
# loading a web page if <tt>config.active_record.migration_error</tt> is set to :page_load
class ActiveRecord::Migration::CheckPending
  # @return [CheckPending] a new instance of CheckPending
  def initialize(app); end

  def call(env); end

  private

  def connection; end
end

# <tt>ActiveRecord::Migration::CommandRecorder</tt> records commands done during
# a migration and knows how to reverse those commands. The CommandRecorder
# knows how to invert the following commands:
#
# * add_column
# * add_foreign_key
# * add_index
# * add_reference
# * add_timestamps
# * change_column
# * change_column_default (must supply a :from and :to option)
# * change_column_null
# * create_join_table
# * create_table
# * disable_extension
# * drop_join_table
# * drop_table (must supply a block)
# * enable_extension
# * remove_column (must supply a type)
# * remove_columns (must specify at least one column name or more)
# * remove_foreign_key (must supply a second table)
# * remove_index
# * remove_reference
# * remove_timestamps
# * rename_column
# * rename_index
# * rename_table
class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions

  # @return [CommandRecorder] a new instance of CommandRecorder
  def initialize(delegate = T.unsafe(nil)); end

  def add_belongs_to(*args, &block); end
  def add_column(*args, &block); end
  def add_foreign_key(*args, &block); end
  def add_index(*args, &block); end
  def add_reference(*args, &block); end
  def add_timestamps(*args, &block); end
  def change_column(*args, &block); end
  def change_column_default(*args, &block); end
  def change_column_null(*args, &block); end

  # @yield [delegate.update_table_definition(table_name, self)]
  def change_table(table_name, options = T.unsafe(nil)); end

  # Returns the value of attribute commands.
  def commands; end

  # Sets the attribute commands
  #
  # @param value the value to set the attribute commands to.
  def commands=(_arg0); end

  def create_join_table(*args, &block); end
  def create_table(*args, &block); end

  # Returns the value of attribute delegate.
  def delegate; end

  # Sets the attribute delegate
  #
  # @param value the value to set the attribute delegate to.
  def delegate=(_arg0); end

  def disable_extension(*args, &block); end
  def drop_join_table(*args, &block); end
  def drop_table(*args, &block); end
  def enable_extension(*args, &block); end
  def execute(*args, &block); end
  def execute_block(*args, &block); end

  # Returns the inverse of the given command. For example:
  #
  #   recorder.inverse_of(:rename_table, [:old, :new])
  #   # => [:rename_table, [:new, :old]]
  #
  # This method will raise an +IrreversibleMigration+ exception if it cannot
  # invert the +command+.
  #
  # @raise [IrreversibleMigration]
  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end
  def invert_remove_belongs_to(args, &block); end

  # Record +command+. +command+ should be a method name and arguments.
  # For example:
  #
  #   recorder.record(:method_name, [:arg1, :arg2])
  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end
  def remove_column(*args, &block); end
  def remove_columns(*args, &block); end
  def remove_foreign_key(*args, &block); end
  def remove_index(*args, &block); end
  def remove_reference(*args, &block); end
  def remove_timestamps(*args, &block); end
  def rename_column(*args, &block); end
  def rename_index(*args, &block); end
  def rename_table(*args, &block); end

  # @return [Boolean]
  def respond_to?(*args); end

  # While executing the given block, the recorded will be in reverting mode.
  # All commands recorded will end up being recorded reverted
  # and in reverse order.
  # For example:
  #
  #   recorder.revert{ recorder.record(:rename_table, [:old, :new]) }
  #   # same effect as recorder.record(:rename_table, [:new, :old])
  def revert; end

  # Returns the value of attribute reverting.
  def reverting; end

  # Sets the attribute reverting
  #
  # @param value the value to set the attribute reverting to.
  def reverting=(_arg0); end

  def transaction(*args, &block); end

  private

  def invert_add_foreign_key(args); end
  def invert_add_index(args); end
  def invert_change_column_default(args); end
  def invert_change_column_null(args); end
  def invert_drop_table(args, &block); end

  # @raise [ActiveRecord::IrreversibleMigration]
  def invert_remove_column(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  def invert_remove_foreign_key(args); end

  def invert_remove_index(args); end
  def invert_rename_column(args); end
  def invert_rename_index(args); end
  def invert_rename_table(args); end

  # Forwards any missing method call to the \target.
  def method_missing(method, *args, &block); end
end

ActiveRecord::Migration::CommandRecorder::ReversibleAndIrreversibleMethods = T.let(T.unsafe(nil), Array)

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end
  def invert_add_reference(args, &block); end
  def invert_add_timestamps(args, &block); end
  def invert_create_join_table(args, &block); end
  def invert_create_table(args, &block); end
  def invert_disable_extension(args, &block); end
  def invert_drop_join_table(args, &block); end
  def invert_drop_table(args, &block); end
  def invert_enable_extension(args, &block); end
  def invert_execute_block(args, &block); end
  def invert_remove_column(args, &block); end
  def invert_remove_reference(args, &block); end
  def invert_remove_timestamps(args, &block); end
  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility
  class << self
    def find(version); end
  end
end

module ActiveRecord::Migration::Compatibility::FourTwoShared
  def add_belongs_to(*_arg0, **options); end
  def add_reference(*_arg0, **options); end
  def add_timestamps(*_arg0, **options); end
  def change_table(table_name, options = T.unsafe(nil)); end
  def create_table(table_name, options = T.unsafe(nil)); end

  # @return [Boolean]
  def index_exists?(table_name, column_name, options = T.unsafe(nil)); end

  def remove_index(table_name, options = T.unsafe(nil)); end

  private

  def index_name_for_remove(table_name, options = T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::FourTwoShared::TableDefinition
  def belongs_to(*_arg0, **options); end
  def references(*_arg0, **options); end
  def timestamps(*_arg0, **options); end
end

module ActiveRecord::Migration::Compatibility::Legacy
  include ::ActiveRecord::Migration::Compatibility::FourTwoShared

  def migrate(*_arg0); end
end

class ActiveRecord::Migration::Compatibility::V4_2 < ::ActiveRecord::Migration::Current
  include ::ActiveRecord::Migration::Compatibility::FourTwoShared
end

ActiveRecord::Migration::Compatibility::V5_0 = ActiveRecord::Migration::Current

# This must be defined before the inherited hook, below
class ActiveRecord::Migration::Current < ::ActiveRecord::Migration; end

module ActiveRecord::Migration::JoinTable
  private

  def find_join_table_name(table_1, table_2, options = T.unsafe(nil)); end
  def join_table_name(table_1, table_2); end
end

ActiveRecord::Migration::MigrationFilenameRegexp = T.let(T.unsafe(nil), Regexp)

class ActiveRecord::Migration::ReversibleBlockHelper < ::Struct
  def down; end
  def up; end
end

class ActiveRecord::MigrationError < ::ActiveRecord::ActiveRecordError
  # @return [MigrationError] a new instance of MigrationError
  def initialize(message = T.unsafe(nil)); end
end

# MigrationProxy is used to defer loading of the actual migration classes
# until they are needed
class ActiveRecord::MigrationProxy < ::Struct
  # @return [MigrationProxy] a new instance of MigrationProxy
  def initialize(name, version, filename, scope); end

  def announce(*args, &block); end
  def basename; end
  def disable_ddl_transaction(*args, &block); end
  def migrate(*args, &block); end
  def mtime; end
  def write(*args, &block); end

  private

  def load_migration; end
  def migration; end
end

class ActiveRecord::Migrator
  # @raise [StandardError]
  # @return [Migrator] a new instance of Migrator
  def initialize(direction, migrations, target_version = T.unsafe(nil)); end

  def current; end
  def current_migration; end
  def current_version; end
  def load_migrated; end
  def migrate; end
  def migrated; end
  def migrations; end
  def pending_migrations; end
  def run; end
  def runnable; end

  private

  # Wrap the migration in a transaction only if supported by the adapter.
  def ddl_transaction(migration); end

  # @return [Boolean]
  def down?; end

  def execute_migration_in_transaction(migration, direction); end
  def finish; end
  def generate_migrator_advisory_lock_id; end

  # Return true if a valid version is not provided.
  #
  # @return [Boolean]
  def invalid_target?; end

  # Used for running multiple migrations up to or down to a certain value.
  def migrate_without_lock; end

  # @return [Boolean]
  def ran?(migration); end

  # Stores the current environment in the database.
  def record_environment; end

  def record_version_state_after_migrating(version); end

  # Used for running a specific migration.
  #
  # @raise [UnknownMigrationVersionError]
  def run_without_lock; end

  def start; end
  def target; end

  # @return [Boolean]
  def up?; end

  # @return [Boolean]
  def use_advisory_lock?; end

  # @return [Boolean]
  def use_transaction?(migration); end

  # @raise [DuplicateMigrationNameError]
  def validate(migrations); end

  def with_advisory_lock; end

  class << self
    # @return [Boolean]
    def any_migrations?; end

    def current_environment; end
    def current_version(connection = T.unsafe(nil)); end
    def down(migrations_paths, target_version = T.unsafe(nil)); end
    def forward(migrations_paths, steps = T.unsafe(nil)); end
    def get_all_versions(connection = T.unsafe(nil)); end
    def last_migration; end

    # @raise [NoEnvironmentInSchemaError]
    def last_stored_environment; end

    def migrate(migrations_paths, target_version = T.unsafe(nil), &block); end
    def migration_files(paths); end
    def migrations(paths); end

    # Sets the attribute migrations_paths
    #
    # @param value the value to set the attribute migrations_paths to.
    def migrations_path=(_arg0); end

    def migrations_paths; end

    # Sets the attribute migrations_paths
    #
    # @param value the value to set the attribute migrations_paths to.
    def migrations_paths=(_arg0); end

    def migrations_status(paths); end

    # @return [Boolean]
    def needs_migration?(connection = T.unsafe(nil)); end

    def open(migrations_paths); end
    def parse_migration_filename(filename); end

    # @return [Boolean]
    def protected_environment?; end

    def rollback(migrations_paths, steps = T.unsafe(nil)); end
    def run(direction, migrations_paths, target_version); end
    def schema_migrations_table_name; end
    def up(migrations_paths, target_version = T.unsafe(nil)); end

    private

    def move(direction, migrations_paths, steps); end
  end
end

ActiveRecord::Migrator::MIGRATOR_SALT = T.let(T.unsafe(nil), Integer)

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::ModelSchema::ClassMethods

  class << self
    # Derives the join table name for +first_table+ and +second_table+. The
    # table names appear in alphabetical order. A common prefix is removed
    # (useful for namespaced models like Music::Artist and Music::Record):
    #
    #   artists, records => artists_records
    #   records, artists => artists_records
    #   music_artists, music_records => music_artists_records
    def derive_join_table_name(first_table, second_table); end
  end

  module GeneratedClassMethods
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(value); end
    def internal_metadata_table_name?; end
    def pluralize_table_names; end
    def pluralize_table_names=(value); end
    def pluralize_table_names?; end
    def protected_environments; end
    def protected_environments=(value); end
    def protected_environments?; end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(value); end
    def schema_migrations_table_name?; end
    def table_name_prefix; end
    def table_name_prefix=(value); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(value); end
    def table_name_suffix?; end
  end

  module GeneratedInstanceMethods
    def pluralize_table_names; end
    def pluralize_table_names?; end
    def table_name_prefix; end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix?; end
  end
end

module ActiveRecord::ModelSchema::ClassMethods
  def _default_attributes; end
  def attribute_types; end
  def attributes_builder; end

  # Returns a hash where the keys are column names and the values are
  # default values when instantiating the Active Record object for this table.
  def column_defaults; end

  # Returns an array of column names as strings.
  def column_names; end

  def columns; end
  def columns_hash; end

  # Returns an array of column objects where the primary id, all columns ending in "_id" or "_count",
  # and columns used for single table inheritance have been removed.
  def content_columns; end

  def full_table_name_prefix; end
  def full_table_name_suffix; end

  # The list of columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  def ignored_columns; end

  # Sets the columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  def ignored_columns=(columns); end

  # Defines the name of the table column which will store the class name on single-table
  # inheritance situations.
  #
  # The default inheritance column name is +type+, which means it's a
  # reserved word inside Active Record. To be able to use single-table
  # inheritance with another column name, or to use the column +type+ in
  # your own model for something else, you can set +inheritance_column+:
  #
  #     self.inheritance_column = 'zoink'
  def inheritance_column; end

  # Sets the value of inheritance_column
  def inheritance_column=(value); end

  # Returns the next value that will be used as the primary key on
  # an insert statement.
  def next_sequence_value; end

  # Determines if the primary key values should be selected from their
  # corresponding sequence before the insert statement.
  #
  # @return [Boolean]
  def prefetch_primary_key?; end

  # Returns a quoted version of the table name, used to construct SQL statements.
  def quoted_table_name; end

  # Resets all the cached information about columns, which will cause them
  # to be reloaded on the next request.
  #
  # The most common usage pattern for this method is probably in a migration,
  # when just after creating a table you want to populate it with some default
  # values, eg:
  #
  #  class CreateJobLevels < ActiveRecord::Migration[5.0]
  #    def up
  #      create_table :job_levels do |t|
  #        t.integer :id
  #        t.string :name
  #
  #        t.timestamps
  #      end
  #
  #      JobLevel.reset_column_information
  #      %w{assistant executive manager director}.each do |type|
  #        JobLevel.create(name: type)
  #      end
  #    end
  #
  #    def down
  #      drop_table :job_levels
  #    end
  #  end
  def reset_column_information; end

  def reset_sequence_name; end

  # Computes the table name, (re)sets it internally, and returns it.
  def reset_table_name; end

  def sequence_name; end

  # Sets the name of the sequence to use when generating ids to the given
  # value, or (if the value is nil or false) to the value returned by the
  # given block. This is required for Oracle and is useful for any
  # database which relies on sequences for primary key generation.
  #
  # If a sequence name is not explicitly set when using Oracle,
  # it will default to the commonly used pattern of: #{table_name}_seq
  #
  # If a sequence name is not explicitly set when using PostgreSQL, it
  # will discover the sequence corresponding to your primary key for you.
  #
  #   class Project < ActiveRecord::Base
  #     self.sequence_name = "projectseq"   # default would have been "project_seq"
  #   end
  def sequence_name=(value); end

  # Indicates whether the table associated with this class exists
  #
  # @return [Boolean]
  def table_exists?; end

  # Guesses the table name (in forced lower-case) based on the name of the class in the
  # inheritance hierarchy descending directly from ActiveRecord::Base. So if the hierarchy
  # looks like: Reply < Message < ActiveRecord::Base, then Message is used
  # to guess the table name even when called on Reply. The rules used to do the guess
  # are handled by the Inflector class in Active Support, which knows almost all common
  # English inflections. You can add new inflections in config/initializers/inflections.rb.
  #
  # Nested classes are given table names prefixed by the singular form of
  # the parent's table name. Enclosing modules are not considered.
  #
  # ==== Examples
  #
  #   class Invoice < ActiveRecord::Base
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice             invoices
  #
  #   class Invoice < ActiveRecord::Base
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice::Lineitem   invoice_lineitems
  #
  #   module Invoice
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
  #
  # Additionally, the class-level +table_name_prefix+ is prepended and the
  # +table_name_suffix+ is appended. So if you have "myapp_" as a prefix,
  # the table name guess for an Invoice class becomes "myapp_invoices".
  # Invoice::Lineitem becomes "myapp_invoice_lineitems".
  #
  # You can also set your own table name explicitly:
  #
  #   class Mouse < ActiveRecord::Base
  #     self.table_name = "mice"
  #   end
  def table_name; end

  # Sets the table name explicitly. Example:
  #
  #   class Project < ActiveRecord::Base
  #     self.table_name = "project"
  #   end
  def table_name=(value); end

  # Returns the type of the attribute with the given name, after applying
  # all modifiers. This method is the only valid source of information for
  # anything related to the types of a model's attributes. This method will
  # access the database and load the model's schema if it is required.
  #
  # The return value of this method will implement the interface described
  # by ActiveModel::Type::Value (though the object itself may not subclass
  # it).
  #
  # +attr_name+ The name of the attribute to retrieve the type for. Must be
  # a string
  def type_for_attribute(attr_name, &block); end

  protected

  def initialize_load_schema_monitor; end

  private

  # Computes and returns a table name according to default conventions.
  def compute_table_name; end

  def inherited(child_class); end
  def load_schema; end
  def load_schema!; end
  def reload_schema_from_cache; end

  # @return [Boolean]
  def schema_loaded?; end

  # Guesses the table name, but does not decorate it with prefix and suffix information.
  def undecorated_table_name(class_name = T.unsafe(nil)); end

  def warn_if_deprecated_type(column); end
end

# Raised when there are multiple errors while doing a mass assignment through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=]
# method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
# objects, each corresponding to the error while assigning to an attribute.
class ActiveRecord::MultiparameterAssignmentErrors < ::ActiveRecord::ActiveRecordError
  # @return [MultiparameterAssignmentErrors] a new instance of MultiparameterAssignmentErrors
  def initialize(errors = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  def errors; end
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::NestedAttributes::ClassMethods

  # Returns ActiveRecord::AutosaveAssociation::marked_for_destruction? It's
  # used in conjunction with fields_for to build a form element for the
  # destruction of this association.
  #
  # See ActionView::Helpers::FormHelper::fields_for for more info.
  def _destroy; end

  private

  # @return [Boolean]
  def allow_destroy?(association_name); end

  # Assigns the given attributes to the collection association.
  #
  # Hashes with an <tt>:id</tt> value matching an existing associated record
  # will update that record. Hashes without an <tt>:id</tt> value will build
  # a new record for the association. Hashes with a matching <tt>:id</tt>
  # value and a <tt>:_destroy</tt> key set to a truthy value will mark the
  # matched record for destruction.
  #
  # For example:
  #
  #   assign_nested_attributes_for_collection_association(:people, {
  #     '1' => { id: '1', name: 'Peter' },
  #     '2' => { name: 'John' },
  #     '3' => { id: '2', _destroy: true }
  #   })
  #
  # Will update the name of the Person with ID 1, build a new associated
  # person with the name 'John', and mark the associated Person with ID 2
  # for destruction.
  #
  # Also accepts an Array of attribute hashes:
  #
  #   assign_nested_attributes_for_collection_association(:people, [
  #     { id: '1', name: 'Peter' },
  #     { name: 'John' },
  #     { id: '2', _destroy: true }
  #   ])
  def assign_nested_attributes_for_collection_association(association_name, attributes_collection); end

  # Assigns the given attributes to the association.
  #
  # If an associated record does not yet exist, one will be instantiated. If
  # an associated record already exists, the method's behavior depends on
  # the value of the update_only option. If update_only is +false+ and the
  # given attributes include an <tt>:id</tt> that matches the existing record's
  # id, then the existing record will be modified. If no <tt>:id</tt> is provided
  # it will be replaced with a new record. If update_only is +true+ the existing
  # record will be modified regardless of whether an <tt>:id</tt> is provided.
  #
  # If the given attributes include a matching <tt>:id</tt> attribute, or
  # update_only is true, and a <tt>:_destroy</tt> key set to a truthy value,
  # then the existing record will be marked for destruction.
  def assign_nested_attributes_for_one_to_one_association(association_name, attributes); end

  # Updates a record with the +attributes+ or marks it for destruction if
  # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.
  def assign_to_or_mark_for_destruction(record, attributes, allow_destroy); end

  # Determines if a record with the particular +attributes+ should be
  # rejected by calling the reject_if Symbol or Proc (if defined).
  # The reject_if option is defined by +accepts_nested_attributes_for+.
  #
  # Returns false if there is a +destroy_flag+ on the attributes.
  def call_reject_if(association_name, attributes); end

  # Takes in a limit and checks if the attributes_collection has too many
  # records. It accepts limit in the form of symbol, proc, or
  # number-like object (anything that can be compared with an integer).
  #
  # Raises TooManyRecords error if the attributes_collection is
  # larger than the limit.
  def check_record_limit!(limit, attributes_collection); end

  # Determines if a hash contains a truthy _destroy key.
  #
  # @return [Boolean]
  def has_destroy_flag?(hash); end

  # @raise [RecordNotFound]
  def raise_nested_attributes_record_not_found!(association_name, record_id); end

  # Determines if a new record should be rejected by checking
  # has_destroy_flag? or if a <tt>:reject_if</tt> proc exists for this
  # association and evaluates to +true+.
  #
  # @return [Boolean]
  def reject_new_record?(association_name, attributes); end

  # Only take into account the destroy flag if <tt>:allow_destroy</tt> is true
  #
  # @return [Boolean]
  def will_be_destroyed?(association_name, attributes); end

  module GeneratedClassMethods
    def nested_attributes_options; end
    def nested_attributes_options=(value); end
    def nested_attributes_options?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes_options; end
    def nested_attributes_options?; end
  end
end

# = Active Record Nested Attributes
#
# Nested attributes allow you to save attributes on associated records
# through the parent. By default nested attribute updating is turned off
# and you can enable it using the accepts_nested_attributes_for class
# method. When you enable nested attributes an attribute writer is
# defined on the model.
#
# The attribute writer is named after the association, which means that
# in the following example, two new methods are added to your model:
#
# <tt>author_attributes=(attributes)</tt> and
# <tt>pages_attributes=(attributes)</tt>.
#
#   class Book < ActiveRecord::Base
#     has_one :author
#     has_many :pages
#
#     accepts_nested_attributes_for :author, :pages
#   end
#
# Note that the <tt>:autosave</tt> option is automatically enabled on every
# association that accepts_nested_attributes_for is used for.
#
# === One-to-one
#
# Consider a Member model that has one Avatar:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#   end
#
# Enabling nested attributes on a one-to-one association allows you to
# create the member and avatar in one go:
#
#   params = { member: { name: 'Jack', avatar_attributes: { icon: 'smiling' } } }
#   member = Member.create(params[:member])
#   member.avatar.id # => 2
#   member.avatar.icon # => 'smiling'
#
# It also allows you to update the avatar through the member:
#
#   params = { member: { avatar_attributes: { id: '2', icon: 'sad' } } }
#   member.update params[:member]
#   member.avatar.icon # => 'sad'
#
# By default you will only be able to set and update attributes on the
# associated model. If you want to destroy the associated model through the
# attributes hash, you have to enable it first using the
# <tt>:allow_destroy</tt> option.
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar, allow_destroy: true
#   end
#
# Now, when you add the <tt>_destroy</tt> key to the attributes hash, with a
# value that evaluates to +true+, you will destroy the associated model:
#
#   member.avatar_attributes = { id: '2', _destroy: '1' }
#   member.avatar.marked_for_destruction? # => true
#   member.save
#   member.reload.avatar # => nil
#
# Note that the model will _not_ be destroyed until the parent is saved.
#
# Also note that the model will not be destroyed unless you also specify
# its id in the updated hash.
#
# === One-to-many
#
# Consider a member that has a number of posts:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts
#   end
#
# You can now set or update attributes on the associated posts through
# an attribute hash for a member: include the key +:posts_attributes+
# with an array of hashes of post attributes as a value.
#
# For each hash that does _not_ have an <tt>id</tt> key a new record will
# be instantiated, unless the hash also contains a <tt>_destroy</tt> key
# that evaluates to +true+.
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '', _destroy: '1' } # this will be ignored
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# You may also set a +:reject_if+ proc to silently ignore any new record
# hashes if they fail to pass your criteria. For example, the previous
# example could be rewritten as:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: proc { |attributes| attributes['title'].blank? }
#   end
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '' } # this will be ignored because of the :reject_if proc
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# Alternatively, +:reject_if+ also accepts a symbol for using methods:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :new_record?
#   end
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :reject_posts
#
#     def reject_posts(attributes)
#       attributes['title'].blank?
#     end
#   end
#
# If the hash contains an <tt>id</tt> key that matches an already
# associated record, the matching record will be modified:
#
#   member.attributes = {
#     name: 'Joe',
#     posts_attributes: [
#       { id: 1, title: '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!' },
#       { id: 2, title: '[UPDATED] other post' }
#     ]
#   }
#
#   member.posts.first.title # => '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!'
#   member.posts.second.title # => '[UPDATED] other post'
#
# However, the above applies if the parent model is being updated as well.
# For example, If you wanted to create a +member+ named _joe_ and wanted to
# update the +posts+ at the same time, that would give an
# ActiveRecord::RecordNotFound error.
#
# By default the associated records are protected from being destroyed. If
# you want to destroy any of the associated records through the attributes
# hash, you have to enable it first using the <tt>:allow_destroy</tt>
# option. This will allow you to also use the <tt>_destroy</tt> key to
# destroy existing records:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, allow_destroy: true
#   end
#
#   params = { member: {
#     posts_attributes: [{ id: '2', _destroy: '1' }]
#   }}
#
#   member.attributes = params[:member]
#   member.posts.detect { |p| p.id == 2 }.marked_for_destruction? # => true
#   member.posts.length # => 2
#   member.save
#   member.reload.posts.length # => 1
#
# Nested attributes for an associated collection can also be passed in
# the form of a hash of hashes instead of an array of hashes:
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: {
#       first:  { title: 'Foo' },
#       second: { title: 'Bar' }
#     }
#   )
#
# has the same effect as
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: [
#       { title: 'Foo' },
#       { title: 'Bar' }
#     ]
#   )
#
# The keys of the hash which is the value for +:posts_attributes+ are
# ignored in this case.
# However, it is not allowed to use <tt>'id'</tt> or <tt>:id</tt> for one of
# such keys, otherwise the hash will be wrapped in an array and
# interpreted as an attribute hash for a single post.
#
# Passing attributes for an associated collection in the form of a hash
# of hashes can be used with hashes generated from HTTP/HTML parameters,
# where there may be no natural way to submit an array of hashes.
#
# === Saving
#
# All changes to models, including the destruction of those marked for
# destruction, are saved and destroyed automatically and atomically when
# the parent model is saved. This happens inside the transaction initiated
# by the parent's save method. See ActiveRecord::AutosaveAssociation.
#
# === Validating the presence of a parent model
#
# If you want to validate that a child record is associated with a parent
# record, you can use the +validates_presence_of+ method and the +:inverse_of+
# key as this example illustrates:
#
#   class Member < ActiveRecord::Base
#     has_many :posts, inverse_of: :member
#     accepts_nested_attributes_for :posts
#   end
#
#   class Post < ActiveRecord::Base
#     belongs_to :member, inverse_of: :posts
#     validates_presence_of :member
#   end
#
# Note that if you do not specify the +:inverse_of+ option, then
# Active Record will try to automatically guess the inverse association
# based on heuristics.
#
# For one-to-one nested associations, if you build the new (in-memory)
# child object yourself before assignment, then this module will not
# overwrite it, e.g.:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#
#     def avatar
#       super || build_avatar(width: 200)
#     end
#   end
#
#   member = Member.new
#   member.avatar_attributes = {icon: 'sad'}
#   member.avatar.width # => 200
module ActiveRecord::NestedAttributes::ClassMethods
  # Defines an attributes writer for the specified association(s).
  #
  # Supported options:
  # [:allow_destroy]
  #   If true, destroys any members from the attributes hash with a
  #   <tt>_destroy</tt> key and a value that evaluates to +true+
  #   (eg. 1, '1', true, or 'true'). This option is off by default.
  # [:reject_if]
  #   Allows you to specify a Proc or a Symbol pointing to a method
  #   that checks whether a record should be built for a certain attribute
  #   hash. The hash is passed to the supplied Proc or the method
  #   and it should return either +true+ or +false+. When no +:reject_if+
  #   is specified, a record will be built for all attribute hashes that
  #   do not have a <tt>_destroy</tt> value that evaluates to true.
  #   Passing <tt>:all_blank</tt> instead of a Proc will create a proc
  #   that will reject a record where all the attributes are blank excluding
  #   any value for +_destroy+.
  # [:limit]
  #   Allows you to specify the maximum number of associated records that
  #   can be processed with the nested attributes. Limit also can be specified
  #   as a Proc or a Symbol pointing to a method that should return a number.
  #   If the size of the nested attributes array exceeds the specified limit,
  #   NestedAttributes::TooManyRecords exception is raised. If omitted, any
  #   number of associations can be processed.
  #   Note that the +:limit+ option is only applicable to one-to-many
  #   associations.
  # [:update_only]
  #   For a one-to-one association, this option allows you to specify how
  #   nested attributes are going to be used when an associated record already
  #   exists. In general, an existing record may either be updated with the
  #   new set of attribute values or be replaced by a wholly new record
  #   containing those values. By default the +:update_only+ option is +false+
  #   and the nested attributes are used to update the existing record only
  #   if they include the record's <tt>:id</tt> value. Otherwise a new
  #   record will be instantiated and used to replace the existing one.
  #   However if the +:update_only+ option is +true+, the nested attributes
  #   are used to update the record's attributes always, regardless of
  #   whether the <tt>:id</tt> is present. The option is ignored for collection
  #   associations.
  #
  # Examples:
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: proc { |attributes| attributes['name'].blank? }
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: :all_blank
  #   # creates avatar_attributes= and posts_attributes=
  #   accepts_nested_attributes_for :avatar, :posts, allow_destroy: true
  def accepts_nested_attributes_for(*attr_names); end

  private

  # Generates a writer method for this association. Serves as a point for
  # accessing the objects in the association. For example, this method
  # could generate the following:
  #
  #   def pirate_attributes=(attributes)
  #     assign_nested_attributes_for_one_to_one_association(:pirate, attributes)
  #   end
  #
  # This redirects the attempts to write objects in an association through
  # the helper methods defined below. Makes it seem like the nested
  # associations are just regular associations.
  def generate_association_writer(association_name, type); end
end

ActiveRecord::NestedAttributes::ClassMethods::REJECT_ALL_BLANK_PROC = T.let(T.unsafe(nil), Proc)
class ActiveRecord::NestedAttributes::TooManyRecords < ::ActiveRecord::ActiveRecordError; end

# Attribute hash keys that should not be assigned as normal attributes.
# These hash keys are nested attributes implementation details.
ActiveRecord::NestedAttributes::UNASSIGNABLE_KEYS = T.let(T.unsafe(nil), Array)

# Raised when a given database does not exist.
class ActiveRecord::NoDatabaseError < ::ActiveRecord::StatementInvalid; end

class ActiveRecord::NoEnvironmentInSchemaError < ::ActiveRecord::MigrationError
  # @return [NoEnvironmentInSchemaError] a new instance of NoEnvironmentInSchemaError
  def initialize; end
end

# = Active Record No Touching
module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::NoTouching::ClassMethods

  # @return [Boolean]
  def no_touching?; end

  def touch(*_arg0); end
  def touch_later(*_arg0); end

  class << self
    # @return [Boolean]
    def applied_to?(klass); end

    def apply_to(klass); end

    private

    def klasses; end
  end
end

module ActiveRecord::NoTouching::ClassMethods
  # Lets you selectively disable calls to `touch` for the
  # duration of a block.
  #
  # ==== Examples
  #   ActiveRecord::Base.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # does nothing
  #   end
  #
  #   Project.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # works, but does not touch the associated project
  #   end
  def no_touching(&block); end
end

class ActiveRecord::NullMigration < ::ActiveRecord::MigrationProxy
  # @return [NullMigration] a new instance of NullMigration
  def initialize; end

  def mtime; end
end

class ActiveRecord::NullMutationTracker
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Boolean]
  def changed?(*_arg0); end

  # @return [Boolean]
  def changed_in_place?(*_arg0); end

  def changed_values; end
  def changes; end
  def forget_change(*_arg0); end
end

module ActiveRecord::NullRelation
  # @return [Boolean]
  def any?; end

  def average(*_arg0); end
  def calculate(operation, _column_name); end
  def count(*_arg0); end
  def delete(_id_or_array); end
  def delete_all(_conditions = T.unsafe(nil)); end

  # @return [Boolean]
  def empty?; end

  def exec_queries; end

  # @return [Boolean]
  def exists?(_conditions = T.unsafe(nil)); end

  # @return [Boolean]
  def many?; end

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  # @return [Boolean]
  def none?; end

  # @return [Boolean]
  def one?; end

  def or(other); end
  def pluck(*column_names); end
  def size; end
  def sum(*_arg0); end
  def to_sql; end
  def update_all(_updates); end
end

class ActiveRecord::PendingMigrationError < ::ActiveRecord::MigrationError
  # @return [PendingMigrationError] a new instance of PendingMigrationError
  def initialize(message = T.unsafe(nil)); end
end

# = Active Record \Persistence
module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Persistence::ClassMethods

  # Returns an instance of the specified +klass+ with the attributes of the
  # current record. This is mostly useful in relation to single-table
  # inheritance structures where you want a subclass to appear as the
  # superclass. This can be used along with record identification in
  # Action Pack to allow, say, <tt>Client < Company</tt> to do something
  # like render <tt>partial: @client.becomes(Company)</tt> to render that
  # instance using the companies/company partial instead of clients/client.
  #
  # Note: The new instance will share a link to the same attributes as the original class.
  # Therefore the sti column value will still be the same.
  # Any change to the attributes on either instance will affect both instances.
  # If you want to change the sti column as well, use #becomes! instead.
  def becomes(klass); end

  # Wrapper around #becomes that also changes the instance's sti column value.
  # This is especially useful if you want to persist the changed class in your
  # database.
  #
  # Note: The old instance's sti column value will be changed too, as both objects
  # share the same set of attributes.
  def becomes!(klass); end

  # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
  # The decrement is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def decrement(attribute, by = T.unsafe(nil)); end

  # Wrapper around #decrement that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Returns +self+.
  def decrement!(attribute, by = T.unsafe(nil)); end

  # Deletes the record in the database and freezes this instance to
  # reflect that no changes should be made (since they can't be
  # persisted). Returns the frozen instance.
  #
  # The row is simply removed with an SQL +DELETE+ statement on the
  # record's primary key, and no callbacks are executed.
  #
  # Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].
  #
  # To enforce the object's +before_destroy+ and +after_destroy+
  # callbacks or any <tt>:dependent</tt> association
  # options, use <tt>#destroy</tt>.
  def delete; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy returns +false+.
  # See ActiveRecord::Callbacks for further details.
  #
  # @raise [ReadOnlyRecord]
  def destroy; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy!. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy! raises ActiveRecord::RecordNotDestroyed.
  # See ActiveRecord::Callbacks for further details.
  def destroy!; end

  # Returns true if this object has been destroyed, otherwise returns false.
  #
  # @return [Boolean]
  def destroyed?; end

  # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
  # The increment is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def increment(attribute, by = T.unsafe(nil)); end

  # Wrapper around #increment that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Returns +self+.
  def increment!(attribute, by = T.unsafe(nil)); end

  # Returns true if this object hasn't been saved yet -- that is, a record
  # for the object doesn't exist in the database yet; otherwise, returns false.
  #
  # @return [Boolean]
  def new_record?; end

  # Returns true if the record is persisted, i.e. it's not a new record and it was
  # not destroyed, otherwise returns false.
  #
  # @return [Boolean]
  def persisted?; end

  # Reloads the record from the database.
  #
  # This method finds record by its primary key (which could be assigned manually) and
  # modifies the receiver in-place:
  #
  #   account = Account.new
  #   # => #<Account id: nil, email: nil>
  #   account.id = 1
  #   account.reload
  #   # Account Load (1.2ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."id" = $1 LIMIT 1  [["id", 1]]
  #   # => #<Account id: 1, email: 'account@example.com'>
  #
  # Attributes are reloaded from the database, and caches busted, in
  # particular the associations cache and the QueryCache.
  #
  # If the record no longer exists in the database ActiveRecord::RecordNotFound
  # is raised. Otherwise, in addition to the in-place modification the method
  # returns +self+ for convenience.
  #
  # The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:
  #
  #   reload(lock: true) # reload with pessimistic locking
  #
  # Reloading is commonly used in test suites to test something is actually
  # written to the database, or when some action modifies the corresponding
  # row in the database but not the object in memory:
  #
  #   assert account.deposit!(25)
  #   assert_equal 25, account.credit        # check it is updated in memory
  #   assert_equal 25, account.reload.credit # check it is also persisted
  #
  # Another common use case is optimistic locking handling:
  #
  #   def with_optimistic_retry
  #     begin
  #       yield
  #     rescue ActiveRecord::StaleObjectError
  #       begin
  #         # Reload lock_version in particular.
  #         reload
  #       rescue ActiveRecord::RecordNotFound
  #         # If the record is gone there is nothing to do.
  #       else
  #         retry
  #       end
  #     end
  #   end
  def reload(options = T.unsafe(nil)); end

  # :call-seq:
  #   save(*args)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, save always runs validations. If any of them fail the action
  # is cancelled and #save returns +false+, and the record won't be saved. However, if you supply
  # validate: false, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save. If any of the
  # <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and
  # #save returns +false+. See ActiveRecord::Callbacks for further
  # details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  def save(*args, &block); end

  # :call-seq:
  #   save!(*args)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, #save! always runs validations. If any of them fail
  # ActiveRecord::RecordInvalid gets raised, and the record won't be saved. However, if you supply
  # validate: false, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save! also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save!. If any of
  # the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled
  # and #save! raises ActiveRecord::RecordNotSaved. See
  # ActiveRecord::Callbacks for further details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  def save!(*args, &block); end

  # Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So
  # if the predicate returns +true+ the attribute will become +false+. This
  # method toggles directly the underlying value without calling any setter.
  # Returns +self+.
  #
  # Example:
  #
  #   user = User.first
  #   user.banned? # => false
  #   user.toggle(:banned)
  #   user.banned? # => true
  def toggle(attribute); end

  # Wrapper around #toggle that saves the record. This method differs from
  # its non-bang version in the sense that it passes through the attribute setter.
  # Saving is not subjected to validation checks. Returns +true+ if the
  # record could be saved.
  def toggle!(attribute); end

  # Saves the record with the updated_at/on attributes set to the current time
  # or the time specified.
  # Please note that no validation is performed and only the +after_touch+,
  # +after_commit+ and +after_rollback+ callbacks are executed.
  #
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with updated_at/on
  # attributes. If no time argument is passed, the current time is used as default.
  #
  #   product.touch                         # updates updated_at/on with current time
  #   product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time
  #   product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on
  #   product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes
  #
  # If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to]
  # then +touch+ will invoke +touch+ method on associated object.
  #
  #   class Brake < ActiveRecord::Base
  #     belongs_to :car, touch: true
  #   end
  #
  #   class Car < ActiveRecord::Base
  #     belongs_to :corporation, touch: true
  #   end
  #
  #   # triggers @brake.car.touch and @brake.car.corporation.touch
  #   @brake.touch
  #
  # Note that +touch+ must be used on a persisted object, or else an
  # ActiveRecordError will be thrown. For example:
  #
  #   ball = Ball.new
  #   ball.touch(:updated_at)   # => raises ActiveRecordError
  def touch(*names, time: T.unsafe(nil)); end

  # Updates the attributes of the model from the passed-in hash and saves the
  # record, all wrapped in a transaction. If the object is invalid, the saving
  # will fail and false will be returned.
  def update(attributes); end

  # Updates its receiver just like #update but calls #save! instead
  # of +save+, so an exception is raised if the record is invalid and saving will fail.
  def update!(attributes); end

  # Updates a single attribute and saves the record.
  # This is especially useful for boolean flags on existing records. Also note that
  #
  # * Validation is skipped.
  # * \Callbacks are invoked.
  # * updated_at/updated_on column is updated if that column is available.
  # * Updates all the attributes that are dirty in this object.
  #
  # This method raises an ActiveRecord::ActiveRecordError  if the
  # attribute is marked as readonly.
  #
  # Also see #update_column.
  def update_attribute(name, value); end

  # Updates the attributes of the model from the passed-in hash and saves the
  # record, all wrapped in a transaction. If the object is invalid, the saving
  # will fail and false will be returned.
  def update_attributes(attributes); end

  # Updates its receiver just like #update but calls #save! instead
  # of +save+, so an exception is raised if the record is invalid and saving will fail.
  def update_attributes!(attributes); end

  # Equivalent to <code>update_columns(name => value)</code>.
  def update_column(name, value); end

  # Updates the attributes directly in the database issuing an UPDATE SQL
  # statement and sets them in the receiver:
  #
  #   user.update_columns(last_request_at: Time.current)
  #
  # This is the fastest way to update attributes because it goes straight to
  # the database, but take into account that in consequence the regular update
  # procedures are totally bypassed. In particular:
  #
  # * \Validations are skipped.
  # * \Callbacks are skipped.
  # * +updated_at+/+updated_on+ are not updated.
  # * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all
  #
  # This method raises an ActiveRecord::ActiveRecordError when called on new
  # objects, or when at least one of the attributes is marked as readonly.
  #
  # @raise [ActiveRecordError]
  def update_columns(attributes); end

  private

  # Creates a record with values matching those of the instance attributes
  # and returns its id.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  def _create_record(attribute_names = T.unsafe(nil)); end

  def _raise_record_not_destroyed; end

  # Updates the associated record with values matching those of the instance attributes.
  # Returns the number of affected rows.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  def _update_record(attribute_names = T.unsafe(nil)); end

  def belongs_to_touch_method; end

  # @raise [ReadOnlyRecord]
  def create_or_update(*args, &block); end

  # A hook to be overridden by association modules.
  def destroy_associations; end

  def destroy_row; end
  def relation_for_destroy; end

  # @raise [ActiveRecordError]
  def verify_readonly_attribute(name); end
end

module ActiveRecord::Persistence::ClassMethods
  # Creates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the
  # attributes on the objects that are to be created.
  #
  # ==== Examples
  #   # Create a single new object
  #   User.create(first_name: 'Jamie')
  #
  #   # Create an Array of new objects
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])
  #
  #   # Create a single object and pass it into a block to set other attributes.
  #   User.create(first_name: 'Jamie') do |u|
  #     u.is_admin = false
  #   end
  #
  #   # Creating an Array of new objects using a block, where the block is executed for each object:
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
  #     u.is_admin = false
  #   end
  def create(attributes = T.unsafe(nil), &block); end

  # Creates an object (or multiple objects) and saves it to the database,
  # if validations pass. Raises a RecordInvalid error if validations fail,
  # unlike Base#create.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes.
  # These describe which attributes to be created on the object, or
  # multiple objects when given an Array of Hashes.
  def create!(attributes = T.unsafe(nil), &block); end

  # Given an attributes hash, +instantiate+ returns a new instance of
  # the appropriate class. Accepts only keys as strings.
  #
  # For example, +Post.all+ may return Comments, Messages, and Emails
  # by storing the record's subclass in a +type+ attribute. By calling
  # +instantiate+ instead of +new+, finder methods ensure they get new
  # instances of the appropriate class for each record.
  #
  # See <tt>ActiveRecord::Inheritance#discriminate_class_for_record</tt> to see
  # how this "single-table" inheritance mapping is implemented.
  def instantiate(attributes, column_types = T.unsafe(nil), &block); end

  private

  # Called by +instantiate+ to decide which class to use for a new
  # record instance.
  #
  # See +ActiveRecord::Inheritance#discriminate_class_for_record+ for
  # the single-table inheritance discriminator.
  def discriminate_class_for_record(record); end
end

class ActiveRecord::PredicateBuilder
  # @return [PredicateBuilder] a new instance of PredicateBuilder
  def initialize(table); end

  def build(attribute, value); end
  def build_from_hash(attributes); end
  def create_binds(attributes); end
  def expand(column, value); end

  # Define how a class is converted to Arel nodes when passed to +where+.
  # The handler can be any object that responds to +call+, and will be used
  # for any value that +===+ the class given. For example:
  #
  #     MyCustomDateRange = Struct.new(:start, :end)
  #     handler = proc do |column, range|
  #       Arel::Nodes::Between.new(column,
  #         Arel::Nodes::And.new([range.start, range.end])
  #       )
  #     end
  #     ActiveRecord::PredicateBuilder.new("users").register_handler(MyCustomDateRange, handler)
  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end

  protected

  def create_binds_for_hash(attributes); end
  def expand_from_hash(attributes); end

  # Returns the value of attribute table.
  def table; end

  private

  def associated_predicate_builder(association_name); end
  def build_bind_param(column_name, value); end

  # @return [Boolean]
  def can_be_bound?(column_name, value); end

  def convert_dot_notation_to_hash(attributes); end
  def handler_for(object); end

  class << self
    def references(attributes); end
  end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  # @return [ArrayHandler] a new instance of ArrayHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  class << self
    def or(other); end
  end
end

class ActiveRecord::PredicateBuilder::AssociationQueryHandler
  # @return [AssociationQueryHandler] a new instance of AssociationQueryHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end

  class << self
    def value_for(table, column, value); end
  end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  # @return [AssociationQueryValue] a new instance of AssociationQueryValue
  def initialize(associated_table, value); end

  # Returns the value of attribute associated_table.
  def associated_table; end

  def base_class; end
  def ids; end

  # Returns the value of attribute value.
  def value; end

  private

  def convert_to_id(value); end
  def polymorphic_base_class_from_value; end
  def primary_key; end
end

class ActiveRecord::PredicateBuilder::BaseHandler
  # @return [BaseHandler] a new instance of BaseHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  # @return [BasicObjectHandler] a new instance of BasicObjectHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::ClassHandler
  # @return [ClassHandler] a new instance of ClassHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end

  private

  def print_deprecation_warning; end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayHandler
  # @return [PolymorphicArrayHandler] a new instance of PolymorphicArrayHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  # @return [PolymorphicArrayValue] a new instance of PolymorphicArrayValue
  def initialize(associated_table, values); end

  # Returns the value of attribute associated_table.
  def associated_table; end

  def type_to_ids_mapping; end

  # Returns the value of attribute values.
  def values; end

  private

  def base_class(value); end
  def convert_to_id(value); end
  def primary_key(value); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
  # @return [RangeHandler] a new instance of RangeHandler
  def initialize(predicate_builder); end

  def call(attribute, value); end

  protected

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds < ::Struct
  # Returns the value of attribute begin
  #
  # @return [Object] the current value of begin
  def begin; end

  # Sets the attribute begin
  #
  # @param value [Object] the value to set the attribute begin to.
  # @return [Object] the newly set value
  def begin=(_); end

  # Returns the value of attribute end
  #
  # @return [Object] the current value of end
  def end; end

  # Sets the attribute end
  #
  # @param value [Object] the value to set the attribute end to.
  # @return [Object] the newly set value
  def end=(_); end

  # Returns the value of attribute exclude_end?
  #
  # @return [Object] the current value of exclude_end?
  def exclude_end?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

# Raised when Postgres returns 'cached plan must not change result type' and
# we cannot retry gracefully (e.g. inside a transaction)
class ActiveRecord::PreparedStatementCacheExpired < ::ActiveRecord::StatementInvalid; end

# Raised when number of bind variables in statement given to +:condition+ key
# (for example, when using {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] method)
# does not match number of expected values supplied.
#
# For example, when there are two placeholders with only one value supplied:
#
#   Location.where("lat = ? AND lng = ?", 53.7362)
class ActiveRecord::PreparedStatementInvalid < ::ActiveRecord::ActiveRecordError; end

class ActiveRecord::ProtectedEnvironmentError < ::ActiveRecord::ActiveRecordError
  # @return [ProtectedEnvironmentError] a new instance of ProtectedEnvironmentError
  def initialize(env = T.unsafe(nil)); end
end

# = Active Record Query Cache
class ActiveRecord::QueryCache
  class << self
    def complete(_arg0); end
    def install_executor_hooks(executor = T.unsafe(nil)); end
    def run; end
  end
end

module ActiveRecord::QueryCache::ClassMethods
  # Enable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  def cache(&block); end

  # Disable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  def uncached(&block); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  extend ::ActiveSupport::Concern

  def _select!(*fields); end

  # Returns the Arel object associated with the relation.
  def arel; end

  def bound_attributes; end

  # Sets attributes to be used when creating new records from a
  # relation object.
  #
  #   users = User.where(name: 'Oscar')
  #   users.new.name # => 'Oscar'
  #
  #   users = users.create_with(name: 'DHH')
  #   users.new.name # => 'DHH'
  #
  # You can pass +nil+ to #create_with to reset attributes:
  #
  #   users = users.create_with(nil)
  #   users.new.name # => 'Oscar'
  def create_with(value); end

  def create_with!(value); end
  def create_with_value; end
  def create_with_value=(value); end

  # Specifies whether the records should be unique or not. For example:
  #
  #   User.select(:name)
  #   # Might return two records with the same name
  #
  #   User.select(:name).distinct
  #   # Returns 1 record per distinct name
  #
  #   User.select(:name).distinct.distinct(false)
  #   # You can also remove the uniqueness
  def distinct(value = T.unsafe(nil)); end

  # Like #distinct, but modifies relation in place.
  def distinct!(value = T.unsafe(nil)); end

  def distinct_value; end
  def distinct_value=(value); end

  # Forces eager loading by performing a LEFT OUTER JOIN on +args+:
  #
  #   User.eager_load(:posts)
  #   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
  #   # FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
  #   # "users"."id"
  def eager_load(*args); end

  def eager_load!(*args); end
  def eager_load_values; end
  def eager_load_values=(values); end

  # Used to extend a scope with additional methods, either through
  # a module or through a block provided.
  #
  # The object returned is a relation, which can be further extended.
  #
  # === Using a module
  #
  #   module Pagination
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #
  #   scope = Model.all.extending(Pagination)
  #   scope.page(params[:page])
  #
  # You can also pass a list of modules:
  #
  #   scope = Model.all.extending(Pagination, SomethingElse)
  #
  # === Using a block
  #
  #   scope = Model.all.extending do
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #   scope.page(params[:page])
  #
  # You can also use a block and a module list:
  #
  #   scope = Model.all.extending(Pagination) do
  #     def per_page(number)
  #       # pagination code goes here
  #     end
  #   end
  def extending(*modules, &block); end

  def extending!(*modules, &block); end
  def extending_values; end
  def extending_values=(values); end
  def extensions; end

  # Specifies table from which the records will be fetched. For example:
  #
  #   Topic.select('title').from('posts')
  #   # SELECT title FROM posts
  #
  # Can accept other relation objects. For example:
  #
  #   Topic.select('title').from(Topic.approved)
  #   # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
  #
  #   Topic.select('a.title').from(Topic.approved, :a)
  #   # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
  def from(value, subquery_name = T.unsafe(nil)); end

  def from!(value, subquery_name = T.unsafe(nil)); end
  def from_clause; end
  def from_clause=(value); end

  # Allows to specify a group attribute:
  #
  #   User.group(:name)
  #   # SELECT "users".* FROM "users" GROUP BY name
  #
  # Returns an array with distinct records based on the +group+ attribute:
  #
  #   User.select([:id, :name])
  #   # => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
  #
  #   User.group(:name)
  #   # => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
  #
  #   User.group('name AS grouped_name, age')
  #   # => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
  #
  # Passing in an array of attributes to group by is also supported.
  #
  #   User.select([:id, :first_name]).group(:id, :first_name).first(3)
  #   # => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
  def group(*args); end

  def group!(*args); end
  def group_values; end
  def group_values=(values); end

  # Allows to specify a HAVING clause. Note that you can't use HAVING
  # without also specifying a GROUP clause.
  #
  #   Order.having('SUM(price) > 30').group('user_id')
  def having(opts, *rest); end

  def having!(opts, *rest); end
  def having_clause; end
  def having_clause=(value); end

  # Specify relationships to be included in the result set. For
  # example:
  #
  #   users = User.includes(:address)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  # allows you to access the +address+ attribute of the +User+ model without
  # firing an additional query. This will often result in a
  # performance improvement over a simple join.
  #
  # You can also specify multiple relationships, like this:
  #
  #   users = User.includes(:address, :friends)
  #
  # Loading nested relationships is possible using a Hash:
  #
  #   users = User.includes(:address, friends: [:address, :followers])
  #
  # === conditions
  #
  # If you want to add conditions to your included models you'll have
  # to explicitly reference them. For example:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example')
  #
  # Will throw an error, but this will work:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
  #
  # Note that #includes works with association names while #references needs
  # the actual table name.
  def includes(*args); end

  def includes!(*args); end
  def includes_values; end
  def includes_values=(values); end

  # Performs a joins on +args+. The given symbol(s) should match the name of
  # the association(s).
  #
  #   User.joins(:posts)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # Multiple joins:
  #
  #   User.joins(:posts, :account)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
  #
  # Nested joins:
  #
  #   User.joins(posts: [:comments])
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "comments" "comments_posts"
  #   #   ON "comments_posts"."post_id" = "posts"."id"
  #
  # You can use strings in order to customize your joins:
  #
  #   User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
  #   # SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
  def joins(*args); end

  def joins!(*args); end
  def joins_values; end
  def joins_values=(values); end

  # Performs a left outer joins on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   => SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  def left_joins(*args); end

  def left_joins!(*args); end
  def left_joins_values; end
  def left_joins_values=(values); end

  # Performs a left outer joins on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   => SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end
  def left_outer_joins_values; end
  def left_outer_joins_values=(values); end

  # Specifies a limit for the number of records to retrieve.
  #
  #   User.limit(10) # generated SQL has 'LIMIT 10'
  #
  #   User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
  def limit(value); end

  def limit!(value); end
  def limit_value; end
  def limit_value=(value); end

  # Specifies locking settings (default to +true+). For more information
  # on locking, please see ActiveRecord::Locking.
  def lock(locks = T.unsafe(nil)); end

  def lock!(locks = T.unsafe(nil)); end
  def lock_value; end
  def lock_value=(value); end

  # Returns a chainable relation with zero records.
  #
  # The returned relation implements the Null Object pattern. It is an
  # object with defined null behavior and always returns an empty array of
  # records without querying the database.
  #
  # Any subsequent condition chained to the returned relation will continue
  # generating an empty relation and will not fire any query to the database.
  #
  # Used in cases where a method or scope could return zero records but the
  # result needs to be chainable.
  #
  # For example:
  #
  #   @posts = current_user.visible_posts.where(name: params[:name])
  #   # the visible_posts method is expected to return a chainable Relation
  #
  #   def visible_posts
  #     case role
  #     when 'Country Manager'
  #       Post.where(country: country)
  #     when 'Reviewer'
  #       Post.published
  #     when 'Bad User'
  #       Post.none # It can't be chained if [] is returned.
  #     end
  #   end
  def none; end

  def none!; end

  # Specifies the number of rows to skip before returning rows.
  #
  #   User.offset(10) # generated SQL has "OFFSET 10"
  #
  # Should be used with order.
  #
  #   User.offset(10).order("name ASC")
  def offset(value); end

  def offset!(value); end
  def offset_value; end
  def offset_value=(value); end

  # Returns a new relation, which is the logical union of this relation and the one passed as an
  # argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present). Neither relation may have a #limit, #offset, or #distinct set.
  #
  #    Post.where("id = 1").or(Post.where("author_id = 3"))
  #    # SELECT `posts`.* FROM `posts`  WHERE (('id = 1' OR 'author_id = 3'))
  def or(other); end

  def or!(other); end

  # Allows to specify an order attribute:
  #
  #   User.order(:name)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
  #
  #   User.order(email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
  #
  #   User.order(:name, email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
  #
  #   User.order('name')
  #   # SELECT "users".* FROM "users" ORDER BY name
  #
  #   User.order('name DESC')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC
  #
  #   User.order('name DESC, email')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC, email
  def order(*args); end

  def order!(*args); end
  def order_values; end
  def order_values=(values); end

  # Allows preloading of +args+, in the same way that #includes does:
  #
  #   User.preload(:posts)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
  def preload(*args); end

  def preload!(*args); end
  def preload_values; end
  def preload_values=(values); end

  # Sets readonly attributes for the returned relation. If value is
  # true (default), attempting to update a record will result in an error.
  #
  #   users = User.readonly
  #   users.first.save
  #   => ActiveRecord::ReadOnlyRecord: User is marked as readonly
  def readonly(value = T.unsafe(nil)); end

  def readonly!(value = T.unsafe(nil)); end
  def readonly_value; end
  def readonly_value=(value); end

  # Use to indicate that the given +table_names+ are referenced by an SQL string,
  # and should therefore be JOINed in any query rather than loaded separately.
  # This method only works in conjunction with #includes.
  # See #includes for more details.
  #
  #   User.includes(:posts).where("posts.name = 'foo'")
  #   # Doesn't JOIN the posts table, resulting in an error.
  #
  #   User.includes(:posts).where("posts.name = 'foo'").references(:posts)
  #   # Query now knows the string references posts, so adds a JOIN
  def references(*table_names); end

  def references!(*table_names); end
  def references_values; end
  def references_values=(values); end

  # Replaces any existing order defined on the relation with the specified order.
  #
  #   User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
  #
  # Subsequent calls to order on the same relation will be appended. For example:
  #
  #   User.order('email DESC').reorder('id ASC').order('name ASC')
  #
  # generates a query with 'ORDER BY id ASC, name ASC'.
  def reorder(*args); end

  def reorder!(*args); end
  def reordering_value; end
  def reordering_value=(value); end

  # Reverse the existing order clause on the relation.
  #
  #   User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
  def reverse_order; end

  def reverse_order!; end
  def reverse_order_value; end
  def reverse_order_value=(value); end

  # Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.
  #
  #   Post.where(trashed: true).where(trashed: false)
  #   # WHERE `trashed` = 1 AND `trashed` = 0
  #
  #   Post.where(trashed: true).rewhere(trashed: false)
  #   # WHERE `trashed` = 0
  #
  #   Post.where(active: true).where(trashed: true).rewhere(trashed: false)
  #   # WHERE `active` = 1 AND `trashed` = 0
  #
  # This is short-hand for <tt>unscope(where: conditions.keys).where(conditions)</tt>.
  # Note that unlike reorder, we're only unscoping the named conditions -- not the entire where statement.
  def rewhere(conditions); end

  # Works in two unique ways.
  #
  # First: takes a block so it can be used just like +Array#select+.
  #
  #   Model.all.select { |m| m.field == value }
  #
  # This will build an array of objects from the database for the scope,
  # converting them into an array and iterating through them using +Array#select+.
  #
  # Second: Modifies the SELECT statement for the query so that only certain
  # fields are retrieved:
  #
  #   Model.select(:field)
  #   # => [#<Model id: nil, field: "value">]
  #
  # Although in the above example it looks as though this method returns an
  # array, it actually returns a relation object and can have other query
  # methods appended to it, such as the other methods in ActiveRecord::QueryMethods.
  #
  # The argument to the method can also be an array of fields.
  #
  #   Model.select(:field, :other_field, :and_one_more)
  #   # => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
  #
  # You can also use one or more strings, which will be used unchanged as SELECT fields.
  #
  #   Model.select('field AS field_one', 'other_field AS field_two')
  #   # => [#<Model id: nil, field: "value", other_field: "value">]
  #
  # If an alias was specified, it will be accessible from the resulting objects:
  #
  #   Model.select('field AS field_one').first.field_one
  #   # => "value"
  #
  # Accessing attributes of an object that do not have fields retrieved by a select
  # except +id+ will throw ActiveModel::MissingAttributeError:
  #
  #   Model.select(:field).first.other_field
  #   # => ActiveModel::MissingAttributeError: missing attribute: other_field
  #
  # @raise [ArgumentError]
  def select(*fields); end

  def select_values; end
  def select_values=(values); end

  # Specifies whether the records should be unique or not. For example:
  #
  #   User.select(:name)
  #   # Might return two records with the same name
  #
  #   User.select(:name).distinct
  #   # Returns 1 record per distinct name
  #
  #   User.select(:name).distinct.distinct(false)
  #   # You can also remove the uniqueness
  def uniq(*args, &block); end

  # Like #distinct, but modifies relation in place.
  def uniq!(*args, &block); end

  # Removes an unwanted relation that is already defined on a chain of relations.
  # This is useful when passing around chains of relations and would like to
  # modify the relations without reconstructing the entire chain.
  #
  #   User.order('email DESC').unscope(:order) == User.all
  #
  # The method arguments are symbols which correspond to the names of the methods
  # which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES.
  # The method can also be called with multiple arguments. For example:
  #
  #   User.order('email DESC').select('id').where(name: "John")
  #       .unscope(:order, :select, :where) == User.all
  #
  # One can additionally pass a hash as an argument to unscope specific +:where+ values.
  # This is done by passing a hash with a single key-value pair. The key should be
  # +:where+ and the value should be the where value to unscope. For example:
  #
  #   User.where(name: "John", active: true).unscope(where: :name)
  #       == User.where(active: true)
  #
  # This method is similar to #except, but unlike
  # #except, it persists across merges:
  #
  #   User.order('email').merge(User.except(:order))
  #       == User.order('email')
  #
  #   User.order('email').merge(User.unscope(:order))
  #       == User.all
  #
  # This means it can be used in association definitions:
  #
  #   has_many :comments, -> { unscope(where: :trashed) }
  def unscope(*args); end

  def unscope!(*args); end
  def unscope_values; end
  def unscope_values=(values); end

  # Returns a new relation, which is the result of filtering the current relation
  # according to the conditions in the arguments.
  #
  # #where accepts conditions in one of several formats. In the examples below, the resulting
  # SQL is given as an illustration; the actual query generated may be different depending
  # on the database adapter.
  #
  # === string
  #
  # A single string, without additional arguments, is passed to the query
  # constructor as an SQL fragment, and used in the where clause of the query.
  #
  #    Client.where("orders_count = '2'")
  #    # SELECT * from clients where orders_count = '2';
  #
  # Note that building your own string from user input may expose your application
  # to injection attacks if not done properly. As an alternative, it is recommended
  # to use one of the following methods.
  #
  # === array
  #
  # If an array is passed, then the first element of the array is treated as a template, and
  # the remaining elements are inserted into the template to generate the condition.
  # Active Record takes care of building the query to avoid injection attacks, and will
  # convert from the ruby type to the database type where needed. Elements are inserted
  # into the string in the order in which they appear.
  #
  #   User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # Alternatively, you can use named placeholders in the template, and pass a hash as the
  # second element of the array. The names in the template are replaced with the corresponding
  # values from the hash.
  #
  #   User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # This can make for more readable code in complex queries.
  #
  # Lastly, you can use sprintf-style % escapes in the template. This works slightly differently
  # than the previous methods; you are responsible for ensuring that the values in the template
  # are properly quoted. The values are passed to the connector for quoting, but the caller
  # is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting,
  # the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.
  #
  #   User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # If #where is called with multiple arguments, these are treated as if they were passed as
  # the elements of a single array.
  #
  #   User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # When using strings to specify conditions, you can use any operator available from
  # the database. While this provides the most flexibility, you can also unintentionally introduce
  # dependencies on the underlying database. If your code is intended for general consumption,
  # test with multiple database backends.
  #
  # === hash
  #
  # #where will also accept a hash condition, in which the keys are fields and the values
  # are values to be searched for.
  #
  # Fields can be symbols or strings. Values can be single values, arrays, or ranges.
  #
  #    User.where({ name: "Joe", email: "joe@example.com" })
  #    # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'
  #
  #    User.where({ name: ["Alice", "Bob"]})
  #    # SELECT * FROM users WHERE name IN ('Alice', 'Bob')
  #
  #    User.where({ created_at: (Time.now.midnight - 1.day)..Time.now.midnight })
  #    # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
  #
  # In the case of a belongs_to relationship, an association key can be used
  # to specify the model if an ActiveRecord object is used as the value.
  #
  #    author = Author.find(1)
  #
  #    # The following queries will be equivalent:
  #    Post.where(author: author)
  #    Post.where(author_id: author)
  #
  # This also works with polymorphic belongs_to relationships:
  #
  #    treasure = Treasure.create(name: 'gold coins')
  #    treasure.price_estimates << PriceEstimate.create(price: 125)
  #
  #    # The following queries will be equivalent:
  #    PriceEstimate.where(estimate_of: treasure)
  #    PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
  #
  # === Joins
  #
  # If the relation is the result of a join, you may create a condition which uses any of the
  # tables in the join. For string and array conditions, use the table name in the condition.
  #
  #    User.joins(:posts).where("posts.created_at < ?", Time.now)
  #
  # For hash conditions, you can either use the table name in the key, or use a sub-hash.
  #
  #    User.joins(:posts).where({ "posts.published" => true })
  #    User.joins(:posts).where({ posts: { published: true } })
  #
  # === no argument
  #
  # If no argument is passed, #where returns a new instance of WhereChain, that
  # can be chained with #not to return a new relation that negates the where clause.
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  # See WhereChain for more details on #not.
  #
  # === blank condition
  #
  # If the condition is any blank-ish object, then #where is a no-op and returns
  # the current relation.
  def where(opts = T.unsafe(nil), *rest); end

  def where!(opts, *rest); end
  def where_clause; end
  def where_clause=(value); end

  private

  def arel_columns(columns); end

  # @raise [ImmutableRelation]
  def assert_mutability!; end

  def association_for_table(table_name); end
  def build_arel; end
  def build_from; end
  def build_join_query(manager, buckets, join_type); end
  def build_joins(manager, joins); end
  def build_left_outer_joins(manager, outer_joins); end
  def build_order(arel); end
  def build_select(arel); end

  # Checks to make sure that the arguments are not blank. Note that if some
  # blank-like object were initially passed into the query method, then this
  # method will not raise an error.
  #
  # Example:
  #
  #    Post.references()   # raises an error
  #    Post.references([]) # does not raise an error
  #
  # This particular method should be called with a method_name and the args
  # passed into that method as an input. For example:
  #
  # def references(*args)
  #   check_if_method_has_arguments!("references", args)
  #   ...
  # end
  def check_if_method_has_arguments!(method_name, args); end

  def convert_join_strings_to_ast(table, joins); end

  # @return [Boolean]
  def does_not_support_reverse?(order); end

  def having_clause_factory; end
  def new_from_clause; end
  def new_having_clause; end
  def new_where_clause; end
  def preprocess_order_args(order_args); end
  def reverse_sql_order(order_query); end

  # @return [Boolean]
  def string_containing_comma?(value); end

  def structurally_incompatible_values_for_or(other); end
  def symbol_unscoping(scope); end
  def validate_order_args(args); end
  def where_clause_factory; end
end

ActiveRecord::QueryMethods::FROZEN_EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::FROZEN_EMPTY_HASH = T.let(T.unsafe(nil), Hash)
ActiveRecord::QueryMethods::VALID_DIRECTIONS = T.let(T.unsafe(nil), Array)
ActiveRecord::QueryMethods::VALID_UNSCOPING_VALUES = T.let(T.unsafe(nil), Set)

# WhereChain objects act as placeholder for queries in which #where does not have any parameter.
# In this case, #where must be chained with #not to return a new relation.
class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection

  # @return [WhereChain] a new instance of WhereChain
  def initialize(scope); end

  # Returns a new relation expressing WHERE + NOT condition according to
  # the conditions in the arguments.
  #
  # #not accepts conditions as a string, array, or hash. See QueryMethods#where for
  # more details on each format.
  #
  #    User.where.not("name = 'Jon'")
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(["name = ?", "Jon"])
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  #    User.where.not(name: nil)
  #    # SELECT * FROM users WHERE name IS NOT NULL
  #
  #    User.where.not(name: %w(Ko1 Nobu))
  #    # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')
  #
  #    User.where.not(name: "Jon", role: "admin")
  #    # SELECT * FROM users WHERE name != 'Jon' AND role != 'admin'
  def not(opts, *rest); end
end

module ActiveRecord::Querying
  def any?(*args, &block); end
  def average(*args, &block); end
  def calculate(*args, &block); end
  def count(*args, &block); end

  # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
  # The use of this method should be restricted to complicated SQL queries that can't be executed
  # using the ActiveRecord::Calculations class methods. Look into those before using this.
  #
  #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"
  #   # => 12
  #
  # ==== Parameters
  #
  # * +sql+ - An SQL statement which should return a count query from the database, see the example above.
  def count_by_sql(sql); end

  def create_with(*args, &block); end
  def delete(*args, &block); end
  def delete_all(*args, &block); end
  def destroy(*args, &block); end
  def destroy_all(*args, &block); end
  def distinct(*args, &block); end
  def eager_load(*args, &block); end
  def except(*args, &block); end
  def exists?(*args, &block); end
  def fifth(*args, &block); end
  def fifth!(*args, &block); end
  def find(*args, &block); end
  def find_by(*args, &block); end
  def find_by!(*args, &block); end

  # Executes a custom SQL query against your database and returns all the results. The results will
  # be returned as an array with columns requested encapsulated as attributes of the model you call
  # this method from. If you call <tt>Product.find_by_sql</tt> then the results will be returned in
  # a +Product+ object with the attributes you specified in the SQL query.
  #
  # If you call a complicated SQL query which spans multiple tables the columns specified by the
  # SELECT will be attributes of the model, whether or not they are columns of the corresponding
  # table.
  #
  # The +sql+ parameter is a full SQL query as a string. It will be called as is, there will be
  # no database agnostic conversions performed. This should be a last resort because using, for example,
  # MySQL specific terms will lock you to using that particular database engine or require you to
  # change your call if you switch engines.
  #
  #   # A simple SQL query spanning multiple tables
  #   Post.find_by_sql "SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id"
  #   # => [#<Post:0x36bff9c @attributes={"title"=>"Ruby Meetup", "first_name"=>"Quentin"}>, ...]
  #
  # You can use the same string replacement techniques as you can with <tt>ActiveRecord::QueryMethods#where</tt>:
  #
  #   Post.find_by_sql ["SELECT title FROM posts WHERE author = ? AND created > ?", author_id, start_date]
  #   Post.find_by_sql ["SELECT body FROM comments WHERE author = :user_id OR approved_by = :user_id", { :user_id => user_id }]
  def find_by_sql(sql, binds = T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end
  def find_in_batches(*args, &block); end
  def find_or_create_by(*args, &block); end
  def find_or_create_by!(*args, &block); end
  def find_or_initialize_by(*args, &block); end
  def first(*args, &block); end
  def first!(*args, &block); end
  def first_or_create(*args, &block); end
  def first_or_create!(*args, &block); end
  def first_or_initialize(*args, &block); end
  def forty_two(*args, &block); end
  def forty_two!(*args, &block); end
  def fourth(*args, &block); end
  def fourth!(*args, &block); end
  def from(*args, &block); end
  def group(*args, &block); end
  def having(*args, &block); end
  def ids(*args, &block); end
  def in_batches(*args, &block); end
  def includes(*args, &block); end
  def joins(*args, &block); end
  def last(*args, &block); end
  def last!(*args, &block); end
  def left_joins(*args, &block); end
  def left_outer_joins(*args, &block); end
  def limit(*args, &block); end
  def lock(*args, &block); end
  def many?(*args, &block); end
  def maximum(*args, &block); end
  def minimum(*args, &block); end
  def none(*args, &block); end
  def none?(*args, &block); end
  def offset(*args, &block); end
  def one?(*args, &block); end
  def or(*args, &block); end
  def order(*args, &block); end
  def pluck(*args, &block); end
  def preload(*args, &block); end
  def readonly(*args, &block); end
  def references(*args, &block); end
  def reorder(*args, &block); end
  def rewhere(*args, &block); end
  def second(*args, &block); end
  def second!(*args, &block); end
  def second_to_last(*args, &block); end
  def second_to_last!(*args, &block); end
  def select(*args, &block); end
  def sum(*args, &block); end
  def take(*args, &block); end
  def take!(*args, &block); end
  def third(*args, &block); end
  def third!(*args, &block); end
  def third_to_last(*args, &block); end
  def third_to_last!(*args, &block); end
  def uniq(*args, &block); end
  def unscope(*args, &block); end
  def update(*args, &block); end
  def update_all(*args, &block); end
  def where(*args, &block); end
end

# = Active Record Railtie
class ActiveRecord::Railtie < ::Rails::Railtie; end

class ActiveRecord::ReadOnlyAssociation < ::ActiveRecord::ActiveRecordError
  # @return [ReadOnlyAssociation] a new instance of ReadOnlyAssociation
  def initialize(reflection = T.unsafe(nil)); end
end

# Raised on attempt to update record that is instantiated as read only.
class ActiveRecord::ReadOnlyRecord < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::ReadonlyAttributes::ClassMethods

  module GeneratedClassMethods
    def _attr_readonly; end
    def _attr_readonly=(value); end
    def _attr_readonly?; end
  end

  module GeneratedInstanceMethods; end
end

module ActiveRecord::ReadonlyAttributes::ClassMethods
  # Attributes listed as readonly will be used to create a new record but update operations will
  # ignore these fields.
  def attr_readonly(*attributes); end

  # Returns an array of all the attributes that have been specified as readonly.
  def readonly_attributes; end
end

# = Active Record \RecordInvalid
#
# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base#create!}[rdoc-ref:Persistence::ClassMethods#create!] when the record is invalid.
# Use the #record method to retrieve the record which did not validate.
#
#   begin
#     complex_operation_that_internally_calls_save!
#   rescue ActiveRecord::RecordInvalid => invalid
#     puts invalid.record.errors
#   end
class ActiveRecord::RecordInvalid < ::ActiveRecord::ActiveRecordError
  # @return [RecordInvalid] a new instance of RecordInvalid
  def initialize(record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised by {ActiveRecord::Base#destroy!}[rdoc-ref:Persistence#destroy!]
# when a call to {#destroy}[rdoc-ref:Persistence#destroy!]
# would return false.
#
#   begin
#     complex_operation_that_internally_calls_destroy!
#   rescue ActiveRecord::RecordNotDestroyed => invalid
#     puts invalid.record.errors
#   end
class ActiveRecord::RecordNotDestroyed < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotDestroyed] a new instance of RecordNotDestroyed
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised when Active Record cannot find a record by given id or set of ids.
class ActiveRecord::RecordNotFound < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotFound] a new instance of RecordNotFound
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil), primary_key = T.unsafe(nil), id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  def id; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute primary_key.
  def primary_key; end
end

# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
# methods when a record is invalid and can not be saved.
class ActiveRecord::RecordNotSaved < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotSaved] a new instance of RecordNotSaved
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  def record; end
end

# Raised when a record cannot be inserted because it would violate a uniqueness constraint.
class ActiveRecord::RecordNotUnique < ::ActiveRecord::WrappedDatabaseException; end

# = Active Record Reflection
module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Reflection::ClassMethods

  class << self
    def add_aggregate_reflection(ar, name, reflection); end
    def add_reflection(ar, name, reflection); end
    def create(macro, name, scope, options, ar); end
  end

  module GeneratedClassMethods
    def _reflections; end
    def _reflections=(value); end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections=(value); end
    def aggregate_reflections?; end
  end

  module GeneratedInstanceMethods
    def _reflections; end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections?; end
  end
end

# Holds all the methods that are shared between MacroReflection and ThroughReflection.
#
#   AbstractReflection
#     MacroReflection
#       AggregateReflection
#       AssociationReflection
#         HasManyReflection
#         HasOneReflection
#         BelongsToReflection
#         HasAndBelongsToManyReflection
#     ThroughReflection
#       PolymorphicReflection
#         RuntimeReflection
class ActiveRecord::Reflection::AbstractReflection
  def alias_candidate(name); end

  # Returns a new, unsaved instance of the associated class. +attributes+ will
  # be passed to the class's constructor.
  def build_association(attributes, &block); end

  def chain; end
  def check_validity_of_inverse!; end

  # Returns the class name for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>'Money'</tt>
  # <tt>has_many :clients</tt> returns <tt>'Client'</tt>
  def class_name; end

  def constraints; end
  def counter_cache_column; end

  # @return [Boolean]
  def counter_must_be_updated_by_has_many?; end

  # Returns whether a counter cache should be used for this association.
  #
  # The counter_cache option must be given on either the owner or inverse
  # association, and the column must be present on the owner.
  #
  # @return [Boolean]
  def has_cached_counter?; end

  def inverse_of; end

  # This shit is nasty. We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  def inverse_updates_counter_cache?; end

  # @return [Boolean]
  def inverse_updates_counter_in_memory?; end

  # This shit is nasty. We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  def inverse_which_updates_counter_cache; end

  def join_keys(association_klass); end
  def primary_key_type; end
  def quoted_table_name; end
  def table_name; end

  # @return [Boolean]
  def through_reflection?; end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys < ::Struct
  # Returns the value of attribute foreign_key
  #
  # @return [Object] the current value of foreign_key
  def foreign_key; end

  # Sets the attribute foreign_key
  #
  # @param value [Object] the value to set the attribute foreign_key to.
  # @return [Object] the newly set value
  def foreign_key=(_); end

  # Returns the value of attribute key
  #
  # @return [Object] the current value of key
  def key; end

  # Sets the attribute key
  #
  # @param value [Object] the value to set the attribute key to.
  # @return [Object] the newly set value
  def key=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Holds all the meta-data about an aggregation as it was specified in the
# Active Record class.
class ActiveRecord::Reflection::AggregateReflection < ::ActiveRecord::Reflection::MacroReflection
  def mapping; end
end

# Holds all the meta-data about an association as it was specified in the
# Active Record class.
class ActiveRecord::Reflection::AssociationReflection < ::ActiveRecord::Reflection::MacroReflection
  # @return [AssociationReflection] a new instance of AssociationReflection
  def initialize(name, scope, options, active_record); end

  def active_record_primary_key; end
  def add_as_polymorphic_through(reflection, seed); end
  def add_as_source(seed); end
  def add_as_through(seed); end

  # @raise [NotImplementedError]
  def association_class; end

  def association_foreign_key; end

  # klass option is necessary to support loading polymorphic associations
  def association_primary_key(klass = T.unsafe(nil)); end

  def association_primary_key_type; end
  def association_scope_cache(conn, owner); end

  # Returns +true+ if +self+ is a +belongs_to+ reflection.
  #
  # @return [Boolean]
  def belongs_to?; end

  def check_eager_loadable!; end
  def check_preloadable!; end
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  def clear_association_scope_cache; end

  # A chain of reflections from this one back to the owner. For more see the explanation in
  # ThroughReflection.
  def collect_join_chain; end

  # Returns whether or not this association reflection is for a collection
  # association. Returns +true+ if the +macro+ is either +has_many+ or
  # +has_and_belongs_to_many+, +false+ otherwise.
  #
  # @return [Boolean]
  def collection?; end

  def compute_class(name); end

  # @return [Boolean]
  def constructable?; end

  def extensions; end
  def foreign_key; end

  # Returns the value of attribute foreign_type.
  def foreign_type; end

  # @return [Boolean]
  def has_inverse?; end

  # Returns +true+ if +self+ is a +has_one+ reflection.
  #
  # @return [Boolean]
  def has_one?; end

  # @return [Boolean]
  def has_scope?; end

  def join_id_for(owner); end
  def join_table; end

  # Returns the target association's class.
  #
  #   class Author < ActiveRecord::Base
  #     has_many :books
  #   end
  #
  #   Author.reflect_on_association(:books).klass
  #   # => Book
  #
  # <b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate
  # a new association object. Use +build_association+ or +create_association+
  # instead. This allows plugins to hook into association object creation.
  def klass; end

  # Returns the macro type.
  #
  # <tt>has_many :clients</tt> returns <tt>:has_many</tt>
  #
  # @raise [NotImplementedError]
  def macro; end

  # @return [Boolean]
  def nested?; end

  # Reflection
  def parent_reflection; end

  # Reflection
  def parent_reflection=(_arg0); end

  # @return [Boolean]
  def polymorphic?; end

  def polymorphic_inverse_of(associated_class); end

  # An array of arrays of scopes. Each item in the outside array corresponds to a reflection
  # in the #chain.
  def scope_chain; end

  def source_reflection; end
  def through_reflection; end

  # Returns the value of attribute type.
  def type; end

  # Returns whether or not the association should be validated as part of
  # the parent's validation.
  #
  # Unless you explicitly disable validation with
  # <tt>validate: false</tt>, validation will take place when:
  #
  # * you explicitly enable validation; <tt>validate: true</tt>
  # * you use autosave; <tt>autosave: true</tt>
  # * the association is a +has_many+ association
  #
  # @return [Boolean]
  def validate?; end

  protected

  # FIXME: this is a horrible name
  def actual_source_reflection; end

  private

  # returns either false or the inverse association name that it finds.
  def automatic_inverse_of; end

  def calculate_constructable(macro, options); end

  # Checks to see if the reflection doesn't have any options that prevent
  # us from being able to guess the inverse automatically. First, the
  # <tt>inverse_of</tt> option cannot be set to false. Second, we must
  # have <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations.
  # Third, we must not have options such as <tt>:polymorphic</tt> or
  # <tt>:foreign_key</tt> which prevent us from correctly guessing the
  # inverse association.
  #
  # Anything with a scope can additionally ruin our attempt at finding an
  # inverse, so we exclude reflections with scopes.
  #
  # @return [Boolean]
  def can_find_inverse_of_automatically?(reflection); end

  def derive_class_name; end
  def derive_foreign_key; end
  def derive_join_table; end

  # Attempts to find the inverse association name automatically.
  # If it cannot find a suitable inverse association name, it returns
  # nil.
  def inverse_name; end

  def primary_key(klass); end

  # Checks if the inverse reflection that is returned from the
  # +automatic_inverse_of+ method is a valid reflection. We must
  # make sure that the reflection's active_record name matches up
  # with the current reflection's klass name.
  #
  # Note: klass will always be valid because when there's a NameError
  # from calling +klass+, +reflection+ will already be set to false.
  #
  # @return [Boolean]
  def valid_inverse_reflection?(reflection); end
end

ActiveRecord::Reflection::AssociationReflection::INVALID_AUTOMATIC_INVERSE_OPTIONS = T.let(T.unsafe(nil), Array)
ActiveRecord::Reflection::AssociationReflection::VALID_AUTOMATIC_INVERSE_MACROS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Reflection::BelongsToReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end

  # @return [Boolean]
  def belongs_to?; end

  def join_id_for(owner); end
  def join_keys(association_klass); end
  def macro; end

  private

  def calculate_constructable(macro, options); end
end

# \Reflection enables the ability to examine the associations and aggregations of
# Active Record classes and objects. This information, for example,
# can be used in a form builder that takes an Active Record object
# and creates input fields for all of the attributes depending on their type
# and displays the associations to other objects.
#
# MacroReflection class has info for AggregateReflection and AssociationReflection
# classes.
module ActiveRecord::Reflection::ClassMethods
  def _reflect_on_association(association); end
  def clear_reflections_cache; end

  # Returns the AggregateReflection object for the named +aggregation+ (use the symbol).
  #
  #   Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection
  def reflect_on_aggregation(aggregation); end

  # Returns an array of AggregateReflection objects for all the aggregations in the class.
  def reflect_on_all_aggregations; end

  # Returns an array of AssociationReflection objects for all the
  # associations in the class. If you only want to reflect on a certain
  # association type, pass in the symbol (<tt>:has_many</tt>, <tt>:has_one</tt>,
  # <tt>:belongs_to</tt>) as the first parameter.
  #
  # Example:
  #
  #   Account.reflect_on_all_associations             # returns an array of all associations
  #   Account.reflect_on_all_associations(:has_many)  # returns an array of all has_many associations
  def reflect_on_all_associations(macro = T.unsafe(nil)); end

  # Returns an array of AssociationReflection objects for all associations which have <tt>:autosave</tt> enabled.
  def reflect_on_all_autosave_associations; end

  # Returns the AssociationReflection object for the +association+ (use the symbol).
  #
  #   Account.reflect_on_association(:owner)             # returns the owner AssociationReflection
  #   Invoice.reflect_on_association(:line_items).macro  # returns :has_many
  def reflect_on_association(association); end

  # Returns a Hash of name of the reflection as the key and an AssociationReflection as the value.
  #
  #   Account.reflections # => {"balance" => AggregateReflection}
  def reflections; end
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  # @return [HasAndBelongsToManyReflection] a new instance of HasAndBelongsToManyReflection
  def initialize(name, scope, options, active_record); end

  # @return [Boolean]
  def collection?; end

  def macro; end
end

class ActiveRecord::Reflection::HasManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end
  def association_primary_key(klass = T.unsafe(nil)); end

  # @return [Boolean]
  def collection?; end

  def macro; end
end

class ActiveRecord::Reflection::HasOneReflection < ::ActiveRecord::Reflection::AssociationReflection
  def association_class; end

  # @return [Boolean]
  def has_one?; end

  def macro; end

  private

  def calculate_constructable(macro, options); end
end

# Base class for AggregateReflection and AssociationReflection. Objects of
# AggregateReflection and AssociationReflection are returned by the Reflection::ClassMethods.
class ActiveRecord::Reflection::MacroReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [MacroReflection] a new instance of MacroReflection
  def initialize(name, scope, options, active_record); end

  # Returns +true+ if +self+ and +other_aggregation+ have the same +name+ attribute, +active_record+ attribute,
  # and +other_aggregation+ has an options hash assigned to it.
  def ==(other_aggregation); end

  # Returns the value of attribute active_record.
  def active_record; end

  def autosave=(autosave); end
  def compute_class(name); end

  # Returns the class for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns the Money class
  # <tt>has_many :clients</tt> returns the Client class
  def klass; end

  # Returns the name of the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>:balance</tt>
  # <tt>has_many :clients</tt> returns <tt>:clients</tt>
  def name; end

  # Returns the hash of options used for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
  # <tt>has_many :clients</tt> returns <tt>{}</tt>
  def options; end

  def plural_name; end

  # Returns the value of attribute scope.
  def scope; end

  def scope_for(klass); end

  private

  def derive_class_name; end
end

class ActiveRecord::Reflection::PolymorphicReflection < ::ActiveRecord::Reflection::ThroughReflection
  # @return [PolymorphicReflection] a new instance of PolymorphicReflection
  def initialize(reflection, previous_reflection); end

  def constraints; end
  def join_keys(association_klass); end
  def klass; end
  def plural_name; end
  def scope; end
  def source_type_info; end
  def table_name; end
  def type; end
end

class ActiveRecord::Reflection::RuntimeReflection < ::ActiveRecord::Reflection::PolymorphicReflection
  # @return [RuntimeReflection] a new instance of RuntimeReflection
  def initialize(reflection, association); end

  def alias_candidate(name); end
  def alias_name; end
  def all_includes; end
  def constraints; end
  def klass; end

  # Returns the value of attribute next.
  def next; end

  # Sets the attribute next
  #
  # @param value the value to set the attribute next to.
  def next=(_arg0); end

  def source_type_info; end
  def table_name; end
end

# Holds all the meta-data about a :through association as it was specified
# in the Active Record class.
class ActiveRecord::Reflection::ThroughReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [ThroughReflection] a new instance of ThroughReflection
  def initialize(delegate_reflection); end

  def active_record(*args, &block); end
  def active_record_primary_key(*args, &block); end
  def add_as_polymorphic_through(reflection, seed); end
  def add_as_source(seed); end
  def add_as_through(seed); end
  def association_class(*args, &block); end
  def association_foreign_key(*args, &block); end

  # We want to use the klass from this reflection, rather than just delegate straight to
  # the source_reflection, because the source_reflection may be polymorphic. We still
  # need to respect the source_reflection's :primary_key option, though.
  def association_primary_key(klass = T.unsafe(nil)); end

  def association_primary_key_type; end
  def association_scope_cache(*args, &block); end
  def autosave=(arg); end
  def belongs_to?(*args, &block); end
  def check_eager_loadable!(*args, &block); end
  def check_preloadable!(*args, &block); end
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  def clear_association_scope_cache; end

  # Returns an array of reflections which are involved in this association. Each item in the
  # array corresponds to a table which will be part of the query for this association.
  #
  # The chain is built by recursively calling #chain on the source reflection and the through
  # reflection. The base case for the recursion is a normal association, which just returns
  # [self] as its #chain.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.chain
  #   # => [<ActiveRecord::Reflection::ThroughReflection: @delegate_reflection=#<ActiveRecord::Reflection::HasManyReflection: @name=:tags...>,
  #         <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @options={}, @active_record=Post>]
  def collect_join_chain; end

  def collect_join_reflections(seed); end
  def collection?(*args, &block); end
  def compute_class(*args, &block); end
  def constraints; end
  def constructable?(*args, &block); end
  def delegate_reflection; end
  def extensions(*args, &block); end
  def foreign_key(*args, &block); end
  def foreign_type(*args, &block); end
  def has_inverse?(*args, &block); end
  def has_one?(*args, &block); end

  # @return [Boolean]
  def has_scope?; end

  def join_id_for(owner); end
  def join_keys(association_klass); end
  def join_table(*args, &block); end
  def klass; end
  def macro(*args, &block); end
  def name(*args, &block); end

  # A through association is nested if there would be more than one join table
  #
  # @return [Boolean]
  def nested?; end

  def options(*args, &block); end
  def parent_reflection(*args, &block); end
  def parent_reflection=(arg); end
  def plural_name(*args, &block); end
  def polymorphic?(*args, &block); end
  def polymorphic_inverse_of(*args, &block); end
  def scope(*args, &block); end

  # Consider the following example:
  #
  #   class Person
  #     has_many :articles
  #     has_many :comment_tags, through: :articles
  #   end
  #
  #   class Article
  #     has_many :comments
  #     has_many :comment_tags, through: :comments, source: :tags
  #   end
  #
  #   class Comment
  #     has_many :tags
  #   end
  #
  # There may be scopes on Person.comment_tags, Article.comment_tags and/or Comment.tags,
  # but only Comment.tags will be represented in the #chain. So this method creates an array
  # of scopes corresponding to the chain.
  def scope_chain; end

  def scope_for(*args, &block); end
  def source_options; end

  # Returns the source of the through reflection. It checks both a singularized
  # and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   class Tagging < ActiveRecord::Base
  #     belongs_to :post
  #     belongs_to :tag
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection
  #   # => <ActiveRecord::Reflection::BelongsToReflection: @name=:tag, @active_record=Tagging, @plural_name="tags">
  def source_reflection; end

  def source_reflection_name; end

  # Gets an array of possible <tt>:through</tt> source reflection names in both singular and plural form.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection_names
  #   # => [:tag, :tags]
  def source_reflection_names; end

  def through_options; end

  # Returns the AssociationReflection object specified in the <tt>:through</tt> option
  # of a HasManyThrough or HasOneThrough association.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.through_reflection
  #   # => <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @active_record=Post, @plural_name="taggings">
  def through_reflection; end

  # @return [Boolean]
  def through_reflection?; end

  def type(*args, &block); end
  def validate?(*args, &block); end

  protected

  # FIXME: this is a horrible name
  def actual_source_reflection; end

  def inverse_name; end
  def primary_key(klass); end

  private

  def derive_class_name; end
end

# = Active Record \Relation
class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::QueryMethods
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  extend ::ActiveRecord::Delegation::ClassMethods

  # @return [Relation] a new instance of Relation
  def initialize(klass, table, predicate_builder, values = T.unsafe(nil)); end

  # Compares two relations for equality.
  def ==(other); end

  def _update_record(values, id, id_was); end

  # Returns true if there are any records.
  #
  # @return [Boolean]
  def any?; end

  def arel_attribute(name); end
  def as_json(options = T.unsafe(nil)); end

  # Returns true if relation is blank.
  #
  # @return [Boolean]
  def blank?; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  def build(*args, &block); end

  # Returns a cache key that can be used to identify the records fetched by
  # this query. The cache key is built with a fingerprint of the sql query,
  # the number of records matched by the query and a timestamp of the last
  # updated record. When a new record comes to match the query, or any of
  # the existing records is updated or deleted, the cache key changes.
  #
  #   Product.where("name like ?", "%Cosmic Encounter%").cache_key
  #   # => "products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000"
  #
  # If the collection is loaded, the method will iterate through the records
  # to generate the timestamp, otherwise it will trigger one SQL query like:
  #
  #    SELECT COUNT(*), MAX("products"."updated_at") FROM "products" WHERE (name like '%Cosmic Encounter%')
  #
  # You can also pass a custom timestamp column to fetch the timestamp of the
  # last updated record.
  #
  #   Product.where("name like ?", "%Game%").cache_key(:last_reviewed_at)
  #
  # You can customize the strategy to generate the key on a per model basis
  # overriding ActiveRecord::Base#collection_cache_key.
  def cache_key(timestamp_column = T.unsafe(nil)); end

  # Tries to create a new record with the same scoped attributes
  # defined in the relation. Returns the initialized object if validation fails.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create}[rdoc-ref:Persistence::ClassMethods#create].
  #
  # ==== Examples
  #
  #   users = User.where(name: 'Oscar')
  #   users.create # => #<User id: 3, name: "Oscar", ...>
  #
  #   users.create(name: 'fxn')
  #   users.create # => #<User id: 4, name: "fxn", ...>
  #
  #   users.create { |user| user.name = 'tenderlove' }
  #   # => #<User id: 5, name: "tenderlove", ...>
  #
  #   users.create(name: nil) # validation on name
  #   # => #<User id: nil, name: nil, ...>
  def create(*args, &block); end

  # Similar to #create, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!]
  # on the base class. Raises an exception if a validation error occurs.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!].
  def create!(*args, &block); end

  # Deletes the row with a primary key matching the +id+ argument, using a
  # SQL +DELETE+ statement, and returns the number of rows deleted. Active
  # Record objects are not instantiated, so the object's callbacks are not
  # executed, including any <tt>:dependent</tt> association options.
  #
  # You can delete multiple rows at once by passing an Array of <tt>id</tt>s.
  #
  # Note: Although it is often much faster than the alternative,
  # #destroy, skipping callbacks might bypass business logic in
  # your application that ensures referential integrity or performs other
  # essential jobs.
  #
  # ==== Examples
  #
  #   # Delete a single row
  #   Todo.delete(1)
  #
  #   # Delete multiple rows
  #   Todo.delete([2,3,4])
  def delete(id_or_array); end

  # Deletes the records without instantiating the records
  # first, and hence not calling the {#destroy}[rdoc-ref:Persistence#destroy]
  # method nor invoking callbacks.
  # This is a single SQL DELETE statement that goes straight to the database, much more
  # efficient than #destroy_all. Be careful with relations though, in particular
  # <tt>:dependent</tt> rules defined on associations are not honored. Returns the
  # number of rows affected.
  #
  #   Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all
  #
  # Both calls delete the affected posts all at once with a single DELETE statement.
  # If you need to destroy dependent associations or call your <tt>before_*</tt> or
  # +after_destroy+ callbacks, use the #destroy_all method instead.
  #
  # If an invalid method is supplied, #delete_all raises an ActiveRecordError:
  #
  #   Post.limit(100).delete_all
  #   # => ActiveRecord::ActiveRecordError: delete_all doesn't support limit
  def delete_all(conditions = T.unsafe(nil)); end

  # Destroy an object (or multiple objects) that has the given id. The object is instantiated first,
  # therefore all callbacks and filters are fired off before the object is deleted. This method is
  # less efficient than #delete but allows cleanup methods and other actions to be run.
  #
  # This essentially finds the object (or multiple objects) with the given id, creates a new object
  # from the attributes, and then calls destroy on it.
  #
  # ==== Parameters
  #
  # * +id+ - Can be either an Integer or an Array of Integers.
  #
  # ==== Examples
  #
  #   # Destroy a single object
  #   Todo.destroy(1)
  #
  #   # Destroy multiple objects
  #   todos = [1,2,3]
  #   Todo.destroy(todos)
  def destroy(id); end

  # Destroys the records by instantiating each
  # record and calling its {#destroy}[rdoc-ref:Persistence#destroy] method.
  # Each object's callbacks are executed (including <tt>:dependent</tt> association options).
  # Returns the collection of objects that were destroyed; each will be frozen, to
  # reflect that no changes should be made (since they can't be persisted).
  #
  # Note: Instantiation, callback execution, and deletion of each
  # record can be time consuming when you're removing many records at
  # once. It generates at least one SQL +DELETE+ query per record (or
  # possibly more, to enforce your callbacks). If you want to delete many
  # rows quickly, without concern for their associations or callbacks, use
  # #delete_all instead.
  #
  # ==== Examples
  #
  #   Person.where(age: 0..18).destroy_all
  def destroy_all(conditions = T.unsafe(nil)); end

  # Returns true if relation needs eager loading.
  #
  # @return [Boolean]
  def eager_loading?; end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  def empty?; end

  # @return [Boolean]
  def empty_scope?; end

  # Serializes the relation objects Array.
  def encode_with(coder); end

  # Runs EXPLAIN on the query or queries triggered by this relation and
  # returns the result as a string. The string is formatted imitating the
  # ones printed by the database shell.
  #
  # Note that this method actually runs the queries, since the results of some
  # are needed by the next ones when eager loading is going on.
  #
  # Please see further details in the
  # {Active Record Query Interface guide}[http://guides.rubyonrails.org/active_record_querying.html#running-explain].
  def explain; end

  # Finds the first record with the given attributes, or creates a record
  # with the attributes if one is not found:
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   # We already have one so the existing record will be returned.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Scarlett" or create a new one with
  #   # a particular last name.
  #   User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method accepts a block, which is passed down to #create. The last example
  # above can be alternatively written this way:
  #
  #   # Find the first user named "Scarlett" or create a new one with a
  #   # different last name.
  #   User.find_or_create_by(first_name: 'Scarlett') do |user|
  #     user.last_name = 'Johansson'
  #   end
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method always returns a record, but if creation was attempted and
  # failed due to validation errors it won't be persisted, you get what
  # #create returns in such situation.
  #
  # Please note *this method is not atomic*, it runs first a SELECT, and if
  # there are no results an INSERT is attempted. If there are other threads
  # or processes there is a race condition between both calls and it could
  # be the case that you end up with two similar records.
  #
  # Whether that is a problem or not depends on the logic of the
  # application, but in the particular case in which rows have a UNIQUE
  # constraint an exception may be raised, just retry:
  #
  #  begin
  #    CreditAccount.transaction(requires_new: true) do
  #      CreditAccount.find_or_create_by(user_id: user.id)
  #    end
  #  rescue ActiveRecord::RecordNotUnique
  #    retry
  #  end
  def find_or_create_by(attributes, &block); end

  # Like #find_or_create_by, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception
  # is raised if the created record is invalid.
  def find_or_create_by!(attributes, &block); end

  # Like #find_or_create_by, but calls {new}[rdoc-ref:Core#new]
  # instead of {create}[rdoc-ref:Persistence::ClassMethods#create].
  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes = T.unsafe(nil), &block); end
  def first_or_create!(attributes = T.unsafe(nil), &block); end
  def first_or_initialize(attributes = T.unsafe(nil), &block); end
  def insert(values); end
  def inspect; end

  # Joins that are also marked for preloading. In which case we should just eager load them.
  # Note that this is a naive implementation because we could have strings and symbols which
  # represent the same association, but that aren't matched by this. Also, we could have
  # nested hashes which partially match, e.g. { a: :b } & { a: [:b, :c] }
  def joined_includes_values; end

  # Returns the value of attribute klass.
  def klass; end

  # Causes the records to be loaded from the database if they have not
  # been loaded already. You can use this if for some reason you need
  # to explicitly load some records before actually using them. The
  # return value is the relation itself, not the records.
  #
  #   Post.where(published: true).load # => #<ActiveRecord::Relation>
  def load(&block); end

  # Returns the value of attribute loaded.
  def loaded; end

  # Returns the value of attribute loaded.
  def loaded?; end

  # Returns true if there is more than one record.
  #
  # @return [Boolean]
  def many?; end

  # Returns the value of attribute klass.
  def model; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  def new(*args, &block); end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  def none?; end

  # Returns true if there is exactly one record.
  #
  # @return [Boolean]
  def one?; end

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end

  def pretty_print(q); end
  def records; end

  # Forces reloading of relation.
  def reload; end

  def reset; end
  def scope_for_create; end

  # Scope all queries to the current scope.
  #
  #   Comment.where(post_id: 1).scoping do
  #     Comment.first
  #   end
  #   # => SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1
  #
  # Please check unscoped if you want to remove all previous scopes (including
  # the default_scope) during the execution of a block.
  def scoping; end

  # Returns size of the records.
  def size; end

  def substitute_values(values); end

  # Returns the value of attribute table.
  def table; end

  # Converts relation objects to Array.
  def to_a; end

  # Returns sql statement for the relation.
  #
  #   User.where(name: 'Oscar').to_sql
  #   # => SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'
  def to_sql; end

  # {#uniq}[rdoc-ref:QueryMethods#uniq] and
  # {#uniq!}[rdoc-ref:QueryMethods#uniq!] are silently deprecated.
  # #uniq_value delegates to #distinct_value to maintain backwards compatibility.
  # Use #distinct_value instead.
  def uniq_value(*args, &block); end

  # Updates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be updated.
  # * +attributes+ - This should be a hash of attributes or an array of hashes.
  #
  # ==== Examples
  #
  #   # Updates one record
  #   Person.update(15, user_name: 'Samuel', group: 'expert')
  #
  #   # Updates multiple records
  #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
  #   Person.update(people.keys, people.values)
  #
  #   # Updates multiple records from the result of a relation
  #   people = Person.where(group: 'expert')
  #   people.update(group: 'masters')
  #
  # Note: Updating a large number of records will run an
  # UPDATE query for each record, which may cause a performance
  # issue. So if it is not needed to run callbacks for each update, it is
  # preferred to use #update_all for updating all records using
  # a single query.
  def update(id = T.unsafe(nil), attributes); end

  # Updates all records in the current relation with details given. This method constructs a single SQL UPDATE
  # statement and sends it straight to the database. It does not instantiate the involved models and it does not
  # trigger Active Record callbacks or validations. However, values passed to #update_all will still go through
  # Active Record's normal type casting and serialization.
  #
  # ==== Parameters
  #
  # * +updates+ - A string, array, or hash representing the SET part of an SQL statement.
  #
  # ==== Examples
  #
  #   # Update all customers with the given attributes
  #   Customer.update_all wants_email: true
  #
  #   # Update all books with 'Rails' in their title
  #   Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')
  #
  #   # Update all books that match conditions, but limit it to 5 ordered by date
  #   Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')
  #
  #   # Update all invoices and set the number column to its id value.
  #   Invoice.update_all('number = id')
  #
  # @raise [ArgumentError]
  def update_all(updates); end

  def values; end

  # Returns a hash of where conditions.
  #
  #   User.where(name: 'Oscar').where_values_hash
  #   # => {name: "Oscar"}
  def where_values_hash(relation_table_name = T.unsafe(nil)); end

  protected

  def load_records(records); end

  private

  def build_preloader; end
  def exec_queries(&block); end
  def initialize_copy(other); end

  # @return [Boolean]
  def references_eager_loaded_tables?; end

  def tables_in_string(string); end
end

ActiveRecord::Relation::CLAUSE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::FromClause
  # @return [FromClause] a new instance of FromClause
  def initialize(value, name); end

  def binds; end

  # @return [Boolean]
  def empty?; end

  def merge(other); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute value.
  def value; end

  class << self
    def empty; end
  end
end

class ActiveRecord::Relation::HashMerger
  # @return [HashMerger] a new instance of HashMerger
  def initialize(relation, hash); end

  # Returns the value of attribute hash.
  def hash; end

  def merge; end

  # Applying values to a relation has some side effects. E.g.
  # interpolation might take place for where values. So we should
  # build a relation to merge in rather than directly merging
  # the values.
  def other; end

  # Returns the value of attribute relation.
  def relation; end
end

ActiveRecord::Relation::INVALID_METHODS_FOR_DELETE_ALL = T.let(T.unsafe(nil), Array)
ActiveRecord::Relation::MULTI_VALUE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::Merger
  # @return [Merger] a new instance of Merger
  def initialize(relation, other); end

  def merge; end
  def normal_values; end

  # Returns the value of attribute other.
  def other; end

  # Returns the value of attribute relation.
  def relation; end

  # Returns the value of attribute values.
  def values; end

  private

  def merge_clauses; end
  def merge_joins; end
  def merge_multi_values; end
  def merge_preloads; end
  def merge_single_values; end
end

ActiveRecord::Relation::Merger::CLAUSE_METHOD_NAMES = T.let(T.unsafe(nil), Array)
ActiveRecord::Relation::Merger::NORMAL_VALUES = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::QueryAttribute < ::ActiveRecord::Attribute
  def type_cast(value); end
  def value_for_database; end
  def with_cast_value(value); end
end

ActiveRecord::Relation::SINGLE_VALUE_METHODS = T.let(T.unsafe(nil), Array)
ActiveRecord::Relation::VALUE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::WhereClause
  # @return [WhereClause] a new instance of WhereClause
  def initialize(predicates, binds); end

  def +(other); end
  def ==(other); end
  def any?(*args, &block); end
  def ast; end

  # Returns the value of attribute binds.
  def binds; end

  def empty?(*args, &block); end
  def except(*columns); end
  def invert; end
  def merge(other); end
  def or(other); end
  def to_h(table_name = T.unsafe(nil)); end

  protected

  # Returns the value of attribute predicates.
  def predicates; end

  def referenced_columns; end

  private

  def binds_except(columns); end

  # @return [Boolean]
  def equality_node?(node); end

  def invert_predicate(node); end
  def inverted_predicates; end
  def non_conflicting_binds(other); end
  def non_empty_predicates; end
  def predicates_except(columns); end
  def predicates_unreferenced_by(other); end
  def predicates_with_wrapped_sql_literals; end
  def wrap_sql_literal(node); end

  class << self
    def empty; end
  end
end

ActiveRecord::Relation::WhereClause::ARRAY_WITH_EMPTY_STRING = T.let(T.unsafe(nil), Array)

class ActiveRecord::Relation::WhereClauseFactory
  # @return [WhereClauseFactory] a new instance of WhereClauseFactory
  def initialize(klass, predicate_builder); end

  def build(opts, other); end

  protected

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute predicate_builder.
  def predicate_builder; end
end

# This class encapsulates a result returned from calling
# {#exec_query}[rdoc-ref:ConnectionAdapters::DatabaseStatements#exec_query]
# on any database connection adapter. For example:
#
#   result = ActiveRecord::Base.connection.exec_query('SELECT id, title, body FROM posts')
#   result # => #<ActiveRecord::Result:0xdeadbeef>
#
#   # Get the column names of the result:
#   result.columns
#   # => ["id", "title", "body"]
#
#   # Get the record values of the result:
#   result.rows
#   # => [[1, "title_1", "body_1"],
#         [2, "title_2", "body_2"],
#         ...
#        ]
#
#   # Get an array of hashes representing the result (column => value):
#   result.to_hash
#   # => [{"id" => 1, "title" => "title_1", "body" => "body_1"},
#         {"id" => 2, "title" => "title_2", "body" => "body_2"},
#         ...
#        ]
#
#   # ActiveRecord::Result also includes Enumerable.
#   result.each do |row|
#     puts row['title'] + " " + row['body']
#   end
class ActiveRecord::Result
  include ::Enumerable

  # @return [Result] a new instance of Result
  def initialize(columns, rows, column_types = T.unsafe(nil)); end

  def [](idx); end
  def cast_values(type_overrides = T.unsafe(nil)); end
  def collect!; end

  # Returns the value of attribute column_types.
  def column_types; end

  # Returns the value of attribute columns.
  def columns; end

  def each; end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  def empty?; end

  def first; end
  def last; end
  def length; end
  def map!; end

  # Returns the value of attribute rows.
  def rows; end

  def to_ary; end
  def to_hash; end

  private

  def column_type(name, type_overrides = T.unsafe(nil)); end
  def hash_rows; end
  def initialize_copy(other); end
end

ActiveRecord::Result::IDENTITY_TYPE = T.let(T.unsafe(nil), ActiveModel::Type::Value)

# {ActiveRecord::Base.transaction}[rdoc-ref:Transactions::ClassMethods#transaction]
# uses this exception to distinguish a deliberate rollback from other exceptional situations.
# Normally, raising an exception will cause the
# {.transaction}[rdoc-ref:Transactions::ClassMethods#transaction] method to rollback
# the database transaction *and* pass on the exception. But if you raise an
# ActiveRecord::Rollback exception, then the database transaction will be rolled back,
# without passing on the exception.
#
# For example, you could do this in your controller to rollback a transaction:
#
#   class BooksController < ActionController::Base
#     def create
#       Book.transaction do
#         book = Book.new(params[:book])
#         book.save!
#         if today_is_friday?
#           # The system must fail on Friday so that our support department
#           # won't be out of job. We silently rollback this transaction
#           # without telling the user.
#           raise ActiveRecord::Rollback, "Call tech support!"
#         end
#       end
#       # ActiveRecord::Rollback is the only exception that won't be passed on
#       # by ActiveRecord::Base.transaction, so this line will still be reached
#       # even on Friday.
#       redirect_to root_url
#     end
#   end
class ActiveRecord::Rollback < ::ActiveRecord::ActiveRecordError; end

# This is a thread locals registry for Active Record. For example:
#
#   ActiveRecord::RuntimeRegistry.connection_handler
#
# returns the connection handler local to the current thread.
#
# See the documentation of ActiveSupport::PerThreadRegistry
# for further details.
class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # Returns the value of attribute connection_handler.
  def connection_handler; end

  # Sets the attribute connection_handler
  #
  # @param value the value to set the attribute connection_handler to.
  def connection_handler=(_arg0); end

  # Returns the value of attribute connection_id.
  def connection_id; end

  # Sets the attribute connection_id
  #
  # @param value the value to set the attribute connection_id to.
  def connection_id=(_arg0); end

  # Returns the value of attribute sql_runtime.
  def sql_runtime; end

  # Sets the attribute sql_runtime
  #
  # @param value the value to set the attribute sql_runtime to.
  def sql_runtime=(_arg0); end

  class << self
    def connection_handler; end
    def connection_handler=(x); end
    def connection_id; end
    def connection_id=(x); end
    def sql_runtime; end
    def sql_runtime=(x); end
  end
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Sanitization::ClassMethods

  # TODO: Deprecate this
  def quoted_id; end
end

module ActiveRecord::Sanitization::ClassMethods
  # Used to sanitize objects before they're used in an SQL SELECT statement.
  # Delegates to {connection.quote}[rdoc-ref:ConnectionAdapters::Quoting#quote].
  def quote_value(object); end

  # Used to sanitize objects before they're used in an SQL SELECT statement.
  # Delegates to {connection.quote}[rdoc-ref:ConnectionAdapters::Quoting#quote].
  def sanitize(object); end

  protected

  # Accepts a hash of SQL conditions and replaces those attributes
  # that correspond to a {#composed_of}[rdoc-ref:Aggregations::ClassMethods#composed_of]
  # relationship with their expanded aggregate attribute values.
  #
  # Given:
  #
  #   class Person < ActiveRecord::Base
  #     composed_of :address, class_name: "Address",
  #       mapping: [%w(address_street street), %w(address_city city)]
  #   end
  #
  # Then:
  #
  #   { address: Address.new("813 abc st.", "chicago") }
  #   # => { address_street: "813 abc st.", address_city: "chicago" }
  def expand_hash_conditions_for_aggregates(attrs); end

  def quote_bound_value(value, c = T.unsafe(nil)); end
  def raise_if_bind_arity_mismatch(statement, expected, provided); end
  def replace_bind_variable(value, c = T.unsafe(nil)); end
  def replace_bind_variables(statement, values); end
  def replace_named_bind_variables(statement, bind_vars); end

  # Accepts an array or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_conditions(condition); end

  # Accepts an array or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql(condition); end

  # Accepts an array of conditions. The array has each value
  # sanitized and interpolated into the SQL statement.
  #
  #   sanitize_sql_array(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql_array(ary); end

  # Accepts an array, hash, or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a SET clause.
  #
  #   sanitize_sql_for_assignment(["name=? and group_id=?", nil, 4])
  #   # => "name=NULL and group_id=4"
  #
  #   sanitize_sql_for_assignment(["name=:name and group_id=:group_id", name: nil, group_id: 4])
  #   # => "name=NULL and group_id=4"
  #
  #   Post.send(:sanitize_sql_for_assignment, { name: nil, group_id: 4 })
  #   # => "`posts`.`name` = NULL, `posts`.`group_id` = 4"
  #
  #   sanitize_sql_for_assignment("name=NULL and group_id='4'")
  #   # => "name=NULL and group_id='4'"
  def sanitize_sql_for_assignment(assignments, default_table_name = T.unsafe(nil)); end

  # Accepts an array or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  def sanitize_sql_for_conditions(condition); end

  # Accepts an array, or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for an ORDER clause.
  #
  #   sanitize_sql_for_order(["field(id, ?)", [1,3,2]])
  #   # => "field(id, 1,3,2)"
  #
  #   sanitize_sql_for_order("id ASC")
  #   # => "id ASC"
  def sanitize_sql_for_order(condition); end

  # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
  #
  #   sanitize_sql_hash_for_assignment({ status: nil, group_id: 1 }, "posts")
  #   # => "`posts`.`status` = NULL, `posts`.`group_id` = 1"
  def sanitize_sql_hash_for_assignment(attrs, table); end

  # Sanitizes a +string+ so that it is safe to use within an SQL
  # LIKE statement. This method uses +escape_character+ to escape all occurrences of "\", "_" and "%".
  #
  #   sanitize_sql_like("100%")
  #   # => "100\\%"
  #
  #   sanitize_sql_like("snake_cased_string")
  #   # => "snake\\_cased\\_string"
  #
  #   sanitize_sql_like("100%", "!")
  #   # => "100!%"
  #
  #   sanitize_sql_like("snake_cased_string", "!")
  #   # => "snake!_cased!_string"
  def sanitize_sql_like(string, escape_character = T.unsafe(nil)); end
end

# = Active Record \Schema
#
# Allows programmers to programmatically define a schema in a portable
# DSL. This means you can define tables, indexes, etc. without using SQL
# directly, so your applications can more easily support multiple
# databases.
#
# Usage:
#
#   ActiveRecord::Schema.define do
#     create_table :authors do |t|
#       t.string :name, null: false
#     end
#
#     add_index :authors, :name, :unique
#
#     create_table :posts do |t|
#       t.integer :author_id, null: false
#       t.string :subject
#       t.text :body
#       t.boolean :private, default: false
#     end
#
#     add_index :posts, :author_id
#   end
#
# ActiveRecord::Schema is only supported by database adapters that also
# support migrations, the two features being very similar.
class ActiveRecord::Schema < ::ActiveRecord::Migration::Current
  def define(info, &block); end

  private

  # Returns the migrations paths.
  #
  #   ActiveRecord::Schema.new.migrations_paths
  #   # => ["db/migrate"] # Rails migration path by default.
  def migrations_paths; end

  class << self
    # Eval the given block. All methods available to the current connection
    # adapter are available within the block, so you can easily use the
    # database definition DSL to build up your schema (
    # {create_table}[rdoc-ref:ConnectionAdapters::SchemaStatements#create_table],
    # {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index], etc.).
    #
    # The +info+ hash is optional, and if given is used to define metadata
    # about the current schema (currently, only the schema's version):
    #
    #   ActiveRecord::Schema.define(version: 20380119000001) do
    #     ...
    #   end
    def define(info = T.unsafe(nil), &block); end
  end
end

# = Active Record Schema Dumper
#
# This class is used to dump the database schema for some connection to some
# output format (i.e., ActiveRecord::Schema).
class ActiveRecord::SchemaDumper
  # @return [SchemaDumper] a new instance of SchemaDumper
  def initialize(connection, options = T.unsafe(nil)); end

  def dump(stream); end

  # :singleton-method:
  # A list of tables which should not be dumped to the schema.
  # Acceptable values are strings as well as regexp.
  # This setting is only used if ActiveRecord::Base.schema_format == :ruby
  def ignore_tables; end

  def ignore_tables=(obj); end

  private

  def extensions(stream); end
  def foreign_keys(table, stream); end
  def format_options(options); end
  def header(stream); end

  # @return [Boolean]
  def ignored?(table_name); end

  def index_parts(index); end

  # Keep it for indexing materialized views
  def indexes(table, stream); end

  def indexes_in_create(table, stream); end
  def remove_prefix_and_suffix(table); end
  def table(table, stream); end
  def tables(stream); end
  def trailer(stream); end

  class << self
    def dump(connection = T.unsafe(nil), stream = T.unsafe(nil), config = T.unsafe(nil)); end
    def ignore_tables; end
    def ignore_tables=(obj); end

    private

    def generate_options(config); end
  end
end

# This class is used to create a table that keeps track of which migrations
# have been applied to a given database. When a migration is run, its schema
# number is inserted in to the `SchemaMigration.table_name` so it doesn't need
# to be executed the next time.
class ActiveRecord::SchemaMigration < ::ActiveRecord::Base
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods

  def version; end

  class << self
    def _validators; end
    def attribute_type_decorations; end
    def create_table; end
    def defined_enums; end
    def drop_table; end
    def normalize_migration_number(number); end
    def normalized_versions; end
    def primary_key; end

    # @return [Boolean]
    def table_exists?; end

    def table_name; end
  end
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation < ::ActiveRecord::AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy < ::ActiveRecord::Associations::CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation < ::ActiveRecord::Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods; end

# = Active Record \Named \Scopes
module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods

  def initialize_internals_callback; end
  def populate_with_current_scope_attributes; end

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

module ActiveRecord::Scoping::ClassMethods
  def current_scope(skip_inherited_scope = T.unsafe(nil)); end
  def current_scope=(scope); end

  # Collects attributes from scopes that should be applied when creating
  # an AR instance for the particular class this is called on.
  def scope_attributes; end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  def scope_attributes?; end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

module ActiveRecord::Scoping::Default::ClassMethods
  def before_remove_const; end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  def scope_attributes?; end

  # Returns a scope for the model without the previously set scopes.
  #
  #   class Post < ActiveRecord::Base
  #     def self.default_scope
  #       where(published: true)
  #     end
  #   end
  #
  #   Post.all                                  # Fires "SELECT * FROM posts WHERE published = true"
  #   Post.unscoped.all                         # Fires "SELECT * FROM posts"
  #   Post.where(published: false).unscoped.all # Fires "SELECT * FROM posts"
  #
  # This method also accepts a block. All queries inside the block will
  # not use the previously set scopes.
  #
  #   Post.unscoped {
  #     Post.limit(10) # Fires "SELECT * FROM posts LIMIT 10"
  #   }
  def unscoped; end

  protected

  def build_default_scope(base_rel = T.unsafe(nil)); end

  # Use this macro in your model to set a default scope for all operations on
  # the model.
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #   end
  #
  #   Article.all # => SELECT * FROM articles WHERE published = true
  #
  # The #default_scope is also applied while creating/building a record.
  # It is not applied while updating a record.
  #
  #   Article.new.published    # => true
  #   Article.create.published # => true
  #
  # (You can also pass any object which responds to +call+ to the
  # +default_scope+ macro, and it will be called when building the
  # default scope.)
  #
  # If you use multiple #default_scope declarations in your model then
  # they will be merged together:
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #     default_scope { where(rating: 'G') }
  #   end
  #
  #   Article.all # => SELECT * FROM articles WHERE published = true AND rating = 'G'
  #
  # This is also the case with inheritance and module includes where the
  # parent or module defines a #default_scope and the child or including
  # class defines a second one.
  #
  # If you need to do more complex things with a default scope, you can
  # alternatively define it as a class method:
  #
  #   class Article < ActiveRecord::Base
  #     def self.default_scope
  #       # Should return a scope, you can call 'super' here etc.
  #     end
  #   end
  def default_scope(scope = T.unsafe(nil)); end

  # The ignore_default_scope flag is used to prevent an infinite recursion
  # situation where a default scope references a scope which has a default
  # scope which references a scope...
  def evaluate_default_scope; end

  def ignore_default_scope=(ignore); end

  # @return [Boolean]
  def ignore_default_scope?; end
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods
end

module ActiveRecord::Scoping::Named::ClassMethods
  # Returns an ActiveRecord::Relation scope object.
  #
  #   posts = Post.all
  #   posts.size # Fires "select count(*) from  posts" and returns the count
  #   posts.each {|p| puts p.name } # Fires "select * from posts" and loads post objects
  #
  #   fruits = Fruit.all
  #   fruits = fruits.where(color: 'red') if options[:red_only]
  #   fruits = fruits.limit(10) if limited?
  #
  # You can define a scope that applies to all finders using
  # {default_scope}[rdoc-ref:Scoping::Default::ClassMethods#default_scope].
  def all; end

  def default_extensions; end
  def default_scoped(scope = T.unsafe(nil)); end

  # Adds a class method for retrieving and querying objects.
  # The method is intended to return an ActiveRecord::Relation
  # object, which is composable with other scopes.
  # If it returns nil or false, an
  # {all}[rdoc-ref:Scoping::Named::ClassMethods#all] scope is returned instead.
  #
  # A \scope represents a narrowing of a database query, such as
  # <tt>where(color: :red).select('shirts.*').includes(:washing_instructions)</tt>.
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') }
  #     scope :dry_clean_only, -> { joins(:washing_instructions).where('washing_instructions.dry_clean_only = ?', true) }
  #   end
  #
  # The above calls to #scope define class methods <tt>Shirt.red</tt> and
  # <tt>Shirt.dry_clean_only</tt>. <tt>Shirt.red</tt>, in effect,
  # represents the query <tt>Shirt.where(color: 'red')</tt>.
  #
  # You should always pass a callable object to the scopes defined
  # with #scope. This ensures that the scope is re-evaluated each
  # time it is called.
  #
  # Note that this is simply 'syntactic sugar' for defining an actual
  # class method:
  #
  #   class Shirt < ActiveRecord::Base
  #     def self.red
  #       where(color: 'red')
  #     end
  #   end
  #
  # Unlike <tt>Shirt.find(...)</tt>, however, the object returned by
  # <tt>Shirt.red</tt> is not an Array but an ActiveRecord::Relation,
  # which is composable with other scopes; it resembles the association object
  # constructed by a {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # declaration. For instance, you can invoke <tt>Shirt.red.first</tt>, <tt>Shirt.red.count</tt>,
  # <tt>Shirt.red.where(size: 'small')</tt>. Also, just as with the
  # association objects, named \scopes act like an Array, implementing
  # Enumerable; <tt>Shirt.red.each(&block)</tt>, <tt>Shirt.red.first</tt>,
  # and <tt>Shirt.red.inject(memo, &block)</tt> all behave as if
  # <tt>Shirt.red</tt> really was an array.
  #
  # These named \scopes are composable. For instance,
  # <tt>Shirt.red.dry_clean_only</tt> will produce all shirts that are
  # both red and dry clean only. Nested finds and calculations also work
  # with these compositions: <tt>Shirt.red.dry_clean_only.count</tt>
  # returns the number of garments for which these criteria obtain.
  # Similarly with <tt>Shirt.red.dry_clean_only.average(:thread_count)</tt>.
  #
  # All scopes are available as class methods on the ActiveRecord::Base
  # descendant upon which the \scopes were defined. But they are also
  # available to {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # associations. If,
  #
  #   class Person < ActiveRecord::Base
  #     has_many :shirts
  #   end
  #
  # then <tt>elton.shirts.red.dry_clean_only</tt> will return all of
  # Elton's red, dry clean only shirts.
  #
  # \Named scopes can also have extensions, just as with
  # {has_many}[rdoc-ref:Associations::ClassMethods#has_many] declarations:
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') } do
  #       def dom_id
  #         'red_shirts'
  #       end
  #     end
  #   end
  #
  # Scopes can also be used while creating/building a record.
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #   end
  #
  #   Article.published.new.published    # => true
  #   Article.published.create.published # => true
  #
  # \Class methods on your model are automatically available
  # on scopes. Assuming the following setup:
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #     scope :featured, -> { where(featured: true) }
  #
  #     def self.latest_article
  #       order('published_at desc').first
  #     end
  #
  #     def self.titles
  #       pluck(:title)
  #     end
  #   end
  #
  # We are able to call the methods like this:
  #
  #   Article.published.featured.latest_article
  #   Article.featured.titles
  def scope(name, body, &block); end

  def scope_for_association(scope = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  def valid_scope_name?(name); end
end

# This class stores the +:current_scope+ and +:ignore_default_scope+ values
# for different classes. The registry is stored as a thread local, which is
# accessed through +ScopeRegistry.current+.
#
# This class allows you to store and get the scope values on different
# classes and different types of scopes. For example, if you are attempting
# to get the current_scope for the +Board+ model, then you would use the
# following code:
#
#   registry = ActiveRecord::Scoping::ScopeRegistry
#   registry.set_value_for(:current_scope, Board, some_new_scope)
#
# Now when you run:
#
#   registry.value_for(:current_scope, Board)
#
# You will obtain whatever was defined in +some_new_scope+. The #value_for
# and #set_value_for methods are delegated to the current ScopeRegistry
# object, so the above example code can also be called as:
#
#   ActiveRecord::Scoping::ScopeRegistry.set_value_for(:current_scope,
#       Board, some_new_scope)
class ActiveRecord::Scoping::ScopeRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [ScopeRegistry] a new instance of ScopeRegistry
  def initialize; end

  # Sets the +value+ for a given +scope_type+ and +model+.
  def set_value_for(scope_type, model, value); end

  # Obtains the value for a given +scope_type+ and +model+.
  def value_for(scope_type, model, skip_inherited_scope = T.unsafe(nil)); end

  private

  def raise_invalid_scope_type!(scope_type); end
end

ActiveRecord::Scoping::ScopeRegistry::VALID_SCOPE_TYPES = T.let(T.unsafe(nil), Array)

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::SecureToken::ClassMethods
end

module ActiveRecord::SecureToken::ClassMethods
  def generate_unique_secure_token; end

  # Example using #has_secure_token
  #
  #   # Schema: User(token:string, auth_token:string)
  #   class User < ActiveRecord::Base
  #     has_secure_token
  #     has_secure_token :auth_token
  #   end
  #
  #   user = User.new
  #   user.save
  #   user.token # => "pX27zsMN2ViQKta1bGfLmVJE"
  #   user.auth_token # => "77TMHrHJFvFDwodq8w7Ev2m7"
  #   user.regenerate_token # => true
  #   user.regenerate_auth_token # => true
  #
  # <tt>SecureRandom::base58</tt> is used to generate the 24-character unique token, so collisions are highly unlikely.
  #
  # Note that it's still possible to generate a race condition in the database in the same way that
  # {validates_uniqueness_of}[rdoc-ref:Validations::ClassMethods#validates_uniqueness_of] can.
  # You're encouraged to add a unique index in the database to deal with this even more unlikely scenario.
  def has_secure_token(attribute = T.unsafe(nil)); end
end

# = Active Record \Serialization
module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::Serializers::JSON

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Naming

  def serializable_hash(options = T.unsafe(nil)); end

  module GeneratedClassMethods
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
  end

  module GeneratedInstanceMethods
    def include_root_in_json; end
    def include_root_in_json?; end
  end
end

# Raised when unserialized object's type mismatches one specified for serializable field.
class ActiveRecord::SerializationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

module ActiveRecord::SpawnMethods
  # Removes from the query the condition(s) specified in +skips+.
  #
  #   Post.order('id asc').except(:order)                  # discards the order condition
  #   Post.where('id > 10').order('id asc').except(:where) # discards the where condition but keeps the order
  def except(*skips); end

  # Merges in the conditions from <tt>other</tt>, if <tt>other</tt> is an ActiveRecord::Relation.
  # Returns an array representing the intersection of the resulting records with <tt>other</tt>, if <tt>other</tt> is an array.
  #
  #   Post.where(published: true).joins(:comments).merge( Comment.where(spam: false) )
  #   # Performs a single join query with both where conditions.
  #
  #   recent_posts = Post.order('created_at DESC').first(5)
  #   Post.where(published: true).merge(recent_posts)
  #   # Returns the intersection of all published posts with the 5 most recently created posts.
  #   # (This is just an example. You'd probably want to do this with a single query!)
  #
  # Procs will be evaluated by merge:
  #
  #   Post.where(published: true).merge(-> { joins(:comments) })
  #   # => Post.where(published: true).joins(:comments)
  #
  # This is mainly intended for sharing common conditions between multiple associations.
  def merge(other); end

  def merge!(other); end

  # Removes any condition from the query other than the one(s) specified in +onlies+.
  #
  #   Post.order('id asc').only(:where)         # discards the order condition
  #   Post.order('id asc').only(:where, :order) # uses the specified order
  def only(*onlies); end

  # This is overridden by Associations::CollectionProxy
  def spawn; end

  private

  def relation_with(values); end
end

# Raised on attempt to save stale record. Record is stale when it's being saved in another query after
# instantiation, for example, when two users edit the same wiki page and one starts editing and saves
# the page before the other.
#
# Read more about optimistic locking in ActiveRecord::Locking module
# documentation.
class ActiveRecord::StaleObjectError < ::ActiveRecord::ActiveRecordError
  # @return [StaleObjectError] a new instance of StaleObjectError
  def initialize(record = T.unsafe(nil), attempted_action = T.unsafe(nil)); end

  # Returns the value of attribute attempted_action.
  def attempted_action; end

  # Returns the value of attribute record.
  def record; end
end

# Statement cache is used to cache a single statement in order to avoid creating the AST again.
# Initializing the cache is done by passing the statement in the create block:
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: "my book").where("author_id > 3")
#   end
#
# The cached statement is executed by using the
# [connection.execute]{rdoc-ref:ConnectionAdapters::DatabaseStatements#execute} method:
#
#   cache.execute([], Book, Book.connection)
#
# The relation returned by the block is cached, and for each
# [execute]{rdoc-ref:ConnectionAdapters::DatabaseStatements#execute}
# call the cached relation gets duped. Database is queried when +to_a+ is called on the relation.
#
# If you want to cache the statement without the values you can use the +bind+ method of the
# block parameter.
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: params.bind)
#   end
#
# And pass the bind values as the first argument of +execute+ call.
#
#   cache.execute(["my book"], Book, Book.connection)
class ActiveRecord::StatementCache
  # @return [StatementCache] a new instance of StatementCache
  def initialize(query_builder, bind_map); end

  # Returns the value of attribute bind_map.
  def bind_map; end

  def call(params, klass, connection, &block); end
  def execute(params, klass, connection, &block); end

  # Returns the value of attribute query_builder.
  def query_builder; end

  class << self
    def create(connection, block = T.unsafe(nil)); end
    def partial_query(visitor, ast, collector); end
    def query(visitor, ast); end
  end
end

class ActiveRecord::StatementCache::BindMap
  # @return [BindMap] a new instance of BindMap
  def initialize(bound_attributes); end

  def bind(values); end
end

class ActiveRecord::StatementCache::Params
  def bind; end
end

class ActiveRecord::StatementCache::PartialQuery < ::ActiveRecord::StatementCache::Query
  # @return [PartialQuery] a new instance of PartialQuery
  def initialize(values); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
  # @return [Query] a new instance of Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Substitute; end

# Superclass for all database execution errors.
#
# Wraps the underlying database error as +cause+.
class ActiveRecord::StatementInvalid < ::ActiveRecord::ActiveRecordError
  # @return [StatementInvalid] a new instance of StatementInvalid
  def initialize(message = T.unsafe(nil), original_exception = T.unsafe(nil)); end

  def original_exception; end
end

# Store gives you a thin wrapper around serialize for the purpose of storing hashes in a single column.
# It's like a simple key/value store baked into your record when you don't care about being able to
# query that store outside the context of a single record.
#
# You can then declare accessors to this store that are then accessible just like any other attribute
# of the model. This is very helpful for easily exposing store keys to a form or elsewhere that's
# already built around just accessing attributes on the model.
#
# Make sure that you declare the database column used for the serialized store as a text, so there's
# plenty of room.
#
# You can set custom coder to encode/decode your serialized attributes to/from different formats.
# JSON, YAML, Marshal are supported out of the box. Generally it can be any wrapper that provides +load+ and +dump+.
#
# NOTE: If you are using PostgreSQL specific columns like +hstore+ or +json+ there is no need for
# the serialization provided by {.store}[rdoc-ref:rdoc-ref:ClassMethods#store].
# Simply use {.store_accessor}[rdoc-ref:ClassMethods#store_accessor] instead to generate
# the accessor methods. Be aware that these columns use a string keyed hash and do not allow access
# using a symbol.
#
# NOTE: The default validations with the exception of +uniqueness+ will work.
# For example, if you want to check for +uniqueness+ with +hstore+ you will
# need to use a custom validation to handle it.
#
# Examples:
#
#   class User < ActiveRecord::Base
#     store :settings, accessors: [ :color, :homepage ], coder: JSON
#   end
#
#   u = User.new(color: 'black', homepage: '37signals.com')
#   u.color                          # Accessor stored attribute
#   u.settings[:country] = 'Denmark' # Any attribute, even if not specified with an accessor
#
#   # There is no difference between strings and symbols for accessing custom attributes
#   u.settings[:country]  # => 'Denmark'
#   u.settings['country'] # => 'Denmark'
#
#   # Add additional accessors to an existing store through store_accessor
#   class SuperUser < User
#     store_accessor :settings, :privileges, :servants
#   end
#
# The stored attribute names can be retrieved using {.stored_attributes}[rdoc-ref:rdoc-ref:ClassMethods#stored_attributes].
#
#   User.stored_attributes[:settings] # [:color, :homepage]
#
# == Overwriting default accessors
#
# All stored values are automatically available through accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling <tt>super</tt>
# to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses a stored integer to hold the volume adjustment of the song
#     store :settings, accessors: [:volume_adjustment]
#
#     def volume_adjustment=(decibels)
#       super(decibels.to_i)
#     end
#
#     def volume_adjustment
#       super.to_i
#     end
#   end
module ActiveRecord::Store
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Store::ClassMethods

  protected

  def read_store_attribute(store_attribute, key); end
  def write_store_attribute(store_attribute, key, value); end

  private

  def store_accessor_for(store_attribute); end
end

module ActiveRecord::Store::ClassMethods
  def _store_accessors_module; end
  def store(store_attribute, options = T.unsafe(nil)); end
  def store_accessor(store_attribute, *keys); end
  def stored_attributes; end
end

class ActiveRecord::Store::HashAccessor
  class << self
    def prepare(object, attribute); end
    def read(object, attribute, key); end
    def write(object, attribute, key, value); end
  end
end

class ActiveRecord::Store::IndifferentCoder
  # @return [IndifferentCoder] a new instance of IndifferentCoder
  def initialize(coder_or_class_name); end

  def dump(obj); end
  def load(yaml); end

  class << self
    def as_indifferent_hash(obj); end
  end
end

class ActiveRecord::Store::IndifferentHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    def prepare(object, store_attribute); end
  end
end

class ActiveRecord::Store::StringKeyedHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    def read(object, attribute, key); end
    def write(object, attribute, key, value); end
  end
end

# Raised when the single-table inheritance mechanism fails to locate the subclass
# (for example due to improper usage of column that
# {ActiveRecord::Base.inheritance_column}[rdoc-ref:ModelSchema::ClassMethods#inheritance_column]
# points to).
class ActiveRecord::SubclassNotFound < ::ActiveRecord::ActiveRecordError; end

# ActiveRecord::Suppressor prevents the receiver from being saved during
# a given block.
#
# For example, here's a pattern of creating notifications when new comments
# are posted. (The notification may in turn trigger an email, a push
# notification, or just appear in the UI somewhere):
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commentable, polymorphic: true
#     after_create -> { Notification.create! comment: self,
#       recipients: commentable.recipients }
#   end
#
# That's what you want the bulk of the time. New comment creates a new
# Notification. But there may well be off cases, like copying a commentable
# and its comments, where you don't want that. So you'd have a concern
# something like this:
#
#   module Copyable
#     def copy_to(destination)
#       Notification.suppress do
#         # Copy logic that creates new comments that we do not want
#         # triggering notifications.
#       end
#     end
#   end
module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Suppressor::ClassMethods

  def save(*_arg0); end
  def save!(*_arg0); end
end

module ActiveRecord::Suppressor::ClassMethods
  def suppress(&block); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry

  # @return [SuppressorRegistry] a new instance of SuppressorRegistry
  def initialize; end

  # Returns the value of attribute suppressed.
  def suppressed; end
end

class ActiveRecord::TableMetadata
  # @return [TableMetadata] a new instance of TableMetadata
  def initialize(klass, arel_table, association = T.unsafe(nil)); end

  def arel_attribute(column_name); end
  def associated_table(table_name); end

  # @return [Boolean]
  def associated_with?(association_name); end

  def association_foreign_key(*args, &block); end
  def association_foreign_type(*args, &block); end
  def association_primary_key(*args, &block); end

  # @return [Boolean]
  def polymorphic_association?; end

  def resolve_column_aliases(hash); end
  def type(column_name); end

  protected

  # Returns the value of attribute arel_table.
  def arel_table; end

  # Returns the value of attribute association.
  def association; end

  # Returns the value of attribute klass.
  def klass; end
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Tasks::DatabaseAlreadyExists < ::StandardError; end
class ActiveRecord::Tasks::DatabaseNotSupported < ::StandardError; end

# ActiveRecord::Tasks::DatabaseTasks is a utility class, which encapsulates
# logic behind common tasks used to manage database and migrations.
#
# The tasks defined here are used with Rake tasks provided by Active Record.
#
# In order to use DatabaseTasks, a few config values need to be set. All the needed
# config values are set by Rails already, so it's necessary to do it only if you
# want to change the defaults or when you want to use Active Record outside of Rails
# (in such case after configuring the database tasks, you can also use the rake tasks
# defined in Active Record).
#
# The possible config values are:
#
# * +env+: current environment (like Rails.env).
# * +database_configuration+: configuration of your databases (as in +config/database.yml+).
# * +db_dir+: your +db+ directory.
# * +fixtures_path+: a path to fixtures directory.
# * +migrations_paths+: a list of paths to directories with migrations.
# * +seed_loader+: an object which will load seeds, it needs to respond to the +load_seed+ method.
# * +root+: a path to the root of the application.
#
# Example usage of DatabaseTasks outside Rails could look as such:
#
#   include ActiveRecord::Tasks
#   DatabaseTasks.database_configuration = YAML.load_file('my_database_config.yml')
#   DatabaseTasks.db_dir = 'db'
#   # other settings...
#
#   DatabaseTasks.create_current('production')
module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks

  def charset(*arguments); end
  def charset_current(environment = T.unsafe(nil)); end
  def check_protected_environments!; end
  def check_schema_file(filename); end
  def collation(*arguments); end
  def collation_current(environment = T.unsafe(nil)); end
  def create(*arguments); end
  def create_all; end
  def create_current(environment = T.unsafe(nil)); end
  def current_config(options = T.unsafe(nil)); end

  # Sets the attribute current_config
  #
  # @param value the value to set the attribute current_config to.
  def current_config=(_arg0); end

  # Returns the value of attribute database_configuration.
  def database_configuration; end

  # Sets the attribute database_configuration
  #
  # @param value the value to set the attribute database_configuration to.
  def database_configuration=(_arg0); end

  def db_dir; end

  # Sets the attribute db_dir
  #
  # @param value the value to set the attribute db_dir to.
  def db_dir=(_arg0); end

  def drop(*arguments); end
  def drop_all; end
  def drop_current(environment = T.unsafe(nil)); end
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  def env=(_arg0); end

  def fixtures_path; end

  # Sets the attribute fixtures_path
  #
  # @param value the value to set the attribute fixtures_path to.
  def fixtures_path=(_arg0); end

  def load_schema(configuration, format = T.unsafe(nil), file = T.unsafe(nil), environment = T.unsafe(nil)); end
  def load_schema_current(format = T.unsafe(nil), file = T.unsafe(nil), environment = T.unsafe(nil)); end
  def load_schema_for(*args); end
  def load_seed; end
  def migrate; end
  def migrations_paths; end

  # Sets the attribute migrations_paths
  #
  # @param value the value to set the attribute migrations_paths to.
  def migrations_paths=(_arg0); end

  def purge(configuration); end
  def purge_all; end
  def purge_current(environment = T.unsafe(nil)); end
  def register_task(pattern, task); end
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  def root=(_arg0); end

  def schema_file(format = T.unsafe(nil)); end
  def seed_loader; end

  # Sets the attribute seed_loader
  #
  # @param value the value to set the attribute seed_loader to.
  def seed_loader=(_arg0); end

  def structure_dump(*arguments); end
  def structure_load(*arguments); end

  private

  def class_for_adapter(adapter); end
  def each_current_configuration(environment); end
  def each_local_configuration; end

  # @return [Boolean]
  def local_database?(configuration); end
end

ActiveRecord::Tasks::DatabaseTasks::LOCAL_HOSTS = T.let(T.unsafe(nil), Array)

class ActiveRecord::Tasks::MySQLDatabaseTasks
  # @return [MySQLDatabaseTasks] a new instance of MySQLDatabaseTasks
  def initialize(configuration); end

  def charset; end
  def collation; end
  def connection(*args, &block); end
  def create; end
  def drop; end
  def establish_connection(*args, &block); end
  def purge; end
  def structure_dump(filename); end
  def structure_load(filename); end

  private

  def configuration; end
  def configuration_without_database; end
  def creation_options; end
  def error_class; end
  def grant_statement; end
  def prepare_command_options; end
  def root_configuration_without_database; end
  def root_password; end
  def run_cmd(cmd, args, action); end
  def run_cmd_error(cmd, args, action); end
end

ActiveRecord::Tasks::MySQLDatabaseTasks::ACCESS_DENIED_ERROR = T.let(T.unsafe(nil), Integer)

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  # @return [PostgreSQLDatabaseTasks] a new instance of PostgreSQLDatabaseTasks
  def initialize(configuration); end

  def charset; end
  def clear_active_connections!(*args, &block); end
  def collation; end
  def connection(*args, &block); end
  def create(master_established = T.unsafe(nil)); end
  def drop; end
  def establish_connection(*args, &block); end
  def purge; end
  def structure_dump(filename); end
  def structure_load(filename); end

  private

  def configuration; end
  def encoding; end
  def establish_master_connection; end
  def run_cmd(cmd, args, action); end
  def run_cmd_error(cmd, args, action); end
  def set_psql_env; end
end

ActiveRecord::Tasks::PostgreSQLDatabaseTasks::DEFAULT_ENCODING = T.let(T.unsafe(nil), String)

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  # @return [SQLiteDatabaseTasks] a new instance of SQLiteDatabaseTasks
  def initialize(configuration, root = T.unsafe(nil)); end

  def charset; end
  def connection(*args, &block); end

  # @raise [DatabaseAlreadyExists]
  def create; end

  def drop; end
  def establish_connection(*args, &block); end
  def purge; end
  def structure_dump(filename); end
  def structure_load(filename); end

  private

  def configuration; end
  def root; end
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods

  def after_teardown; end
  def before_setup; end
  def enlist_fixture_connections; end

  # @return [Boolean]
  def run_in_transaction?; end

  def setup_fixtures(config = T.unsafe(nil)); end
  def teardown_fixtures; end

  private

  def instantiate_fixtures; end
  def load_fixtures(config); end

  # @return [Boolean]
  def load_instances?; end

  module GeneratedClassMethods
    def config; end
    def config=(value); end
    def config?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path=(value); end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_fixtures; end
    def use_transactional_fixtures=(value); end
    def use_transactional_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def config; end
    def config=(value); end
    def config?; end
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_path; end
    def fixture_path?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_fixtures; end
    def use_transactional_fixtures=(value); end
    def use_transactional_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
  #
  # Examples:
  #
  #   set_fixture_class some_fixture:        SomeModel,
  #                     'namespaced/fixture' => Another::Model
  #
  # The keys must be the fixture names, that coincide with the short paths to the fixture files.
  def set_fixture_class(class_names = T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names = T.unsafe(nil)); end
  def uses_transaction(*methods); end

  # @return [Boolean]
  def uses_transaction?(method); end
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ActiveRecordError
  # @return [ThroughCantAssociateThroughHasOneOrManyReflection] a new instance of ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly < ::ActiveRecord::ActiveRecordError
  # @return [ThroughNestedAssociationsAreReadonly] a new instance of ThroughNestedAssociationsAreReadonly
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# = Active Record \Timestamp
#
# Active Record automatically timestamps create and update operations if the
# table has fields named <tt>created_at/created_on</tt> or
# <tt>updated_at/updated_on</tt>.
#
# Timestamping can be turned off by setting:
#
#   config.active_record.record_timestamps = false
#
# Timestamps are in UTC by default but you can use the local timezone by setting:
#
#   config.active_record.default_timezone = :local
#
# == Time Zone aware attributes
#
# Active Record keeps all the <tt>datetime</tt> and <tt>time</tt> columns
# timezone aware. By default, these values are stored in the database as UTC
# and converted back to the current <tt>Time.zone</tt> when pulled from the database.
#
# This feature can be turned off completely by setting:
#
#   config.active_record.time_zone_aware_attributes = false
#
# You can also specify that only <tt>datetime</tt> columns should be time-zone
# aware (while <tt>time</tt> should not) by setting:
#
#   ActiveRecord::Base.time_zone_aware_types = [:datetime]
#
# You can also add database specific timezone aware types. For example, for PostgreSQL:
#
#   ActiveRecord::Base.time_zone_aware_types += [:tsrange, :tstzrange]
#
# Finally, you can indicate specific attributes of a model for which time zone
# conversion should not applied, for instance by setting:
#
#   class Topic < ActiveRecord::Base
#     self.skip_time_zone_conversion_for_attributes = [:written_on]
#   end
module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  private

  def _create_record; end
  def _update_record(*args, touch: T.unsafe(nil), **options); end
  def all_timestamp_attributes; end
  def all_timestamp_attributes_in_model; end

  # Clear attributes and changed_attributes
  def clear_timestamp_attributes; end

  def current_time_from_proper_timezone; end
  def initialize_dup(other); end
  def max_updated_column_timestamp(timestamp_names = T.unsafe(nil)); end

  # @return [Boolean]
  def should_record_timestamps?; end

  def timestamp_attributes_for_create; end
  def timestamp_attributes_for_create_in_model; end
  def timestamp_attributes_for_update; end
  def timestamp_attributes_for_update_in_model; end

  module GeneratedClassMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end

  module GeneratedInstanceMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end
end

# = Active Record Touch Later
module ActiveRecord::TouchLater
  extend ::ActiveSupport::Concern

  def touch(*names, time: T.unsafe(nil)); end
  def touch_later(*names); end

  private

  def belongs_to_touch_method; end

  # @return [Boolean]
  def has_defer_touch_attrs?; end

  def surreptitiously_touch(attrs); end
  def touch_deferred_attributes; end
end

# TransactionIsolationError will be raised under the following conditions:
#
# * The adapter does not support setting the isolation level
# * You are joining an existing open transaction
# * You are creating a nested (savepoint) transaction
#
# The mysql2 and postgresql adapters support setting the transaction isolation level.
class ActiveRecord::TransactionIsolationError < ::ActiveRecord::ActiveRecordError; end

# See ActiveRecord::Transactions::ClassMethods for documentation.
module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Transactions::ClassMethods

  # Add the record to the current transaction so that the #after_rollback and #after_commit callbacks
  # can be called.
  def add_to_transaction; end

  def before_committed!; end

  # Call the #after_commit callbacks.
  #
  # Ensure that it is not called if the object was never persisted (failed create),
  # but call it after the commit of a destroyed object.
  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy; end

  # Reset id and @new_record if the transaction rolls back.
  def rollback_active_record_state!; end

  # Call the #after_rollback callbacks. The +force_restore_state+ argument indicates if the record
  # state should be rolled back to the beginning or just to the last savepoint.
  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_arg0); end
  def save!(*_arg0); end
  def touch(*_arg0); end

  # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
  def transaction(options = T.unsafe(nil), &block); end

  # Executes +method+ within a transaction and captures its return value as a
  # status flag. If the status is true the transaction is committed, otherwise
  # a ROLLBACK is issued. In any case the status flag is returned.
  #
  # This method is available within the context of an ActiveRecord::Base
  # instance.
  def with_transaction_returning_status; end

  protected

  # Clear the new record state and id of a record.
  def clear_transaction_record_state; end

  # Force to clear the transaction record state.
  def force_clear_transaction_record_state; end

  # Save the new record state and id of a record so it can be restored later if a transaction fails.
  def remember_transaction_record_state; end

  # Restore the new record state and id of a record that was previously saved by a call to save_record_state.
  def restore_transaction_record_state(force = T.unsafe(nil)); end

  # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
  #
  # @return [Boolean]
  def transaction_include_any_action?(actions); end

  # Determine if a record was created or destroyed in a transaction. State should be one of :new_record or :destroyed.
  def transaction_record_state(state); end

  private

  # @return [Boolean]
  def has_transactional_callbacks?; end

  def set_transaction_state(state); end

  # Updates the attributes on this particular Active Record object so that
  # if it's associated with a transaction, then the state of the Active Record
  # object will be updated to reflect the current state of the transaction
  #
  # The +@transaction_state+ variable stores the states of the associated
  # transaction. This relies on the fact that a transaction can only be in
  # one rollback or commit (otherwise a list of states would be required)
  # Each Active Record object inside of a transaction carries that transaction's
  # TransactionState.
  #
  # This method checks to see if the ActiveRecord object's state reflects
  # the TransactionState, and rolls back or commits the Active Record object
  # as appropriate.
  #
  # Since Active Record objects can be inside multiple transactions, this
  # method recursively goes through the parent of the TransactionState and
  # checks if the Active Record object reflects the state of the object.
  def sync_with_transaction_state; end

  def update_attributes_from_transaction_state(transaction_state); end
end

ActiveRecord::Transactions::ACTIONS = T.let(T.unsafe(nil), Array)

# = Active Record Transactions
#
# \Transactions are protective blocks where SQL statements are only permanent
# if they can all succeed as one atomic action. The classic example is a
# transfer between two accounts where you can only have a deposit if the
# withdrawal succeeded and vice versa. \Transactions enforce the integrity of
# the database and guard the data against program errors or database
# break-downs. So basically you should use transaction blocks whenever you
# have a number of statements that must be executed together or not at all.
#
# For example:
#
#   ActiveRecord::Base.transaction do
#     david.withdrawal(100)
#     mary.deposit(100)
#   end
#
# This example will only take money from David and give it to Mary if neither
# +withdrawal+ nor +deposit+ raise an exception. Exceptions will force a
# ROLLBACK that returns the database to the state before the transaction
# began. Be aware, though, that the objects will _not_ have their instance
# data returned to their pre-transactional state.
#
# == Different Active Record classes in a single transaction
#
# Though the #transaction class method is called on some Active Record class,
# the objects within the transaction block need not all be instances of
# that class. This is because transactions are per-database connection, not
# per-model.
#
# In this example a +balance+ record is transactionally saved even
# though #transaction is called on the +Account+ class:
#
#   Account.transaction do
#     balance.save!
#     account.save!
#   end
#
# The #transaction method is also available as a model instance method.
# For example, you can also do this:
#
#   balance.transaction do
#     balance.save!
#     account.save!
#   end
#
# == Transactions are not distributed across database connections
#
# A transaction acts on a single database connection. If you have
# multiple class-specific databases, the transaction will not protect
# interaction among them. One workaround is to begin a transaction
# on each class whose models you alter:
#
#   Student.transaction do
#     Course.transaction do
#       course.enroll(student)
#       student.units += course.units
#     end
#   end
#
# This is a poor solution, but fully distributed transactions are beyond
# the scope of Active Record.
#
# == +save+ and +destroy+ are automatically wrapped in a transaction
#
# Both {#save}[rdoc-ref:Persistence#save] and
# {#destroy}[rdoc-ref:Persistence#destroy] come wrapped in a transaction that ensures
# that whatever you do in validations or callbacks will happen under its
# protected cover. So you can use validations to check for values that
# the transaction depends on or you can raise exceptions in the callbacks
# to rollback, including <tt>after_*</tt> callbacks.
#
# As a consequence changes to the database are not seen outside your connection
# until the operation is complete. For example, if you try to update the index
# of a search engine in +after_save+ the indexer won't see the updated record.
# The #after_commit callback is the only one that is triggered once the update
# is committed. See below.
#
# == Exception handling and rolling back
#
# Also have in mind that exceptions thrown within a transaction block will
# be propagated (after triggering the ROLLBACK), so you should be ready to
# catch those in your application code.
#
# One exception is the ActiveRecord::Rollback exception, which will trigger
# a ROLLBACK when raised, but not be re-raised by the transaction block.
#
# *Warning*: one should not catch ActiveRecord::StatementInvalid exceptions
# inside a transaction block. ActiveRecord::StatementInvalid exceptions indicate that an
# error occurred at the database level, for example when a unique constraint
# is violated. On some database systems, such as PostgreSQL, database errors
# inside a transaction cause the entire transaction to become unusable
# until it's restarted from the beginning. Here is an example which
# demonstrates the problem:
#
#   # Suppose that we have a Number model with a unique column called 'i'.
#   Number.transaction do
#     Number.create(i: 0)
#     begin
#       # This will raise a unique constraint error...
#       Number.create(i: 0)
#     rescue ActiveRecord::StatementInvalid
#       # ...which we ignore.
#     end
#
#     # On PostgreSQL, the transaction is now unusable. The following
#     # statement will cause a PostgreSQL error, even though the unique
#     # constraint is no longer violated:
#     Number.create(i: 1)
#     # => "PG::Error: ERROR:  current transaction is aborted, commands
#     #     ignored until end of transaction block"
#   end
#
# One should restart the entire transaction if an
# ActiveRecord::StatementInvalid occurred.
#
# == Nested transactions
#
# #transaction calls can be nested. By default, this makes all database
# statements in the nested transaction block become part of the parent
# transaction. For example, the following behavior may be surprising:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# creates both "Kotori" and "Nemu". Reason is the ActiveRecord::Rollback
# exception in the nested block does not issue a ROLLBACK. Since these exceptions
# are captured in transaction blocks, the parent block does not see it and the
# real transaction is committed.
#
# In order to get a ROLLBACK for the nested transaction you may ask for a real
# sub-transaction by passing <tt>requires_new: true</tt>. If anything goes wrong,
# the database rolls back to the beginning of the sub-transaction without rolling
# back the parent transaction. If we add it to the previous example:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction(requires_new: true) do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# only "Kotori" is created. This works on MySQL and PostgreSQL. SQLite3 version >= '3.6.8' also supports it.
#
# Most databases don't support true nested transactions. At the time of
# writing, the only database that we're aware of that supports true nested
# transactions, is MS-SQL. Because of this, Active Record emulates nested
# transactions by using savepoints on MySQL and PostgreSQL. See
# http://dev.mysql.com/doc/refman/5.7/en/savepoint.html
# for more information about savepoints.
#
# === \Callbacks
#
# There are two types of callbacks associated with committing and rolling back transactions:
# #after_commit and #after_rollback.
#
# #after_commit callbacks are called on every record saved or destroyed within a
# transaction immediately after the transaction is committed. #after_rollback callbacks
# are called on every record saved or destroyed within a transaction immediately after the
# transaction or savepoint is rolled back.
#
# These callbacks are useful for interacting with other systems since you will be guaranteed
# that the callback is only executed when the database is in a permanent state. For example,
# #after_commit is a good spot to put in a hook to clearing a cache since clearing it from
# within a transaction could trigger the cache to be regenerated before the database is updated.
#
# === Caveats
#
# If you're on MySQL, then do not use DDL operations in nested transactions
# blocks that are emulated with savepoints. That is, do not execute statements
# like 'CREATE TABLE' inside such blocks. This is because MySQL automatically
# releases all savepoints upon executing a DDL operation. When +transaction+
# is finished and tries to release the savepoint it created earlier, a
# database error will occur because the savepoint has already been
# automatically released. The following example demonstrates the problem:
#
#   Model.connection.transaction do                           # BEGIN
#     Model.connection.transaction(requires_new: true) do     # CREATE SAVEPOINT active_record_1
#       Model.connection.create_table(...)                    # active_record_1 now automatically released
#     end                                                     # RELEASE SAVEPOINT active_record_1
#                                                             # ^^^^ BOOM! database error!
#   end
#
# Note that "TRUNCATE" is also a MySQL DDL statement!
module ActiveRecord::Transactions::ClassMethods
  # This callback is called after a record has been created, updated, or destroyed.
  #
  # You can specify that the callback should only be fired by a certain action with
  # the +:on+ option:
  #
  #   after_commit :do_foo, on: :create
  #   after_commit :do_bar, on: :update
  #   after_commit :do_baz, on: :destroy
  #
  #   after_commit :do_foo_bar, on: [:create, :update]
  #   after_commit :do_bar_baz, on: [:update, :destroy]
  def after_commit(*args, &block); end

  def after_commit_without_transaction_enrollment(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :create</tt>.
  def after_create_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :destroy</tt>.
  def after_destroy_commit(*args, &block); end

  # This callback is called after a create, update, or destroy are rolled back.
  #
  # Please check the documentation of #after_commit for options.
  def after_rollback(*args, &block); end

  def after_rollback_without_transaction_enrollment(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :update</tt>.
  def after_update_commit(*args, &block); end

  def before_commit(*args, &block); end
  def before_commit_without_transaction_enrollment(*args, &block); end
  def raise_in_transactional_callbacks; end
  def raise_in_transactional_callbacks=(value); end

  # See the ConnectionAdapters::DatabaseStatements#transaction API docs.
  def transaction(options = T.unsafe(nil), &block); end

  private

  def assert_valid_transaction_action(actions); end
  def set_options_for_callbacks!(args, enforced_options = T.unsafe(nil)); end
end

module ActiveRecord::Translation
  include ::ActiveModel::Naming
  include ::ActiveModel::Translation

  # Set the i18n scope to overwrite ActiveModel.
  def i18n_scope; end

  # Set the lookup ancestors for ActiveModel.
  def lookup_ancestors; end
end

# :stopdoc:
module ActiveRecord::Type
  class << self
    def add_modifier(*args, &block); end
    def lookup(*args, adapter: T.unsafe(nil), **kwargs); end

    # Add a new type to the registry, allowing it to be referenced as a
    # symbol by {ActiveRecord::Base.attribute}[rdoc-ref:Attributes::ClassMethods#attribute].
    # If your type is only meant to be used with a specific database adapter, you can
    # do so by passing <tt>adapter: :postgresql</tt>. If your type has the same
    # name as a native type for the current adapter, an exception will be
    # raised unless you specify an +:override+ option. <tt>override: true</tt> will
    # cause your type to be used instead of the native type. <tt>override:
    # false</tt> will cause the native type to be used over yours if one exists.
    def register(type_name, klass = T.unsafe(nil), **options, &block); end

    def registry; end
    def registry=(_arg0); end

    private

    def current_adapter_name; end
  end
end

class ActiveRecord::Type::AdapterSpecificRegistry < ::ActiveModel::Type::Registry
  def add_modifier(options, klass, **args); end

  private

  def find_registration(symbol, *args); end
  def registration_klass; end
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger
ActiveRecord::Type::Binary = ActiveModel::Type::Binary
ActiveRecord::Type::Boolean = ActiveModel::Type::Boolean

class ActiveRecord::Type::Date < ::ActiveModel::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime < ::ActiveModel::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal
ActiveRecord::Type::DecimalWithoutScale = ActiveModel::Type::DecimalWithoutScale

class ActiveRecord::Type::DecorationRegistration < ::ActiveRecord::Type::Registration
  # @return [DecorationRegistration] a new instance of DecorationRegistration
  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def call(registry, *args, **kwargs); end

  # @return [Boolean]
  def matches?(*args, **kwargs); end

  def priority; end

  protected

  # Returns the value of attribute klass.
  def klass; end

  # Returns the value of attribute options.
  def options; end

  private

  # @return [Boolean]
  def matches_options?(**kwargs); end
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap < ::ActiveRecord::Type::TypeMap
  def alias_type(type, alias_type); end

  # @return [Boolean]
  def key?(key); end

  def keys; end

  private

  def perform_fetch(type, *args, &block); end
end

ActiveRecord::Type::Helpers = ActiveModel::Type::Helpers
ActiveRecord::Type::Integer = ActiveModel::Type::Integer
module ActiveRecord::Type::Internal; end

class ActiveRecord::Type::Internal::AbstractJson < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  def accessor; end
  def deserialize(value); end
  def serialize(value); end
  def type; end
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone; end

  # @return [Boolean]
  def is_utc?; end
end

class ActiveRecord::Type::Registration
  # @return [Registration] a new instance of Registration
  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def <=>(other); end
  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  # @return [Boolean]
  def matches?(type_name, *args, **kwargs); end

  protected

  # Returns the value of attribute adapter.
  def adapter; end

  # Returns the value of attribute block.
  def block; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute override.
  def override; end

  def priority; end
  def priority_except_adapter; end

  private

  # @return [Boolean]
  def conflicts_with?(other); end

  # @return [Boolean]
  def has_adapter_conflict?(other); end

  # @return [Boolean]
  def matches_adapter?(adapter: T.unsafe(nil), **_arg1); end

  # @return [Boolean]
  def same_priority_except_adapter?(other); end
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable

  # @return [Serialized] a new instance of Serialized
  def initialize(subtype, coder); end

  def accessor; end
  def assert_valid_value(value); end

  # @return [Boolean]
  def changed_in_place?(raw_old_value, value); end

  # Returns the value of attribute coder.
  def coder; end

  def deserialize(value); end
  def inspect; end
  def serialize(value); end

  # Returns the value of attribute subtype.
  def subtype; end

  private

  # @return [Boolean]
  def default_value?(value); end

  def encoded(value); end
end

ActiveRecord::Type::String = ActiveModel::Type::String
ActiveRecord::Type::Text = ActiveModel::Type::Text

class ActiveRecord::Type::Time < ::ActiveModel::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone

  def serialize(value); end
end

class ActiveRecord::Type::Time::Value; end

class ActiveRecord::Type::TypeMap
  # @return [TypeMap] a new instance of TypeMap
  def initialize; end

  def alias_type(key, target_key); end
  def clear; end
  def fetch(lookup_key, *args, &block); end
  def lookup(lookup_key, *args); end

  # @raise [::ArgumentError]
  def register_type(key, value = T.unsafe(nil), &block); end

  private

  def default_value; end
  def perform_fetch(lookup_key, *args); end
end

ActiveRecord::Type::UnsignedInteger = ActiveModel::Type::UnsignedInteger
ActiveRecord::Type::Value = ActiveModel::Type::Value
module ActiveRecord::TypeCaster; end

class ActiveRecord::TypeCaster::Connection
  # @return [Connection] a new instance of Connection
  def initialize(klass, table_name); end

  def connection(*args, &block); end
  def type_cast_for_database(attribute_name, value); end

  protected

  # Returns the value of attribute table_name.
  def table_name; end

  private

  def column_for(attribute_name); end
end

class ActiveRecord::TypeCaster::Map
  # @return [Map] a new instance of Map
  def initialize(types); end

  def type_cast_for_database(attr_name, value); end

  protected

  # Returns the value of attribute types.
  def types; end
end

class ActiveRecord::TypeConflictError < ::StandardError; end

# Raised when unknown attributes are supplied via mass assignment.
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

class ActiveRecord::UnknownMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [UnknownMigrationVersionError] a new instance of UnknownMigrationVersionError
  def initialize(version = T.unsafe(nil)); end
end

# Raised when a primary key is needed, but not specified in the schema or model.
class ActiveRecord::UnknownPrimaryKey < ::ActiveRecord::ActiveRecordError
  # @return [UnknownPrimaryKey] a new instance of UnknownPrimaryKey
  def initialize(model = T.unsafe(nil), description = T.unsafe(nil)); end

  # Returns the value of attribute model.
  def model; end
end

module ActiveRecord::VERSION; end
ActiveRecord::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActiveRecord::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActiveRecord::VERSION::PRE = T.let(T.unsafe(nil), String)
ActiveRecord::VERSION::STRING = T.let(T.unsafe(nil), String)
ActiveRecord::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# = Active Record \Validations
#
# Active Record includes the majority of its validations from ActiveModel::Validations
# all of which accept the <tt>:on</tt> argument to define the context where the
# validations are active. Active Record will always supply either the context of
# <tt>:create</tt> or <tt>:update</tt> dependent on whether the model is a
# {new_record?}[rdoc-ref:Persistence#new_record?].
module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveRecord::Validations::ClassMethods

  # The validation process on save can be skipped by passing <tt>validate: false</tt>.
  # The regular {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] method is replaced
  # with this when the validations module is mixed in, which it is by default.
  def save(options = T.unsafe(nil)); end

  # Attempts to save the record just like {ActiveRecord::Base#save}[rdoc-ref:Base#save] but
  # will raise an ActiveRecord::RecordInvalid exception instead of returning +false+ if the record is not valid.
  def save!(options = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  def valid?(context = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  def validate(context = T.unsafe(nil)); end

  protected

  def default_validation_context; end
  def perform_validations(options = T.unsafe(nil)); end

  # @raise [RecordInvalid]
  def raise_validation_error; end

  module GeneratedClassMethods
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validate_callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def _validate_callbacks; end
    def _validate_callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

class ActiveRecord::Validations::AbsenceValidator < ::ActiveModel::Validations::AbsenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::AssociatedValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  def valid_object?(record); end
end

module ActiveRecord::Validations::ClassMethods
  # Validates that the specified attributes are not present (as defined by
  # Object#present?). If the attribute is an association, the associated object
  # is considered absent if it was marked for destruction.
  #
  # See ActiveModel::Validations::HelperMethods.validates_absence_of for more information.
  def validates_absence_of(*attr_names); end

  # Validates whether the associated object or objects are all valid.
  # Works with any kind of association.
  #
  #   class Book < ActiveRecord::Base
  #     has_many :pages
  #     belongs_to :library
  #
  #     validates_associated :pages, :library
  #   end
  #
  # WARNING: This validation must not be used on both ends of an association.
  # Doing so will lead to a circular dependency and cause infinite recursion.
  #
  # NOTE: This validation will not fail if the association hasn't been
  # assigned. If you want to ensure that the association is both present and
  # guaranteed to be valid, you also need to use
  # {validates_presence_of}[rdoc-ref:Validations::ClassMethods#validates_presence_of].
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - A custom error message (default is: "is invalid").
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default (nil). You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  def validates_associated(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  def validates_length_of(*attr_names); end

  # Validates that the specified attributes are not blank (as defined by
  # Object#blank?), and, if the attribute is an association, that the
  # associated object is not marked for destruction. Happens by default
  # on save.
  #
  #   class Person < ActiveRecord::Base
  #     has_one :face
  #     validates_presence_of :face
  #   end
  #
  # The face attribute must be in the object and it cannot be blank or marked
  # for destruction.
  #
  # If you want to validate the presence of a boolean field (where the real values
  # are true and false), you will want to use
  # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
  #
  # This is due to the way Object#blank? handles boolean values:
  # <tt>false.blank? # => true</tt>.
  #
  # This validator defers to the Active Model validation for presence, adding the
  # check to see that an associated object is not marked for destruction. This
  # prevents the parent object from validating successfully and saving, which then
  # deletes the associated object, thus putting the parent object into an invalid
  # state.
  #
  # NOTE: This validation will not fail while using it with an association
  # if the latter was assigned but not valid. If you want to ensure that
  # it is both present and valid, you also need to use
  # {validates_associated}[rdoc-ref:Validations::ClassMethods#validates_associated].
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default (nil). You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine if
  #   the validation should occur (e.g. <tt>if: :allow_validation</tt>, or
  #   <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc
  #   or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:strict</tt> - Specifies whether validation should be strict.
  #   See ActiveModel::Validation#validates! for more information.
  def validates_presence_of(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  def validates_size_of(*attr_names); end

  # Validates whether the value of the specified attributes are unique
  # across the system. Useful for making sure that only one user
  # can be named "davidhh".
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name
  #   end
  #
  # It can also validate whether the value of the specified attributes are
  # unique based on a <tt>:scope</tt> parameter:
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name, scope: :account_id
  #   end
  #
  # Or even multiple scope parameters. For example, making sure that a
  # teacher can only be on the schedule once per semester for a particular
  # class.
  #
  #   class TeacherSchedule < ActiveRecord::Base
  #     validates_uniqueness_of :teacher_id, scope: [:semester_id, :class_id]
  #   end
  #
  # It is also possible to limit the uniqueness constraint to a set of
  # records matching certain conditions. In this example archived articles
  # are not being taken into consideration when validating uniqueness
  # of the title attribute:
  #
  #   class Article < ActiveRecord::Base
  #     validates_uniqueness_of :title, conditions: -> { where.not(status: 'archived') }
  #   end
  #
  # When the record is created, a check is performed to make sure that no
  # record exists in the database with the given value for the specified
  # attribute (that maps to a column). When the record is updated,
  # the same check is made but disregarding the record itself.
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - Specifies a custom error message (default is:
  #   "has already been taken").
  # * <tt>:scope</tt> - One or more columns by which to limit the scope of
  #   the uniqueness constraint.
  # * <tt>:conditions</tt> - Specify the conditions to be included as a
  #   <tt>WHERE</tt> SQL fragment to limit the uniqueness constraint lookup
  #   (e.g. <tt>conditions: -> { where(status: 'active') }</tt>).
  # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
  #   non-text columns (+true+ by default).
  # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
  #   attribute is +nil+ (default is +false+).
  # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
  #   attribute is blank (default is +false+).
  # * <tt>:if</tt> - Specifies a method, proc or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # === Concurrency and integrity
  #
  # Using this validation method in conjunction with
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save]
  # does not guarantee the absence of duplicate record insertions, because
  # uniqueness checks on the application level are inherently prone to race
  # conditions. For example, suppose that two users try to post a Comment at
  # the same time, and a Comment's title must be unique. At the database-level,
  # the actions performed by these users could be interleaved in the following manner:
  #
  #               User 1                 |               User 2
  #  ------------------------------------+--------------------------------------
  #  # User 1 checks whether there's     |
  #  # already a comment with the title  |
  #  # 'My Post'. This is not the case.  |
  #  SELECT * FROM comments              |
  #  WHERE title = 'My Post'             |
  #                                      |
  #                                      | # User 2 does the same thing and also
  #                                      | # infers that their title is unique.
  #                                      | SELECT * FROM comments
  #                                      | WHERE title = 'My Post'
  #                                      |
  #  # User 1 inserts their comment.     |
  #  INSERT INTO comments                |
  #  (title, content) VALUES             |
  #  ('My Post', 'hi!')                  |
  #                                      |
  #                                      | # User 2 does the same thing.
  #                                      | INSERT INTO comments
  #                                      | (title, content) VALUES
  #                                      | ('My Post', 'hello!')
  #                                      |
  #                                      | # ^^^^^^
  #                                      | # Boom! We now have a duplicate
  #                                      | # title!
  #
  # This could even happen if you use transactions with the 'serializable'
  # isolation level. The best way to work around this problem is to add a unique
  # index to the database table using
  # {connection.add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # In the rare case that a race condition occurs, the database will guarantee
  # the field's uniqueness.
  #
  # When the database catches such a duplicate insertion,
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will raise an ActiveRecord::StatementInvalid
  # exception. You can either choose to let this error propagate (which
  # will result in the default Rails exception page being shown), or you
  # can catch it and restart the transaction (e.g. by telling the user
  # that the title already exists, and asking them to re-enter the title).
  # This technique is also known as
  # {optimistic concurrency control}[http://en.wikipedia.org/wiki/Optimistic_concurrency_control].
  #
  # The bundled ActiveRecord::ConnectionAdapters distinguish unique index
  # constraint errors from other types of database errors by throwing an
  # ActiveRecord::RecordNotUnique exception. For other adapters you will
  # have to parse the (database-specific) exception message to detect such
  # a case.
  #
  # The following bundled adapters throw the ActiveRecord::RecordNotUnique exception:
  #
  # * ActiveRecord::ConnectionAdapters::Mysql2Adapter.
  # * ActiveRecord::ConnectionAdapters::SQLite3Adapter.
  # * ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.
  def validates_uniqueness_of(*attr_names); end
end

class ActiveRecord::Validations::LengthValidator < ::ActiveModel::Validations::LengthValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::PresenceValidator < ::ActiveModel::Validations::PresenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::UniquenessValidator < ::ActiveModel::EachValidator
  # @return [UniquenessValidator] a new instance of UniquenessValidator
  def initialize(options); end

  def validate_each(record, attribute, value); end

  protected

  def build_relation(klass, table, attribute, value); end

  # The check for an existing value should be run from a class that
  # isn't abstract. This means working down from the current class
  # (self), to the first non-abstract class. Since classes don't know
  # their subclasses, we have to build the hierarchy between self and
  # the record's class.
  def find_finder_class_for(record); end

  def map_enum_attribute(klass, attribute, value); end
  def scope_relation(record, table, relation); end
end

# Raised when a record cannot be inserted or updated because a value too long for a column type.
class ActiveRecord::ValueTooLong < ::ActiveRecord::StatementInvalid; end

# Defunct wrapper class kept for compatibility.
# StatementInvalid wraps the original exception now.
class ActiveRecord::WrappedDatabaseException < ::ActiveRecord::StatementInvalid; end
