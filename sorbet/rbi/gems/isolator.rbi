# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/isolator/all/isolator.rbi
#
# isolator-0.8.0

module Isolator
  def self.adapters; end
  def self.backtrace_cleaner; end
  def self.backtrace_cleaner=(arg0); end
  def self.backtrace_length; end
  def self.backtrace_length=(arg0); end
  def self.clear_transactions!; end
  def self.colorize_debug(msg); end
  def self.config; end
  def self.configure; end
  def self.connection_threshold(connection_id); end
  def self.current_transactions(connection_id = nil); end
  def self.debug!(msg); end
  def self.debug_enabled; end
  def self.debug_enabled=(arg0); end
  def self.decr_thresholds!; end
  def self.decr_transactions!(connection_id = nil); end
  def self.default_connection_id; end
  def self.default_connection_id=(arg0); end
  def self.default_threshold; end
  def self.default_threshold=(arg0); end
  def self.disable!; end
  def self.disable; end
  def self.disabled?; end
  def self.enable!; end
  def self.enable; end
  def self.enabled?; end
  def self.extract_source_location(locations); end
  def self.incr_thresholds!; end
  def self.incr_transactions!(connection_id = nil); end
  def self.load_ignore_config(path); end
  def self.notify(exception:, backtrace:); end
  def self.set_connection_threshold(val, connection_id = nil); end
  def self.state; end
  def self.state=(arg0); end
  def self.transactions_threshold(connection_id = nil); end
  def self.transactions_threshold=(val); end
  def self.within_transaction?; end
end
class Isolator::Configuration
  def backtrace_filter; end
  def backtrace_filter=(arg0); end
  def ignorer; end
  def ignorer=(arg0); end
  def initialize; end
  def logger; end
  def logger=(arg0); end
  def raise_exceptions; end
  def raise_exceptions=(arg0); end
  def raise_exceptions?; end
  def send_notifications; end
  def send_notifications=(arg0); end
  def send_notifications?; end
  def test_env?; end
end
module Isolator::Adapters
end
module Isolator::Adapters::Base
  def build_exception(obj, args); end
  def details_message; end
  def details_message=(arg0); end
  def disable!; end
  def disabled?; end
  def enable!; end
  def enabled?; end
  def exception_class; end
  def exception_class=(arg0); end
  def exception_message; end
  def exception_message=(arg0); end
  def ignore_if(&block); end
  def ignored?(*args); end
  def ignores; end
  def notify(backtrace, obj, *args); end
  def notify?(*args); end
end
module Isolator::AdapterBuilder
  def self.add_patch_method(adapter, base, method_name); end
  def self.call(target: nil, method_name: nil, **options); end
end
class Isolator::Notifier
  def backtrace; end
  def call; end
  def exception; end
  def filtered_backtrace; end
  def initialize(exception, backtrace = nil); end
  def log_exception; end
  def raise_exceptions?; end
  def send_notifications; end
  def send_notifications?; end
  def uniform_notifier_loaded?; end
end
class Isolator::UnsafeOperationError < StandardError
  def initialize(msg = nil, details: nil); end
end
class Isolator::HTTPError < Isolator::UnsafeOperationError
end
class Isolator::BackgroundJobError < Isolator::UnsafeOperationError
end
class Isolator::MailerError < Isolator::UnsafeOperationError
end
class Isolator::SimpleHashie < Hash
  def method_missing(key, *args, &block); end
  def respond_to_missing?(key); end
end
class Isolator::Ignorer
  def self.prepare(path: nil, regex_string: nil); end
end
class Isolator::Ignorer::AdapterIgnore
  def adapter; end
  def adapter=(arg0); end
  def ignored_paths; end
  def ignored_paths=(arg0); end
  def ignores; end
  def initialize(adapter:, ignored_paths:, regex_string:); end
  def prepare; end
  def regex; end
  def regex_string; end
  def regex_string=(arg0); end
end
module Isolator::Callbacks
  def after_isolate(&block); end
  def after_isolate_callbacks; end
  def before_isolate(&block); end
  def before_isolate_callbacks; end
  def finish!; end
  def start!; end
end
module Isolator::Isolate
  def isolate(id, **options); end
end
module Isolator::ThreadFetch
end
class Isolator::Railtie < Rails::Railtie
end
class Isolator::ThreadStateProxy
  def [](key); end
  def []=(key, value); end
  def initilize(prefix = nil); end
  def prefix; end
end
module Isolator::ActiveSupportSubscriber
  def self.subscribe!(event); end
end
