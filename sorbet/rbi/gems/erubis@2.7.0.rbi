# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `erubis` gem.
# Please instead update this file by running `bin/tapioca gem erubis`.

module Erubis; end

# use an Array object as buffer (included in Eruby by default)
#
# this is only for Eruby.
module Erubis::ArrayBufferEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

# return array instead of string
#
# this is only for Eruby.
module Erubis::ArrayEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

module Erubis::Basic; end

# basic converter which supports '<% ... %>' notation.
module Erubis::Basic::Converter
  include ::Erubis::Converter

  # add expression code to src
  def add_expr(src, code, indicator); end

  def convert_input(src, input); end
  def init_converter(properties = T.unsafe(nil)); end

  # Returns the value of attribute pattern.
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  def pattern=(_arg0); end

  # Returns the value of attribute trim.
  def trim; end

  # Sets the attribute trim
  #
  # @param value the value to set the attribute trim to.
  def trim=(_arg0); end

  private

  # return regexp of pattern to parse eRuby script
  def pattern_regexp(pattern); end

  class << self
    # return regexp of pattern to parse eRuby script
    def pattern_regexp(pattern); end

    def supported_properties; end
  end
end

# DEFAULT_REGEXP = /(.*?)(^[ \t]*)?<%(=+|\#)?(.*?)-?%>([ \t]*\r?\n)?/m
# DEFAULT_REGEXP = /(^[ \t]*)?<%(=+|\#)?(.*?)-?%>([ \t]*\r?\n)?/m
# DEFAULT_REGEXP = /<%(=+|\#)?(.*?)-?%>([ \t]*\r?\n)?/m
Erubis::Basic::Converter::DEFAULT_REGEXP = T.let(T.unsafe(nil), Regexp)

# (abstract) base engine class for Eruby, Eperl, Ejava, and so on.
# subclass must include generator.
class Erubis::Basic::Engine < ::Erubis::Engine
  include ::Erubis::Evaluator
  include ::Erubis::Converter
  include ::Erubis::Basic::Converter
  include ::Erubis::Generator
end

# enable to use other embedded expression pattern (default is '\[= =\]').
#
# notice! this is an experimental. spec may change in the future.
#
# ex.
#   input = <<END
#   <% for item in list %>
#     <%= item %> : <%== item %>
#     [= item =] : [== item =]
#   <% end %>
#   END
#
#   class BiPatternEruby
#     include BiPatternEnhancer
#   end
#   eruby = BiPatternEruby.new(input, :bipattern=>'\[= =\]')
#   list = ['<a>', 'b&b', '"c"']
#   print eruby.result(binding())
#
#   ## output
#     <a> : &lt;a&gt;
#     <a> : &lt;a&gt;
#     b&b : b&amp;b
#     b&b : b&amp;b
#     "c" : &quot;c&quot;
#     "c" : &quot;c&quot;
#
# this is language independent.
module Erubis::BiPatternEnhancer
  def initialize(input, properties = T.unsafe(nil)); end

  def add_text(src, text); end

  # when pat is nil then '\[= =\]' is used
  def bipattern=(pat); end

  class << self
    def desc; end
  end
end

# context object for Engine#evaluate
#
# ex.
#   template = <<'END'
#   Hello <%= @user %>!
#   <% for item in @list %>
#    - <%= item %>
#   <% end %>
#   END
#
#   context = Erubis::Context.new(:user=>'World', :list=>['a','b','c'])
#   # or
#   # context = Erubis::Context.new
#   # context[:user] = 'World'
#   # context[:list] = ['a', 'b', 'c']
#
#   eruby = Erubis::Eruby.new(template)
#   print eruby.evaluate(context)
class Erubis::Context
  include ::Enumerable

  # @return [Context] a new instance of Context
  def initialize(hash = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def each; end
  def keys; end
  def to_hash; end
  def update(context_or_hash); end
end

# convert
module Erubis::Converter
  # convert input string into target language
  def convert(input); end

  # Returns the value of attribute escape.
  def escape; end

  # Sets the attribute escape
  #
  # @param value the value to set the attribute escape to.
  def escape=(_arg0); end

  def init_converter(properties = T.unsafe(nil)); end

  # Returns the value of attribute postamble.
  def postamble; end

  # Sets the attribute postamble
  #
  # @param value the value to set the attribute postamble to.
  def postamble=(_arg0); end

  # Returns the value of attribute preamble.
  def preamble; end

  # Sets the attribute preamble
  #
  # @param value the value to set the attribute preamble to.
  def preamble=(_arg0); end

  protected

  # (abstract) convert input to code
  def convert_input(codebuf, input); end

  # detect spaces at beginning of line
  def detect_spaces_at_bol(text, is_bol); end

  class << self
    def supported_properties; end
  end
end

# delete indentation of HTML.
#
# this is language-independent.
module Erubis::DeleteIndentEnhancer
  def convert_input(src, input); end

  class << self
    def desc; end
  end
end

Erubis::EMPTY_BINDING = T.let(T.unsafe(nil), Binding)

# (abstract) abstract engine class.
# subclass must include evaluator and converter module.
class Erubis::Engine
  # include Evaluator
  # include Converter
  # include Generator
  #
  # @return [Engine] a new instance of Engine
  def initialize(input = T.unsafe(nil), properties = T.unsafe(nil)); end

  # convert input string and set it to @src
  def convert!(input); end

  # helper method to convert and evaluate input text with context object.
  # context may be Binding, Hash, or Object.
  def process(input, context = T.unsafe(nil), filename = T.unsafe(nil)); end

  # helper method evaluate Proc object with contect object.
  # context may be Binding, Hash, or Object.
  def process_proc(proc_obj, context = T.unsafe(nil), filename = T.unsafe(nil)); end

  class << self
    # load file, write cache file, and return engine object.
    # this method create code cache file automatically.
    # cachefile name can be specified with properties[:cachename],
    # or filname + 'cache' is used as default.
    def load_file(filename, properties = T.unsafe(nil)); end
  end
end

# set buffer variable name to '_erbout' as well as '_buf'
#
# this is only for Eruby.
module Erubis::ErboutEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

# base error class
class Erubis::ErubisError < ::StandardError; end

# engine for Ruby
class Erubis::Eruby < ::Erubis::Basic::Engine
  include ::Erubis::RubyEvaluator
  include ::Erubis::StringBufferEnhancer
  include ::Erubis::RubyGenerator
end

# switch '<%= ... %>' to escaped and '<%== ... %>' to unescaped
#
# ex.
#   class XmlEruby < Eruby
#     include EscapeEnhancer
#   end
#
# this is language-indenedent.
module Erubis::EscapeEnhancer
  # --
  # def self.included(klass)
  #  klass.class_eval <<-END
  #    alias _add_expr_literal add_expr_literal
  #    alias _add_expr_escaped add_expr_escaped
  #    alias add_expr_literal _add_expr_escaped
  #    alias add_expr_escaped _add_expr_literal
  #  END
  # end
  # ++
  def add_expr(src, code, indicator); end

  class << self
    def desc; end
  end
end

# swtich '<%= %>' to escaped and '<%== %>' to not escaped
class Erubis::EscapedEruby < ::Erubis::Eruby
  include ::Erubis::EscapeEnhancer
end

# evaluate code
module Erubis::Evaluator
  # @raise [NotSupportedError]
  def evaluate(*args); end

  # Returns the value of attribute filename.
  def filename; end

  # Sets the attribute filename
  #
  # @param value the value to set the attribute filename to.
  def filename=(_arg0); end

  def init_evaluator(properties); end

  # @raise [NotSupportedError]
  def result(*args); end

  # Returns the value of attribute src.
  def src; end

  # Sets the attribute src
  #
  # @param value the value to set the attribute src to.
  def src=(_arg0); end

  class << self
    def supported_properties; end
  end
end

# fast engine for Ruby
class Erubis::FastEruby < ::Erubis::Eruby
  include ::Erubis::InterpolationEnhancer
end

# code generator, called by Converter module
module Erubis::Generator
  # (abstract) add expression code to src for debug. this is called by add_expr().
  def add_expr_debug(src, code); end

  # (abstract) add escaped expression code to src. this is called by add_expr().
  def add_expr_escaped(src, code); end

  # (abstract) add expression literal code to src. this is called by add_expr().
  def add_expr_literal(src, code); end

  # (abstract) add @postamble to src
  def add_postamble(src); end

  # (abstract) add @preamble to src
  def add_preamble(src); end

  # (abstract) add statement code to src
  def add_stmt(src, code); end

  # (abstract) add text string to src
  def add_text(src, text); end

  # (abstract) escape text string
  #
  # ex.
  #   def escape_text(text)
  #     return text.dump
  #     # or return "'" + text.gsub(/['\\]/, '\\\\\&') + "'"
  #   end
  def escape_text(text); end

  # return escaped expression code (ex. 'h(...)' or 'htmlspecialchars(...)')
  def escaped_expr(code); end

  # Returns the value of attribute escapefunc.
  def escapefunc; end

  # Sets the attribute escapefunc
  #
  # @param value the value to set the attribute escapefunc to.
  def escapefunc=(_arg0); end

  def init_generator(properties = T.unsafe(nil)); end

  class << self
    def supported_properties; end
  end
end

# [experimental] allow header and footer in eRuby script
#
# ex.
#   ====================
#   ## without header and footer
#   $ cat ex1.eruby
#   <% def list_items(list) %>
#   <%   for item in list %>
#   <li><%= item %></li>
#   <%   end %>
#   <% end %>
#
#   $ erubis -s ex1.eruby
#   _buf = []; def list_items(list)
#   ;   for item in list
#   ; _buf << '<li>'; _buf << ( item ).to_s; _buf << '</li>
#   ';   end
#   ; end
#   ;
#   _buf.join
#
#   ## with header and footer
#   $ cat ex2.eruby
#   <!--#header:
#   def list_items(list)
#    #-->
#   <%  for item in list %>
#   <li><%= item %></li>
#   <%  end %>
#   <!--#footer:
#   end
#    #-->
#
#   $ erubis -s -c HeaderFooterEruby ex4.eruby
#
#   def list_items(list)
#    _buf = []; _buf << '
#   ';  for item in list
#   ; _buf << '<li>'; _buf << ( item ).to_s; _buf << '</li>
#   ';  end
#   ; _buf << '
#   ';
#   _buf.join
#   end
#
#   ====================
#
# this is language-independent.
module Erubis::HeaderFooterEnhancer
  def add_text(src, text); end
  def convert(input); end

  # Returns the value of attribute footer.
  def footer; end

  # Sets the attribute footer
  #
  # @param value the value to set the attribute footer to.
  def footer=(_arg0); end

  # Returns the value of attribute header.
  def header; end

  # Sets the attribute header
  #
  # @param value the value to set the attribute header to.
  def header=(_arg0); end

  class << self
    def desc; end
  end
end

Erubis::HeaderFooterEnhancer::HEADER_FOOTER_PATTERN = T.let(T.unsafe(nil), Regexp)

# convert "<h1><%=title%></h1>" into "_buf << %Q`<h1>#{title}</h1>`"
#
# this is only for Eruby.
module Erubis::InterpolationEnhancer
  def _add_text_to_str(str, text); end
  def add_expr_escaped(str, code); end
  def add_expr_literal(str, code); end
  def add_text(src, text); end
  def convert_input(src, input); end

  class << self
    def desc; end
  end
end

# remove code and leave text, especially useful when validating HTML tags.
#
# ex.
#   $ erubis -s -E NoCode file.eruby | tidy -errors
#
# this is language independent.
module Erubis::NoCodeEnhancer
  def add_expr(src, code, indicator); end
  def add_postamble(src); end
  def add_preamble(src); end
  def add_stmt(src, code); end
  def add_text(src, text); end

  class << self
    def desc; end
  end
end

# remove text and leave code, especially useful when debugging.
#
# ex.
#   $ erubis -s -E NoText file.eruby | more
#
# this is language independent.
module Erubis::NoTextEnhancer
  def add_text(src, text); end

  class << self
    def desc; end
  end
end

# raised when method or function is not supported
class Erubis::NotSupportedError < ::Erubis::ErubisError; end

module Erubis::PI; end

# Processing Instructions (PI) converter for XML.
# this class converts '<?rb ... ?>' and '${...}' notation.
module Erubis::PI::Converter
  include ::Erubis::Converter

  def convert(input); end
  def init_converter(properties = T.unsafe(nil)); end

  # Returns the value of attribute pi.
  def pi; end

  # Sets the attribute pi
  #
  # @param value the value to set the attribute pi to.
  def pi=(_arg0); end

  # Returns the value of attribute prefix.
  def prefix; end

  # Sets the attribute prefix
  #
  # @param value the value to set the attribute prefix to.
  def prefix=(_arg0); end

  protected

  def add_pi_expr(codebuf, code, indicator); end

  # --
  # def convert_input(codebuf, input)
  #  parse_stmts(codebuf, input)
  #  #parse_stmts2(codebuf, input)
  # end
  #
  # def parse_stmts(codebuf, input)
  #  #regexp = pattern_regexp(@pattern)
  #  @pi ||= 'e'
  #  @stmt_pattern ||= /<\?#{@pi}(?:-(\w+))?(\s.*?)\?>([ \t]*\r?\n)?/m
  #  is_bol = true
  #  pos = 0
  #  input.scan(@stmt_pattern) do |pi_arg, code, rspace|
  #    match = Regexp.last_match
  #    len  = match.begin(0) - pos
  #    text = input[pos, len]
  #    pos  = match.end(0)
  #    lspace = detect_spaces_at_bol(text, is_bol)
  #    is_bol = rspace ? true : false
  #    parse_exprs(codebuf, text) # unless text.empty?
  #    if @trim && lspace && rspace
  #      add_pi_stmt(codebuf, "#{lspace}#{code}#{rspace}", pi_arg)
  #    else
  #      add_text(codebuf, lspace)
  #      add_pi_stmt(codebuf, code, pi_arg)
  #      add_text(codebuf, rspace)
  #    end
  #  end
  #  rest = $' || input
  #  parse_exprs(codebuf, rest)
  # end
  #
  # def parse_exprs(codebuf, input)
  #  unless @expr_pattern
  #    ch = Regexp.escape(@embchar)
  #    if @pattern
  #      left, right = @pattern.split(' ')
  #      @expr_pattern = /#{ch}(!*)?\{(.*?)\}#{ch}|#{left}(=+)(.*?)#{right}/
  #    else
  #      @expr_pattern = /#{ch}(!*)?\{(.*?)\}#{ch}/
  #    end
  #  end
  #  pos = 0
  #  input.scan(@expr_pattern) do |indicator1, code1, indicator2, code2|
  #    indicator = indicator1 || indicator2
  #    code = code1 || code2
  #    match = Regexp.last_match
  #    len  = match.begin(0) - pos
  #    text = input[pos, len]
  #    pos  = match.end(0)
  #    add_text(codebuf, text) # unless text.empty?
  #    add_pi_expr(codebuf, code, indicator)
  #  end
  #  rest = $' || input
  #  add_text(codebuf, rest)
  # end
  # ++
  def add_pi_stmt(codebuf, code, pi_arg); end

  def convert_input(codebuf, input); end

  class << self
    def desc; end
    def supported_properties; end
  end
end

class Erubis::PI::Engine < ::Erubis::Engine
  include ::Erubis::Evaluator
  include ::Erubis::Converter
  include ::Erubis::PI::Converter
  include ::Erubis::Generator
end

class Erubis::PI::Eruby < ::Erubis::PI::Engine
  include ::Erubis::RubyEvaluator
  include ::Erubis::StringBufferEnhancer
  include ::Erubis::RubyGenerator

  def init_converter(properties = T.unsafe(nil)); end
end

# regards lines starting with '%' as program code
#
# this is for compatibility to eruby and ERB.
#
# this is language-independent.
module Erubis::PercentLineEnhancer
  include ::Erubis::PrefixedLineEnhancer

  # --
  # def init_generator(properties={})
  #  super
  #  @prefixchar = '%'
  #  @prefixrexp = /^\%(.*?\r?\n)/
  # end
  # ++
  def add_text(src, text); end

  class << self
    def desc; end
  end
end

# regards lines starting with '^[ \t]*%' as program code
#
# in addition you can specify prefix character (default '%')
#
# this is language-independent.
module Erubis::PrefixedLineEnhancer
  def add_text(src, text); end
  def init_generator(properties = T.unsafe(nil)); end

  class << self
    def desc; end
  end
end

# enable print function
#
# Notice: use Eruby#evaluate() and don't use Eruby#result()
# to be enable print function.
#
# this is only for Eruby.
module Erubis::PrintEnabledEnhancer
  def add_preamble(src); end
  def evaluate(context = T.unsafe(nil)); end
  def print(*args); end

  class << self
    def desc; end
  end
end

# use print statement instead of '_buf << ...'
#
# this is only for Eruby.
module Erubis::PrintOutEnhancer
  def add_expr_escaped(src, code); end
  def add_expr_literal(src, code); end
  def add_postamble(src); end
  def add_preamble(src); end
  def add_text(src, text); end

  class << self
    def desc; end
  end
end

# evaluator for Ruby
module Erubis::RubyEvaluator
  include ::Erubis::Evaluator

  # if object is an Class or Module then define instance method to it,
  # else define singleton method to it.
  def def_method(object, method_name, filename = T.unsafe(nil)); end

  # invoke context.instance_eval(@src)
  def evaluate(_context = T.unsafe(nil)); end

  # eval(@src) with binding object
  def result(_binding_or_hash = T.unsafe(nil)); end

  class << self
    def supported_properties; end
  end
end

# code generator for Ruby
module Erubis::RubyGenerator
  include ::Erubis::Generator
  include ::Erubis::StringBufferEnhancer

  def add_expr_debug(src, code); end
  def add_expr_escaped(src, code); end
  def add_expr_literal(src, code); end
  def add_stmt(src, code); end

  # --
  # def add_preamble(src)
  #  src << "#{@bufvar} = [];"
  # end
  # ++
  def add_text(src, text); end

  def escape_text(text); end
  def escaped_expr(code); end
  def init_generator(properties = T.unsafe(nil)); end

  class << self
    def supported_properties; end
  end
end

# get convert faster, but spaces around '<%...%>' are not trimmed.
#
# this is language-independent.
module Erubis::SimplifyEnhancer
  def convert(input); end

  class << self
    def desc; end
  end
end

# DEFAULT_REGEXP = /(^[ \t]*)?<%(=+|\#)?(.*?)-?%>([ \t]*\r?\n)?/m
Erubis::SimplifyEnhancer::SIMPLE_REGEXP = T.let(T.unsafe(nil), Regexp)

# use $stdout instead of string
#
# this is only for Eruby.
module Erubis::StdoutEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

# use String class for buffering
#
# this is only for Eruby.
module Erubis::StringBufferEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

# use StringIO class for buffering
#
# this is only for Eruby.
module Erubis::StringIOEnhancer
  def add_postamble(src); end
  def add_preamble(src); end

  class << self
    def desc; end
  end
end

Erubis::VERSION = T.let(T.unsafe(nil), String)

# sanitize expression (<%= ... %>) by default
#
# this is equivalent to EscapedEruby and is prepared only for compatibility.
class Erubis::XmlEruby < ::Erubis::Eruby
  include ::Erubis::EscapeEnhancer
end

# helper for xml
module Erubis::XmlHelper
  private

  def escape_xml(value); end
  def escape_xml2(value); end
  def h(value); end
  def html_escape(value); end
  def u(str); end
  def url_encode(str); end

  class << self
    def escape_xml(value); end
    def escape_xml2(value); end
    def url_encode(str); end
  end
end

Erubis::XmlHelper::ESCAPE_TABLE = T.let(T.unsafe(nil), Hash)

module Kernel
  private

  # raise NotImplementedError
  def not_implemented; end
end
