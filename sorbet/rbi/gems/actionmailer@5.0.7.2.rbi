# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actionmailer` gem.
# Please instead update this file by running `bin/tapioca gem actionmailer`.

module ActionMailer
  extend ::ActiveSupport::Autoload

  class << self
    # Returns the version of the currently loaded Action Mailer as a <tt>Gem::Version</tt>.
    def gem_version; end

    # Returns the version of the currently loaded Action Mailer as a
    # <tt>Gem::Version</tt>.
    def version; end
  end
end

# Action Mailer allows you to send email from your application using a mailer model and views.
#
# = Mailer Models
#
# To use Action Mailer, you need to create a mailer model.
#
#   $ rails generate mailer Notifier
#
# The generated model inherits from <tt>ApplicationMailer</tt> which in turn
# inherits from <tt>ActionMailer::Base</tt>. A mailer model defines methods
# used to generate an email message. In these methods, you can setup variables to be used in
# the mailer views, options on the mail itself such as the <tt>:from</tt> address, and attachments.
#
#   class ApplicationMailer < ActionMailer::Base
#     default from: 'from@example.com'
#     layout 'mailer'
#   end
#
#   class NotifierMailer < ApplicationMailer
#     default from: 'no-reply@example.com',
#             return_path: 'system@example.com'
#
#     def welcome(recipient)
#       @account = recipient
#       mail(to: recipient.email_address_with_name,
#            bcc: ["bcc@example.com", "Order Watcher <watcher@example.com>"])
#     end
#   end
#
# Within the mailer method, you have access to the following methods:
#
# * <tt>attachments[]=</tt> - Allows you to add attachments to your email in an intuitive
#   manner; <tt>attachments['filename.png'] = File.read('path/to/filename.png')</tt>
#
# * <tt>attachments.inline[]=</tt> - Allows you to add an inline attachment to your email
#   in the same manner as <tt>attachments[]=</tt>
#
# * <tt>headers[]=</tt> - Allows you to specify any header field in your email such
#   as <tt>headers['X-No-Spam'] = 'True'</tt>. Note that declaring a header multiple times
#   will add many fields of the same name. Read #headers doc for more information.
#
# * <tt>headers(hash)</tt> - Allows you to specify multiple headers in your email such
#   as <tt>headers({'X-No-Spam' => 'True', 'In-Reply-To' => '1234@message.id'})</tt>
#
# * <tt>mail</tt> - Allows you to specify email to be sent.
#
# The hash passed to the mail method allows you to specify any header that a <tt>Mail::Message</tt>
# will accept (any valid email header including optional fields).
#
# The mail method, if not passed a block, will inspect your views and send all the views with
# the same name as the method, so the above action would send the +welcome.text.erb+ view
# file as well as the +welcome.html.erb+ view file in a +multipart/alternative+ email.
#
# If you want to explicitly render only certain templates, pass a block:
#
#   mail(to: user.email) do |format|
#     format.text
#     format.html
#   end
#
# The block syntax is also useful in providing information specific to a part:
#
#   mail(to: user.email) do |format|
#     format.html
#   end
#
# Or even to render a special view:
#
#   mail(to: user.email) do |format|
#     format.text
#     format.html { render "some_other_template" }
#   end
#
# = Mailer views
#
# Like Action Controller, each mailer class has a corresponding view directory in which each
# method of the class looks for a template with its name.
#
# To define a template to be used with a mailer, create an <tt>.erb</tt> file with the same
# name as the method in your mailer model. For example, in the mailer defined above, the template at
# <tt>app/views/notifier_mailer/welcome.text.erb</tt> would be used to generate the email.
#
# Variables defined in the methods of your mailer model are accessible as instance variables in their
# corresponding view.
#
# Emails by default are sent in plain text, so a sample view for our model example might look like this:
#
#   Hi <%= @account.name %>,
#   Thanks for joining our service! Please check back often.
#
# You can even use Action View helpers in these views. For example:
#
#   You got a new note!
#   <%= truncate(@note.body, length: 25) %>
#
# If you need to access the subject, from or the recipients in the view, you can do that through message object:
#
#   You got a new note from <%= message.from %>!
#   <%= truncate(@note.body, length: 25) %>
#
#
# = Generating URLs
#
# URLs can be generated in mailer views using <tt>url_for</tt> or named routes. Unlike controllers from
# Action Pack, the mailer instance doesn't have any context about the incoming request, so you'll need
# to provide all of the details needed to generate a URL.
#
# When using <tt>url_for</tt> you'll need to provide the <tt>:host</tt>, <tt>:controller</tt>, and <tt>:action</tt>:
#
#   <%= url_for(host: "example.com", controller: "welcome", action: "greeting") %>
#
# When using named routes you only need to supply the <tt>:host</tt>:
#
#   <%= users_url(host: "example.com") %>
#
# You should use the <tt>named_route_url</tt> style (which generates absolute URLs) and avoid using the
# <tt>named_route_path</tt> style (which generates relative URLs), since clients reading the mail will
# have no concept of a current URL from which to determine a relative path.
#
# It is also possible to set a default host that will be used in all mailers by setting the <tt>:host</tt>
# option as a configuration option in <tt>config/application.rb</tt>:
#
#   config.action_mailer.default_url_options = { host: "example.com" }
#
# By default when <tt>config.force_ssl</tt> is true, URLs generated for hosts will use the HTTPS protocol.
#
# = Sending mail
#
# Once a mailer action and template are defined, you can deliver your message or defer its creation and
# delivery for later:
#
#   NotifierMailer.welcome(User.first).deliver_now # sends the email
#   mail = NotifierMailer.welcome(User.first)      # => an ActionMailer::MessageDelivery object
#   mail.deliver_now                               # generates and sends the email now
#
# The <tt>ActionMailer::MessageDelivery</tt> class is a wrapper around a delegate that will call
# your method to generate the mail. If you want direct access to the delegator, or <tt>Mail::Message</tt>,
# you can call the <tt>message</tt> method on the <tt>ActionMailer::MessageDelivery</tt> object.
#
#   NotifierMailer.welcome(User.first).message     # => a Mail::Message object
#
# Action Mailer is nicely integrated with Active Job so you can generate and send emails in the background
# (example: outside of the request-response cycle, so the user doesn't have to wait on it):
#
#   NotifierMailer.welcome(User.first).deliver_later # enqueue the email sending to Active Job
#
# Note that <tt>deliver_later</tt> will execute your method from the background job.
#
# You never instantiate your mailer class. Rather, you just call the method you defined on the class itself.
# All instance methods are expected to return a message object to be sent.
#
# = Multipart Emails
#
# Multipart messages can also be used implicitly because Action Mailer will automatically detect and use
# multipart templates, where each template is named after the name of the action, followed by the content
# type. Each such detected template will be added to the message, as a separate part.
#
# For example, if the following templates exist:
# * signup_notification.text.erb
# * signup_notification.html.erb
# * signup_notification.xml.builder
# * signup_notification.yml.erb
#
# Each would be rendered and added as a separate part to the message, with the corresponding content
# type. The content type for the entire message is automatically set to <tt>multipart/alternative</tt>,
# which indicates that the email contains multiple different representations of the same email
# body. The same instance variables defined in the action are passed to all email templates.
#
# Implicit template rendering is not performed if any attachments or parts have been added to the email.
# This means that you'll have to manually add each part to the email and set the content type of the email
# to <tt>multipart/alternative</tt>.
#
# = Attachments
#
# Sending attachment in emails is easy:
#
#   class NotifierMailer < ApplicationMailer
#     def welcome(recipient)
#       attachments['free_book.pdf'] = File.read('path/to/file.pdf')
#       mail(to: recipient, subject: "New account information")
#     end
#   end
#
# Which will (if it had both a <tt>welcome.text.erb</tt> and <tt>welcome.html.erb</tt>
# template in the view directory), send a complete <tt>multipart/mixed</tt> email with two parts,
# the first part being a <tt>multipart/alternative</tt> with the text and HTML email parts inside,
# and the second being a <tt>application/pdf</tt> with a Base64 encoded copy of the file.pdf book
# with the filename +free_book.pdf+.
#
# If you need to send attachments with no content, you need to create an empty view for it,
# or add an empty body parameter like this:
#
#     class NotifierMailer < ApplicationMailer
#       def welcome(recipient)
#         attachments['free_book.pdf'] = File.read('path/to/file.pdf')
#         mail(to: recipient, subject: "New account information", body: "")
#       end
#     end
#
# = Inline Attachments
#
# You can also specify that a file should be displayed inline with other HTML. This is useful
# if you want to display a corporate logo or a photo.
#
#   class NotifierMailer < ApplicationMailer
#     def welcome(recipient)
#       attachments.inline['photo.png'] = File.read('path/to/photo.png')
#       mail(to: recipient, subject: "Here is what we look like")
#     end
#   end
#
# And then to reference the image in the view, you create a <tt>welcome.html.erb</tt> file and
# make a call to +image_tag+ passing in the attachment you want to display and then call
# +url+ on the attachment to get the relative content id path for the image source:
#
#   <h1>Please Don't Cringe</h1>
#
#   <%= image_tag attachments['photo.png'].url -%>
#
# As we are using Action View's +image_tag+ method, you can pass in any other options you want:
#
#   <h1>Please Don't Cringe</h1>
#
#   <%= image_tag attachments['photo.png'].url, alt: 'Our Photo', class: 'photo' -%>
#
# = Observing and Intercepting Mails
#
# Action Mailer provides hooks into the Mail observer and interceptor methods. These allow you to
# register classes that are called during the mail delivery life cycle.
#
# An observer class must implement the <tt>:delivered_email(message)</tt> method which will be
# called once for every email sent after the email has been sent.
#
# An interceptor class must implement the <tt>:delivering_email(message)</tt> method which will be
# called before the email is sent, allowing you to make modifications to the email before it hits
# the delivery agents. Your class should make any needed modifications directly to the passed
# in <tt>Mail::Message</tt> instance.
#
# = Default Hash
#
# Action Mailer provides some intelligent defaults for your emails, these are usually specified in a
# default method inside the class definition:
#
#   class NotifierMailer < ApplicationMailer
#     default sender: 'system@example.com'
#   end
#
# You can pass in any header value that a <tt>Mail::Message</tt> accepts. Out of the box,
# <tt>ActionMailer::Base</tt> sets the following:
#
# * <tt>mime_version: "1.0"</tt>
# * <tt>charset:      "UTF-8"</tt>
# * <tt>content_type: "text/plain"</tt>
# * <tt>parts_order:  [ "text/plain", "text/enriched", "text/html" ]</tt>
#
# <tt>parts_order</tt> and <tt>charset</tt> are not actually valid <tt>Mail::Message</tt> header fields,
# but Action Mailer translates them appropriately and sets the correct values.
#
# As you can pass in any header, you need to either quote the header as a string, or pass it in as
# an underscored symbol, so the following will work:
#
#   class NotifierMailer < ApplicationMailer
#     default 'Content-Transfer-Encoding' => '7bit',
#             content_description: 'This is a description'
#   end
#
# Finally, Action Mailer also supports passing <tt>Proc</tt> objects into the default hash, so you
# can define methods that evaluate as the message is being generated:
#
#   class NotifierMailer < ApplicationMailer
#     default 'X-Special-Header' => Proc.new { my_method }
#
#     private
#
#       def my_method
#         'some complex call'
#       end
#   end
#
# Note that the proc is evaluated right at the start of the mail message generation, so if you
# set something in the default hash using a proc, and then set the same thing inside of your
# mailer method, it will get overwritten by the mailer method.
#
# It is also possible to set these default options that will be used in all mailers through
# the <tt>default_options=</tt> configuration in <tt>config/application.rb</tt>:
#
#    config.action_mailer.default_options = { from: "no-reply@example.org" }
#
# = Callbacks
#
# You can specify callbacks using before_action and after_action for configuring your messages.
# This may be useful, for example, when you want to add default inline attachments for all
# messages sent out by a certain mailer class:
#
#   class NotifierMailer < ApplicationMailer
#     before_action :add_inline_attachment!
#
#     def welcome
#       mail
#     end
#
#     private
#
#       def add_inline_attachment!
#         attachments.inline["footer.jpg"] = File.read('/path/to/filename.jpg')
#       end
#   end
#
# Callbacks in Action Mailer are implemented using
# <tt>AbstractController::Callbacks</tt>, so you can define and configure
# callbacks in the same manner that you would use callbacks in classes that
# inherit from <tt>ActionController::Base</tt>.
#
# Note that unless you have a specific reason to do so, you should prefer
# using <tt>before_action</tt> rather than <tt>after_action</tt> in your
# Action Mailer classes so that headers are parsed properly.
#
# = Previewing emails
#
# You can preview your email templates visually by adding a mailer preview file to the
# <tt>ActionMailer::Base.preview_path</tt>. Since most emails do something interesting
# with database data, you'll need to write some scenarios to load messages with fake data:
#
#   class NotifierMailerPreview < ActionMailer::Preview
#     def welcome
#       NotifierMailer.welcome(User.first)
#     end
#   end
#
# Methods must return a <tt>Mail::Message</tt> object which can be generated by calling the mailer
# method without the additional <tt>deliver_now</tt> / <tt>deliver_later</tt>. The location of the
# mailer previews directory can be configured using the <tt>preview_path</tt> option which has a default
# of <tt>test/mailers/previews</tt>:
#
#   config.action_mailer.preview_path = "#{Rails.root}/lib/mailer_previews"
#
# An overview of all previews is accessible at <tt>http://localhost:3000/rails/mailers</tt>
# on a running development server instance.
#
# Previews can also be intercepted in a similar manner as deliveries can be by registering
# a preview interceptor that has a <tt>previewing_email</tt> method:
#
#   class CssInlineStyler
#     def self.previewing_email(message)
#       # inline CSS styles
#     end
#   end
#
#   config.action_mailer.preview_interceptors :css_inline_styler
#
# Note that interceptors need to be registered both with <tt>register_interceptor</tt>
# and <tt>register_preview_interceptor</tt> if they should operate on both sending and
# previewing emails.
#
# = Configuration options
#
# These options are specified on the class level, like
# <tt>ActionMailer::Base.raise_delivery_errors = true</tt>
#
# * <tt>default_options</tt> - You can pass this in at a class level as well as within the class itself as
#   per the above section.
#
# * <tt>logger</tt> - the logger is used for generating information on the mailing run if available.
#   Can be set to +nil+ for no logging. Compatible with both Ruby's own +Logger+ and Log4r loggers.
#
# * <tt>smtp_settings</tt> - Allows detailed configuration for <tt>:smtp</tt> delivery method:
#   * <tt>:address</tt> - Allows you to use a remote mail server. Just change it from its default
#     "localhost" setting.
#   * <tt>:port</tt> - On the off chance that your mail server doesn't run on port 25, you can change it.
#   * <tt>:domain</tt> - If you need to specify a HELO domain, you can do it here.
#   * <tt>:user_name</tt> - If your mail server requires authentication, set the username in this setting.
#   * <tt>:password</tt> - If your mail server requires authentication, set the password in this setting.
#   * <tt>:authentication</tt> - If your mail server requires authentication, you need to specify the
#     authentication type here.
#     This is a symbol and one of <tt>:plain</tt> (will send the password Base64 encoded), <tt>:login</tt> (will
#     send the password Base64 encoded) or <tt>:cram_md5</tt> (combines a Challenge/Response mechanism to exchange
#     information and a cryptographic Message Digest 5 algorithm to hash important information)
#   * <tt>:enable_starttls_auto</tt> - Detects if STARTTLS is enabled in your SMTP server and starts
#     to use it. Defaults to <tt>true</tt>.
#   * <tt>:openssl_verify_mode</tt> - When using TLS, you can set how OpenSSL checks the certificate. This is
#     really useful if you need to validate a self-signed and/or a wildcard certificate. You can use the name
#     of an OpenSSL verify constant (<tt>'none'</tt>, <tt>'peer'</tt>, <tt>'client_once'</tt>,
#     <tt>'fail_if_no_peer_cert'</tt>) or directly the constant (<tt>OpenSSL::SSL::VERIFY_NONE</tt>,
#     <tt>OpenSSL::SSL::VERIFY_PEER</tt>, ...).
#
# * <tt>sendmail_settings</tt> - Allows you to override options for the <tt>:sendmail</tt> delivery method.
#   * <tt>:location</tt> - The location of the sendmail executable. Defaults to <tt>/usr/sbin/sendmail</tt>.
#   * <tt>:arguments</tt> - The command line arguments. Defaults to <tt>-i</tt> with <tt>-f sender@address</tt>
#     added automatically before the message is sent.
#
# * <tt>file_settings</tt> - Allows you to override options for the <tt>:file</tt> delivery method.
#   * <tt>:location</tt> - The directory into which emails will be written. Defaults to the application
#     <tt>tmp/mails</tt>.
#
# * <tt>raise_delivery_errors</tt> - Whether or not errors should be raised if the email fails to be delivered.
#
# * <tt>delivery_method</tt> - Defines a delivery method. Possible values are <tt>:smtp</tt> (default),
#   <tt>:sendmail</tt>, <tt>:test</tt>, and <tt>:file</tt>. Or you may provide a custom delivery method
#   object e.g. +MyOwnDeliveryMethodClass+. See the Mail gem documentation on the interface you need to
#   implement for a custom delivery agent.
#
# * <tt>perform_deliveries</tt> - Determines whether emails are actually sent from Action Mailer when you
#   call <tt>.deliver</tt> on an email message or on an Action Mailer method. This is on by default but can
#   be turned off to aid in functional testing.
#
# * <tt>deliveries</tt> - Keeps an array of all the emails sent out through the Action Mailer with
#   <tt>delivery_method :test</tt>. Most useful for unit and functional testing.
#
# * <tt>deliver_later_queue_name</tt> - The name of the queue used with <tt>deliver_later</tt>.
#
# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
class ActionMailer::Base < ::AbstractController::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActiveSupport::Rescuable
  include ::ActionMailer::Rescuable
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching::ConfigMethods
  include ::AbstractController::Caching
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActiveSupport::Rescuable::ClassMethods
  extend ::ActionMailer::Rescuable::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::ActionView::ViewPaths::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionView::Rendering::ClassMethods
  extend ::ActionView::Layouts::ClassMethods

  # Instantiate a new mailer object. If +method_name+ is not +nil+, the mailer
  # will be initialized according to the named method. If not, the mailer will
  # remain uninitialized (useful when you only need to invoke the "receive"
  # method, for instance).
  #
  # @return [Base] a new instance of Base
  def initialize; end

  def _helper_methods; end
  def _helper_methods=(_arg0); end
  def _helper_methods?; end
  def _helpers; end
  def _helpers=(_arg0); end
  def _helpers?; end
  def _process_action_callbacks; end
  def _process_action_callbacks?; end
  def _protected_ivars; end
  def _run_process_action_callbacks(&block); end
  def _view_cache_dependencies; end
  def _view_cache_dependencies=(_arg0); end
  def _view_cache_dependencies?; end
  def _view_paths; end
  def _view_paths=(_arg0); end
  def _view_paths?; end
  def asset_host; end
  def asset_host=(value); end
  def assets_dir; end
  def assets_dir=(value); end

  # Allows you to add attachments to an email, like so:
  #
  #  mail.attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
  #
  # If you do this, then Mail will take the file name and work out the mime type.
  # It will also set the Content-Type, Content-Disposition, Content-Transfer-Encoding
  # and encode the contents of the attachment in Base64.
  #
  # You can also specify overrides if you want by passing a hash instead of a string:
  #
  #  mail.attachments['filename.jpg'] = {mime_type: 'application/gzip',
  #                                      content: File.read('/path/to/filename.jpg')}
  #
  # If you want to use encoding other than Base64 then you will need to pass encoding
  # type along with the pre-encoded content as Mail doesn't know how to decode the
  # data:
  #
  #  file_content = SpecialEncode(File.read('/path/to/filename.jpg'))
  #  mail.attachments['filename.jpg'] = {mime_type: 'application/gzip',
  #                                      content: file_content }
  #
  # You can also search for specific attachments:
  #
  #  # By Filename
  #  mail.attachments['filename.jpg']   # => Mail::Part object or nil
  #
  #  # or by index
  #  mail.attachments[0]                # => Mail::Part (first attachment)
  def attachments; end

  def default_asset_host_protocol; end
  def default_asset_host_protocol=(value); end
  def default_params; end
  def default_params=(_arg0); end
  def default_params?; end
  def default_static_extension; end
  def default_static_extension=(value); end
  def deliver_later_queue_name; end
  def deliver_later_queue_name=(obj); end
  def delivery_method; end
  def delivery_method=(_arg0); end
  def delivery_method?; end
  def delivery_methods; end
  def delivery_methods=(_arg0); end
  def delivery_methods?; end
  def file_settings; end
  def file_settings=(_arg0); end
  def file_settings?; end
  def fragment_cache_keys; end
  def fragment_cache_keys=(_arg0); end
  def fragment_cache_keys?; end

  # Allows you to pass random and unusual headers to the new <tt>Mail::Message</tt>
  # object which will add them to itself.
  #
  #   headers['X-Special-Domain-Specific-Header'] = "SecretValue"
  #
  # You can also pass a hash into headers of header field names and values,
  # which will then be set on the <tt>Mail::Message</tt> object:
  #
  #   headers 'X-Special-Domain-Specific-Header' => "SecretValue",
  #           'In-Reply-To' => incoming.message_id
  #
  # The resulting <tt>Mail::Message</tt> will have the following in its header:
  #
  #   X-Special-Domain-Specific-Header: SecretValue
  #
  # Note about replacing already defined headers:
  #
  # * +subject+
  # * +sender+
  # * +from+
  # * +to+
  # * +cc+
  # * +bcc+
  # * +reply-to+
  # * +orig-date+
  # * +message-id+
  # * +references+
  #
  # Fields can only appear once in email headers while other fields such as
  # <tt>X-Anything</tt> can appear multiple times.
  #
  # If you want to replace any header which already exists, first set it to
  # +nil+ in order to reset the value otherwise another field will be added
  # for the same header.
  def headers(args = T.unsafe(nil)); end

  def javascripts_dir; end
  def javascripts_dir=(value); end
  def logger; end
  def logger=(value); end

  # The main method that creates the message and renders the email templates. There are
  # two ways to call this method, with a block, or without a block.
  #
  # It accepts a headers hash. This hash allows you to specify
  # the most used headers in an email message, these are:
  #
  # * +:subject+ - The subject of the message, if this is omitted, Action Mailer will
  #   ask the Rails I18n class for a translated +:subject+ in the scope of
  #   <tt>[mailer_scope, action_name]</tt> or if this is missing, will translate the
  #   humanized version of the +action_name+
  # * +:to+ - Who the message is destined for, can be a string of addresses, or an array
  #   of addresses.
  # * +:from+ - Who the message is from
  # * +:cc+ - Who you would like to Carbon-Copy on this email, can be a string of addresses,
  #   or an array of addresses.
  # * +:bcc+ - Who you would like to Blind-Carbon-Copy on this email, can be a string of
  #   addresses, or an array of addresses.
  # * +:reply_to+ - Who to set the Reply-To header of the email to.
  # * +:date+ - The date to say the email was sent on.
  #
  # You can set default values for any of the above headers (except +:date+)
  # by using the ::default class method:
  #
  #  class Notifier < ActionMailer::Base
  #    default from: 'no-reply@test.lindsaar.net',
  #            bcc: 'email_logger@test.lindsaar.net',
  #            reply_to: 'bounces@test.lindsaar.net'
  #  end
  #
  # If you need other headers not listed above, you can either pass them in
  # as part of the headers hash or use the <tt>headers['name'] = value</tt>
  # method.
  #
  # When a +:return_path+ is specified as header, that value will be used as
  # the 'envelope from' address for the Mail message. Setting this is useful
  # when you want delivery notifications sent to a different address than the
  # one in +:from+. Mail will actually use the +:return_path+ in preference
  # to the +:sender+ in preference to the +:from+ field for the 'envelope
  # from' value.
  #
  # If you do not pass a block to the +mail+ method, it will find all
  # templates in the view paths using by default the mailer name and the
  # method name that it is being called from, it will then create parts for
  # each of these templates intelligently, making educated guesses on correct
  # content type and sequence, and return a fully prepared <tt>Mail::Message</tt>
  # ready to call <tt>:deliver</tt> on to send.
  #
  # For example:
  #
  #   class Notifier < ActionMailer::Base
  #     default from: 'no-reply@test.lindsaar.net'
  #
  #     def welcome
  #       mail(to: 'mikel@test.lindsaar.net')
  #     end
  #   end
  #
  # Will look for all templates at "app/views/notifier" with name "welcome".
  # If no welcome template exists, it will raise an ActionView::MissingTemplate error.
  #
  # However, those can be customized:
  #
  #   mail(template_path: 'notifications', template_name: 'another')
  #
  # And now it will look for all templates at "app/views/notifications" with name "another".
  #
  # If you do pass a block, you can render specific templates of your choice:
  #
  #   mail(to: 'mikel@test.lindsaar.net') do |format|
  #     format.text
  #     format.html
  #   end
  #
  # You can even render plain text directly without using a template:
  #
  #   mail(to: 'mikel@test.lindsaar.net') do |format|
  #     format.text { render plain: "Hello Mikel!" }
  #     format.html { render html: "<h1>Hello Mikel!</h1>".html_safe }
  #   end
  #
  # Which will render a +multipart/alternative+ email with +text/plain+ and
  # +text/html+ parts.
  #
  # The block syntax also allows you to customize the part headers if desired:
  #
  #   mail(to: 'mikel@test.lindsaar.net') do |format|
  #     format.html
  #   end
  def mail(headers = T.unsafe(nil), &block); end

  # Returns the name of the mailer object.
  def mailer_name; end

  def message; end
  def message=(_arg0); end
  def perform_caching; end
  def perform_caching=(value); end
  def perform_deliveries; end
  def perform_deliveries=(obj); end
  def preview_interceptors; end
  def preview_path; end
  def process(method_name, *args); end
  def raise_delivery_errors; end
  def raise_delivery_errors=(obj); end
  def relative_url_root; end
  def relative_url_root=(value); end
  def rescue_handlers; end
  def rescue_handlers=(_arg0); end
  def rescue_handlers?; end
  def sendmail_settings; end
  def sendmail_settings=(_arg0); end
  def sendmail_settings?; end
  def show_previews; end
  def smtp_settings; end
  def smtp_settings=(_arg0); end
  def smtp_settings?; end
  def stylesheets_dir; end
  def stylesheets_dir=(value); end
  def test_settings; end
  def test_settings=(_arg0); end
  def test_settings?; end

  protected

  # Translates the +subject+ using Rails I18n class under <tt>[mailer_scope, action_name]</tt> scope.
  # If it does not find a translation for the +subject+ under the specified scope it will default to a
  # humanized version of the <tt>action_name</tt>.
  # If the subject has interpolations, you can pass them through the +interpolations+ parameter.
  def default_i18n_subject(interpolations = T.unsafe(nil)); end

  # Used by #mail to set the content type of the message.
  #
  # It will use the given +user_content_type+, or multipart if the mail
  # message has any attachments. If the attachments are inline, the content
  # type will be "multipart/related", otherwise "multipart/mixed".
  #
  # If there is no content type passed in via headers, and there are no
  # attachments, or the message is multipart, then the default content type is
  # used.
  def set_content_type(m, user_content_type, class_default); end

  private

  def _layout(formats); end
  def apply_defaults(headers); end
  def assign_headers_to_message(message, headers); end
  def collect_responses(headers); end
  def collect_responses_from_templates(headers); end
  def create_parts_from_responses(m, responses); end
  def each_template(paths, name, &block); end
  def insert_part(container, response, charset); end
  def instrument_name; end

  # This and #instrument_name is for caching instrument
  def instrument_payload(key); end

  class << self
    def _helper_methods; end
    def _helper_methods=(val); end
    def _helper_methods?; end
    def _helpers; end
    def _helpers=(val); end
    def _helpers?; end
    def _layout; end
    def _layout=(val); end
    def _layout?; end
    def _layout_conditions; end
    def _layout_conditions=(val); end
    def _layout_conditions?; end
    def _process_action_callbacks; end
    def _process_action_callbacks=(val); end
    def _process_action_callbacks?; end
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(val); end
    def _view_cache_dependencies?; end
    def _view_paths; end
    def _view_paths=(val); end
    def _view_paths?; end
    def asset_host; end
    def asset_host=(value); end
    def assets_dir; end
    def assets_dir=(value); end

    # Returns the name of current mailer. This method is also being used as a path for a view lookup.
    # If this is an anonymous mailer, this method will return +anonymous+ instead.
    def controller_path; end

    # Sets the defaults through app configuration:
    #
    #     config.action_mailer.default(from: "no-reply@example.org")
    #
    # Aliased by ::default_options=
    def default(value = T.unsafe(nil)); end

    def default_asset_host_protocol; end
    def default_asset_host_protocol=(value); end

    # Sets the defaults through app configuration:
    #
    #     config.action_mailer.default(from: "no-reply@example.org")
    #
    # Aliased by ::default_options=
    # Allows to set defaults through app configuration:
    #
    #    config.action_mailer.default_options = { from: "no-reply@example.org" }
    def default_options=(value = T.unsafe(nil)); end

    def default_params; end
    def default_params=(val); end
    def default_params?; end
    def default_static_extension; end
    def default_static_extension=(value); end
    def deliver_later_queue_name; end
    def deliver_later_queue_name=(obj); end

    # Wraps an email delivery inside of <tt>ActiveSupport::Notifications</tt> instrumentation.
    #
    # This method is actually called by the <tt>Mail::Message</tt> object itself
    # through a callback when you call <tt>:deliver</tt> on the <tt>Mail::Message</tt>,
    # calling +deliver_mail+ directly and passing a <tt>Mail::Message</tt> will do
    # nothing except tell the logger you sent the email.
    def deliver_mail(mail); end

    def delivery_method; end
    def delivery_method=(val); end
    def delivery_method?; end
    def delivery_methods; end
    def delivery_methods=(val); end
    def delivery_methods?; end
    def file_settings; end
    def file_settings=(val); end
    def file_settings?; end
    def fragment_cache_keys; end
    def fragment_cache_keys=(val); end
    def fragment_cache_keys?; end
    def javascripts_dir; end
    def javascripts_dir=(value); end
    def logger; end
    def logger=(value); end

    # Returns the name of current mailer. This method is also being used as a path for a view lookup.
    # If this is an anonymous mailer, this method will return +anonymous+ instead.
    def mailer_name; end

    # Allows to set the name of current mailer.
    def mailer_name=(_arg0); end

    def perform_caching; end
    def perform_caching=(value); end
    def perform_deliveries; end
    def perform_deliveries=(obj); end
    def preview_interceptors; end
    def preview_interceptors=(obj); end
    def preview_path; end
    def preview_path=(obj); end
    def raise_delivery_errors; end
    def raise_delivery_errors=(obj); end

    # Receives a raw email, parses it into an email object, decodes it,
    # instantiates a new mailer, and passes the email object to the mailer
    # object's +receive+ method.
    #
    # If you want your mailer to be able to process incoming messages, you'll
    # need to implement a +receive+ method that accepts the raw email string
    # as a parameter:
    #
    #   class MyMailer < ActionMailer::Base
    #     def receive(mail)
    #       # ...
    #     end
    #   end
    def receive(raw_mail); end

    # Register an Interceptor which will be called before mail is sent.
    # Either a class, string or symbol can be passed in as the Interceptor.
    # If a string or symbol is passed in it will be camelized and constantized.
    def register_interceptor(interceptor); end

    # Register one or more Interceptors which will be called before mail is sent.
    def register_interceptors(*interceptors); end

    # Register an Observer which will be notified when mail is delivered.
    # Either a class, string or symbol can be passed in as the Observer.
    # If a string or symbol is passed in it will be camelized and constantized.
    def register_observer(observer); end

    # Register one or more Observers which will be notified when mail is delivered.
    def register_observers(*observers); end

    def relative_url_root; end
    def relative_url_root=(value); end
    def rescue_handlers; end
    def rescue_handlers=(val); end
    def rescue_handlers?; end
    def sendmail_settings; end
    def sendmail_settings=(val); end
    def sendmail_settings?; end
    def show_previews; end
    def show_previews=(obj); end
    def smtp_settings; end
    def smtp_settings=(val); end
    def smtp_settings?; end
    def stylesheets_dir; end
    def stylesheets_dir=(value); end

    # Emails do not support relative path links.
    #
    # @return [Boolean]
    def supports_path?; end

    def test_settings; end
    def test_settings=(val); end
    def test_settings?; end

    protected

    def method_missing(method_name, *args); end
    def set_payload_for_mail(payload, mail); end

    private

    def observer_class_for(value); end

    # @return [Boolean]
    def respond_to_missing?(method, include_all = T.unsafe(nil)); end
  end
end

class ActionMailer::Base::LateAttachmentsProxy < ::SimpleDelegator
  def []=(_name, _content); end
  def inline; end

  private

  # @raise [RuntimeError]
  def _raise_error; end
end

class ActionMailer::Base::NullMail
  def body; end
  def header; end
  def method_missing(*args); end

  # @return [Boolean]
  def respond_to?(string, include_all = T.unsafe(nil)); end
end

ActionMailer::Base::PROTECTED_IVARS = T.let(T.unsafe(nil), Set)

class ActionMailer::Collector
  include ::AbstractController::Collector

  # @return [Collector] a new instance of Collector
  def initialize(context, &block); end

  # @raise [ArgumentError]
  def all(*args, &block); end

  # @raise [ArgumentError]
  def any(*args, &block); end

  def custom(mime, options = T.unsafe(nil)); end

  # Returns the value of attribute responses.
  def responses; end
end

# The <tt>ActionMailer::DeliveryJob</tt> class is used when you
# want to send emails outside of the request-response cycle.
#
# Exceptions are rescued and handled by the mailer class.
class ActionMailer::DeliveryJob < ::ActiveJob::Base
  def perform(mailer, mail_method, delivery_method, *args); end

  private

  def handle_exception_with_mailer_class(exception); end

  # "Deserialize" the mailer class name by hand in case another argument
  # (like a Global ID reference) raised DeserializationError.
  def mailer_class; end

  class << self
    def queue_name; end
    def rescue_handlers; end
  end
end

# This module handles everything related to mail delivery, from registering
# new delivery methods to configuring the mail object to be sent.
module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActionMailer::DeliveryMethods::ClassMethods

  def wrap_delivery_behavior!(*args); end

  module GeneratedClassMethods
    def delivery_method; end
    def delivery_method=(value); end
    def delivery_method?; end
    def delivery_methods; end
    def delivery_methods=(value); end
    def delivery_methods?; end
    def file_settings; end
    def file_settings=(value); end
    def file_settings?; end
    def sendmail_settings; end
    def sendmail_settings=(value); end
    def sendmail_settings?; end
    def smtp_settings; end
    def smtp_settings=(value); end
    def smtp_settings?; end
    def test_settings; end
    def test_settings=(value); end
    def test_settings?; end
  end

  module GeneratedInstanceMethods
    def delivery_method; end
    def delivery_method=(value); end
    def delivery_method?; end
    def delivery_methods; end
    def delivery_methods=(value); end
    def delivery_methods?; end
    def file_settings; end
    def file_settings=(value); end
    def file_settings?; end
    def sendmail_settings; end
    def sendmail_settings=(value); end
    def sendmail_settings?; end
    def smtp_settings; end
    def smtp_settings=(value); end
    def smtp_settings?; end
    def test_settings; end
    def test_settings=(value); end
    def test_settings?; end
  end
end

# Helpers for creating and wrapping delivery behavior, used by DeliveryMethods.
module ActionMailer::DeliveryMethods::ClassMethods
  # Adds a new delivery method through the given class using the given
  # symbol as alias and the default options supplied.
  #
  #   add_delivery_method :sendmail, Mail::Sendmail,
  #     location:  '/usr/sbin/sendmail',
  #     arguments: '-i'
  def add_delivery_method(symbol, klass, default_options = T.unsafe(nil)); end

  def deliveries(*args, &block); end
  def deliveries=(arg); end
  def wrap_delivery_behavior(mail, method = T.unsafe(nil), options = T.unsafe(nil)); end
end

# Implements a mailer preview interceptor that converts image tag src attributes
# that use inline cid: style urls to data: style urls so that they are visible
# when previewing an HTML email in a web browser.
#
# This interceptor is enabled by default. To disable it, delete it from the
# <tt>ActionMailer::Base.preview_interceptors</tt> array:
#
#   ActionMailer::Base.preview_interceptors.delete(ActionMailer::InlinePreviewInterceptor)
class ActionMailer::InlinePreviewInterceptor
  include ::Base64

  # @return [InlinePreviewInterceptor] a new instance of InlinePreviewInterceptor
  def initialize(message); end

  def transform!; end

  private

  def data_url(part); end
  def find_part(cid); end
  def html_part; end
  def html_source; end
  def message; end

  class << self
    def previewing_email(message); end
  end
end

ActionMailer::InlinePreviewInterceptor::PATTERN = T.let(T.unsafe(nil), Regexp)

# Implements the ActiveSupport::LogSubscriber for logging notifications when
# email is delivered or received.
class ActionMailer::LogSubscriber < ::ActiveSupport::LogSubscriber
  # An email was delivered.
  def deliver(event); end

  # Use the logger configured for ActionMailer::Base.
  def logger; end

  # An email was generated.
  def process(event); end

  # An email was received.
  def receive(event); end
end

# Provides helper methods for ActionMailer::Base that can be used for easily
# formatting messages, accessing mailer or message instances, and the
# attachments list.
module ActionMailer::MailHelper
  # Access the message attachments list.
  def attachments; end

  # Take the text and format it, indented two spaces for each line, and
  # wrapped at 72 columns:
  #
  #   text = <<-TEXT
  #     This is
  #     the      paragraph.
  #
  #     * item1 * item2
  #   TEXT
  #
  #   block_format text
  #   # => "  This is the paragraph.\n\n  * item1\n  * item2\n"
  def block_format(text); end

  # Returns +text+ wrapped at +len+ columns and indented +indent+ spaces.
  # By default column length +len+ equals 72 characters and indent
  # +indent+ equal two spaces.
  #
  #   my_text = 'Here is a sample text with more than 40 characters'
  #
  #   format_paragraph(my_text, 25, 4)
  #   # => "    Here is a sample text with\n    more than 40 characters"
  def format_paragraph(text, len = T.unsafe(nil), indent = T.unsafe(nil)); end

  # Access the mailer instance.
  def mailer; end

  # Access the message instance.
  def message; end
end

# The <tt>ActionMailer::MessageDelivery</tt> class is used by
# <tt>ActionMailer::Base</tt> when creating a new mailer.
# <tt>MessageDelivery</tt> is a wrapper (+Delegator+ subclass) around a lazy
# created <tt>Mail::Message</tt>. You can get direct access to the
# <tt>Mail::Message</tt>, deliver the email or schedule the email to be sent
# through Active Job.
#
#   Notifier.welcome(User.first)               # an ActionMailer::MessageDelivery object
#   Notifier.welcome(User.first).deliver_now   # sends the email
#   Notifier.welcome(User.first).deliver_later # enqueue email delivery as a job through Active Job
#   Notifier.welcome(User.first).message       # a Mail::Message object
class ActionMailer::MessageDelivery
  # @return [MessageDelivery] a new instance of MessageDelivery
  def initialize(mailer_class, action, *args); end

  # Method calls are delegated to the Mail::Message that's ready to deliver.
  def __getobj__; end

  # Unused except for delegator internals (dup, marshaling).
  def __setobj__(mail_message); end

  # Enqueues the email to be delivered through Active Job. When the
  # job runs it will send the email using +deliver_now+.
  #
  #   Notifier.welcome(User.first).deliver_later
  #   Notifier.welcome(User.first).deliver_later(wait: 1.hour)
  #   Notifier.welcome(User.first).deliver_later(wait_until: 10.hours.from_now)
  #
  # Options:
  #
  # * <tt>:wait</tt> - Enqueue the email to be delivered with a delay.
  # * <tt>:wait_until</tt> - Enqueue the email to be delivered at (after) a specific date / time.
  # * <tt>:queue</tt> - Enqueue the email on the specified queue.
  def deliver_later(options = T.unsafe(nil)); end

  # Enqueues the email to be delivered through Active Job. When the
  # job runs it will send the email using +deliver_now!+. That means
  # that the message will be sent bypassing checking +perform_deliveries+
  # and +raise_delivery_errors+, so use with caution.
  #
  #   Notifier.welcome(User.first).deliver_later!
  #   Notifier.welcome(User.first).deliver_later!(wait: 1.hour)
  #   Notifier.welcome(User.first).deliver_later!(wait_until: 10.hours.from_now)
  #
  # Options:
  #
  # * <tt>:wait</tt> - Enqueue the email to be delivered with a delay
  # * <tt>:wait_until</tt> - Enqueue the email to be delivered at (after) a specific date / time
  # * <tt>:queue</tt> - Enqueue the email on the specified queue
  def deliver_later!(options = T.unsafe(nil)); end

  # Delivers an email:
  #
  #   Notifier.welcome(User.first).deliver_now
  def deliver_now; end

  # Delivers an email without checking +perform_deliveries+ and +raise_delivery_errors+,
  # so use with caution.
  #
  #   Notifier.welcome(User.first).deliver_now!
  def deliver_now!; end

  # Returns the resulting Mail::Message
  def message; end

  # Was the delegate loaded, causing the mailer action to be processed?
  #
  # @return [Boolean]
  def processed?; end

  private

  def enqueue_delivery(delivery_method, options = T.unsafe(nil)); end

  # Returns the processed Mailer instance. We keep this instance
  # on hand so we can delegate exception handling to it.
  def processed_mailer; end
end

class ActionMailer::NonInferrableMailerError < ::StandardError
  # @return [NonInferrableMailerError] a new instance of NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker

  class << self
    # Returns all mailer preview classes.
    def all; end

    # Returns the mail object for the given email name. The registered preview
    # interceptors will be informed so that they can transform the message
    # as they would if the mail was actually being delivered.
    def call(email); end

    # Returns true if the email exists.
    #
    # @return [Boolean]
    def email_exists?(email); end

    # Returns all of the available email previews.
    def emails; end

    # Returns true if the preview exists.
    #
    # @return [Boolean]
    def exists?(preview); end

    # Find a mailer preview by its underscored class name.
    def find(preview); end

    # Returns the underscored name of the mailer preview without the suffix.
    def preview_name; end

    protected

    def inform_preview_interceptors(message); end
    def load_previews; end
    def preview_path; end
    def show_previews; end
  end
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionMailer::Previews::ClassMethods
end

module ActionMailer::Previews::ClassMethods
  # Register an Interceptor which will be called before mail is previewed.
  # Either a class or a string can be passed in as the Interceptor. If a
  # string is passed in it will be <tt>constantize</tt>d.
  def register_preview_interceptor(interceptor); end

  # Register one or more Interceptors which will be called before mail is previewed.
  def register_preview_interceptors(*interceptors); end
end

class ActionMailer::Railtie < ::Rails::Railtie; end

# Provides `rescue_from` for mailers. Wraps mailer action processing,
# mail job processing, and mail delivery.
module ActionMailer::Rescuable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Rescuable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Rescuable::ClassMethods
  mixes_in_class_methods ::ActionMailer::Rescuable::ClassMethods

  def handle_exceptions; end

  private

  def process(*_arg0); end

  module GeneratedClassMethods
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end
  end

  module GeneratedInstanceMethods
    def rescue_handlers; end
    def rescue_handlers=(value); end
    def rescue_handlers?; end
  end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

class ActionMailer::TestCase < ::ActiveSupport::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  extend ::ActionMailer::TestCase::Behavior::ClassMethods

  def _mailer_class; end
  def _mailer_class=(_arg0); end
  def _mailer_class?; end

  class << self
    def _mailer_class; end
    def _mailer_class=(val); end
    def _mailer_class?; end
    def _setup_callbacks; end
    def _teardown_callbacks; end
  end
end

module ActionMailer::TestCase::Behavior
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Testing::ConstantLookup

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveSupport::Testing::ConstantLookup::ClassMethods
  mixes_in_class_methods ::ActionMailer::TestCase::Behavior::ClassMethods

  protected

  def initialize_test_deliveries; end
  def restore_delivery_method; end
  def restore_test_deliveries; end
  def set_delivery_method(method); end
  def set_expected_mail; end

  private

  def charset; end
  def encode(subject); end
  def read_fixture(action); end

  module GeneratedClassMethods
    def _mailer_class; end
    def _mailer_class=(value); end
    def _mailer_class?; end
  end

  module GeneratedInstanceMethods
    def _mailer_class; end
    def _mailer_class=(value); end
    def _mailer_class?; end
  end
end

module ActionMailer::TestCase::Behavior::ClassMethods
  # @raise [NonInferrableMailerError]
  def determine_default_mailer(name); end

  def mailer_class; end
  def tests(mailer); end
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern

  private

  def clear_test_deliveries; end
end

# Provides helper methods for testing Action Mailer, including #assert_emails
# and #assert_no_emails.
module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper

  # Asserts that the number of emails sent matches the given number.
  #
  #   def test_emails
  #     assert_emails 0
  #     ContactMailer.welcome.deliver_now
  #     assert_emails 1
  #     ContactMailer.welcome.deliver_now
  #     assert_emails 2
  #   end
  #
  # If a block is passed, that block should cause the specified number of
  # emails to be sent.
  #
  #   def test_emails_again
  #     assert_emails 1 do
  #       ContactMailer.welcome.deliver_now
  #     end
  #
  #     assert_emails 2 do
  #       ContactMailer.welcome.deliver_now
  #       ContactMailer.welcome.deliver_now
  #     end
  #   end
  def assert_emails(number); end

  # Asserts that the number of emails enqueued for later delivery matches
  # the given number.
  #
  #   def test_emails
  #     assert_enqueued_emails 0
  #     ContactMailer.welcome.deliver_later
  #     assert_enqueued_emails 1
  #     ContactMailer.welcome.deliver_later
  #     assert_enqueued_emails 2
  #   end
  #
  # If a block is passed, that block should cause the specified number of
  # emails to be enqueued.
  #
  #   def test_emails_again
  #     assert_enqueued_emails 1 do
  #       ContactMailer.welcome.deliver_later
  #     end
  #
  #     assert_enqueued_emails 2 do
  #       ContactMailer.welcome.deliver_later
  #       ContactMailer.welcome.deliver_later
  #     end
  #   end
  def assert_enqueued_emails(number, &block); end

  # Asserts that no emails have been sent.
  #
  #   def test_emails
  #     assert_no_emails
  #     ContactMailer.welcome.deliver_now
  #     assert_emails 1
  #   end
  #
  # If a block is passed, that block should not cause any emails to be sent.
  #
  #   def test_emails_again
  #     assert_no_emails do
  #       # No emails should be sent from this block
  #     end
  #   end
  #
  # Note: This assertion is simply a shortcut for:
  #
  #   assert_emails 0
  def assert_no_emails(&block); end

  # Asserts that no emails are enqueued for later delivery.
  #
  #   def test_no_emails
  #     assert_no_enqueued_emails
  #     ContactMailer.welcome.deliver_later
  #     assert_enqueued_emails 1
  #   end
  #
  # If a block is provided, it should not cause any emails to be enqueued.
  #
  #   def test_no_emails
  #     assert_no_enqueued_emails do
  #       # No emails should be enqueued from this block
  #     end
  #   end
  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::VERSION; end
ActionMailer::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActionMailer::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActionMailer::VERSION::PRE = T.let(T.unsafe(nil), String)
ActionMailer::VERSION::STRING = T.let(T.unsafe(nil), String)
ActionMailer::VERSION::TINY = T.let(T.unsafe(nil), Integer)
